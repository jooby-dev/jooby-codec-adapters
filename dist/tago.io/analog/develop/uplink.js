//#region [autogenerated jooby-codec bundle from index.js]
var fromBytes, getBytesFromHex;

(function () {
    'use strict';

    const hexFormatOptions = {
        separator: ' ',
        prefix: ''
    };

    const INT8_SIZE = 1;
    const INT16_SIZE = 2;
    const INT24_SIZE = 3;
    const INT32_SIZE = 4;
    const { log, pow, LN2 } = Math;
    const readFloat = (buffer, offset, isLittleEndian, mLen, bytes) => {
        var e, m, eLen = bytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLittleEndian ? bytes - 1 : 0, d = isLittleEndian ? -1 : 1, s = buffer[offset + i];
        i += d;
        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 0x100 + buffer[offset + i], i += d, nBits -= 8)
            ;
        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 0x100 + buffer[offset + i], i += d, nBits -= 8)
            ;
        if (e === 0) {
            e = 1 - eBias;
        }
        else if (e === eMax) {
            return m ? NaN : s ? -Infinity : Infinity;
        }
        else {
            m = m + pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * pow(2, e - mLen);
    };
    const writeFloat = (buffer, offset, value, isLittleEndian, mLen, bytes) => {
        var e, m, c, eLen = bytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = (mLen === 23 ? pow(2, -24) - pow(2, -77) : 0), i = isLittleEndian ? 0 : bytes - 1, d = isLittleEndian ? 1 : -1, s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
        value < 0 && (value = -value);
        if (value !== value || value === Infinity) {
            m = value !== value ? 1 : 0;
            e = eMax;
        }
        else {
            e = (log(value) / LN2) | 0;
            if (value * (c = pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            }
            else {
                value += rt * pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }
            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            }
            else if (e + eBias >= 1) {
                m = (value * c - 1) * pow(2, mLen);
                e = e + eBias;
            }
            else {
                m = value * pow(2, eBias - 1) * pow(2, mLen);
                e = 0;
            }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 0x100, mLen -= 8)
            ;
        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 0x100, eLen -= 8)
            ;
        buffer[offset + i - d] |= s * 0x80;
    };
    const be2 = [1, 0];
    const be3 = [2, 1, 0];
    const be4 = [3, 2, 1, 0];
    const le2 = [0, 1];
    const le3 = [0, 1, 2];
    const le4 = [0, 1, 2, 3];
    const readUint8 = (buffer, offset) => buffer[offset];
    const readUint16 = (buffer, offset, isLittleEndian) => {
        const order = isLittleEndian ? le2 : be2;
        const b0 = buffer[offset + order[0]];
        const b1 = buffer[offset + order[1]] << 8;
        return b0 | b1;
    };
    const readUint24 = (buffer, offset, isLittleEndian) => {
        const order = isLittleEndian ? le3 : be3;
        const b0 = buffer[offset + order[0]];
        const b1 = buffer[offset + order[1]] << 8;
        const b2 = buffer[offset + order[2]] << 16;
        return b0 | b1 | b2;
    };
    const readUint32 = (buffer, offset, isLittleEndian) => {
        const order = isLittleEndian ? le4 : be4;
        const b0 = buffer[offset + order[3]] * 0x1000000;
        const b1 = buffer[offset + order[2]] * 0x10000;
        const b2 = buffer[offset + order[1]] * 0x100;
        const b3 = buffer[offset + order[0]];
        return b0 + b1 + b2 + b3;
    };
    const writeUint8 = (buffer, offset, value) => {
        buffer[offset] = value & 0xff;
    };
    const writeUint16 = (buffer, offset, value, isLittleEndian) => {
        const order = isLittleEndian ? le2 : be2;
        buffer[offset + order[0]] = value & 0xff;
        buffer[offset + order[1]] = value >>> 8 & 0xff;
    };
    const writeUint24 = (buffer, offset, value, isLittleEndian) => {
        const order = isLittleEndian ? le3 : be3;
        buffer[offset + order[0]] = value & 0xff;
        buffer[offset + order[1]] = value >>> 8 & 0xff;
        buffer[offset + order[2]] = value >>> 16 & 0xff;
    };
    const writeUint32 = (buffer, offset, value, isLittleEndian) => {
        const order = isLittleEndian ? le4 : be4;
        buffer[offset + order[0]] = value & 0xff;
        buffer[offset + order[1]] = value >>> 8 & 0xff;
        buffer[offset + order[2]] = value >>> 16 & 0xff;
        buffer[offset + order[3]] = value >>> 24 & 0xff;
    };
    function BinaryBuffer(dataOrLength, isLittleEndian = true) {
        if (typeof dataOrLength === 'number') {
            const bytes = new Array(dataOrLength).fill(0);
            this.data = bytes;
        }
        else {
            this.data = dataOrLength;
        }
        this.offset = 0;
        this.isLittleEndian = isLittleEndian;
    }
    BinaryBuffer.prototype = {
        toUint8Array() {
            return this.data;
        },
        seek(position) {
            if (position < 0 || position >= this.data.length) {
                throw new Error('Invalid position.');
            }
            this.offset = position;
        },
        setInt8(value) {
            writeUint8(this.data, this.offset, value < 0 ? value | 0x100 : value);
            this.offset += INT8_SIZE;
        },
        getInt8() {
            const result = readUint8(this.data, this.offset);
            this.offset += INT8_SIZE;
            return result & 0x80 ? result ^ -256 : result;
        },
        setUint8(value) {
            writeUint8(this.data, this.offset, value);
            this.offset += INT8_SIZE;
        },
        getUint8() {
            const result = readUint8(this.data, this.offset);
            this.offset += INT8_SIZE;
            return result;
        },
        setInt16(value, isLittleEndian = this.isLittleEndian) {
            writeUint16(this.data, this.offset, value < 0 ? value | 0x10000 : value, isLittleEndian);
            this.offset += INT16_SIZE;
        },
        getInt16(isLittleEndian = this.isLittleEndian) {
            const result = readUint16(this.data, this.offset, isLittleEndian);
            this.offset += INT16_SIZE;
            return result & 0x8000 ? result ^ -65536 : result;
        },
        setUint16(value, isLittleEndian = this.isLittleEndian) {
            writeUint16(this.data, this.offset, value, isLittleEndian);
            this.offset += INT16_SIZE;
        },
        getUint16(isLittleEndian = this.isLittleEndian) {
            const result = readUint16(this.data, this.offset, isLittleEndian);
            this.offset += INT16_SIZE;
            return result;
        },
        setInt24(value, isLittleEndian = this.isLittleEndian) {
            writeUint24(this.data, this.offset, value < 0 ? value | 0x1000000 : value, isLittleEndian);
            this.offset += INT24_SIZE;
        },
        getInt24(isLittleEndian = this.isLittleEndian) {
            const result = readUint24(this.data, this.offset, isLittleEndian);
            this.offset += INT24_SIZE;
            return result & 0x800000 ? result ^ -16777216 : result;
        },
        setUint24(value, isLittleEndian = this.isLittleEndian) {
            writeUint24(this.data, this.offset, value, isLittleEndian);
            this.offset += INT24_SIZE;
        },
        getUint24(isLittleEndian = this.isLittleEndian) {
            const result = readUint24(this.data, this.offset, isLittleEndian);
            this.offset += INT24_SIZE;
            return result;
        },
        setInt32(value, isLittleEndian = this.isLittleEndian) {
            writeUint32(this.data, this.offset, value < 0 ? value | 0x100000000 : value, isLittleEndian);
            this.offset += INT32_SIZE;
        },
        getInt32(isLittleEndian = this.isLittleEndian) {
            const result = readUint32(this.data, this.offset, isLittleEndian);
            this.offset += INT32_SIZE;
            return result & 0x80000000 ? result ^ -4294967296 : result;
        },
        setUint32(value, isLittleEndian = this.isLittleEndian) {
            writeUint32(this.data, this.offset, value, isLittleEndian);
            this.offset += INT32_SIZE;
        },
        getUint32(isLittleEndian = this.isLittleEndian) {
            const result = readUint32(this.data, this.offset, isLittleEndian);
            this.offset += INT32_SIZE;
            return result;
        },
        setFloat32(value, isLittleEndian = this.isLittleEndian) {
            writeFloat(this.data, this.offset, value, isLittleEndian, 23, 4);
            this.offset += INT32_SIZE;
        },
        getFloat32(isLittleEndian = this.isLittleEndian) {
            const result = readFloat(this.data, this.offset, isLittleEndian, 23, 4);
            this.offset += INT32_SIZE;
            return result;
        },
        setString(value) {
            this.setUint8(value.length);
            for (let index = 0; index < value.length; ++index) {
                this.setUint8(value.charCodeAt(index));
            }
        },
        getString() {
            const size = this.getUint8();
            const endIndex = this.offset + size;
            const chars = [];
            while (this.offset < endIndex) {
                chars.push(String.fromCharCode(this.getUint8()));
            }
            return chars.join('');
        },
        getBytesToOffset(offset = this.offset) {
            return this.data.slice(0, offset);
        },
        getBytesLeft() {
            return this.getBytes(this.bytesLeft);
        },
        getBytes(length, offset = this.offset) {
            this.offset = offset + length;
            return this.data.slice(offset, this.offset);
        },
        setBytes(data, offset = this.offset) {
            const bytes = this.data;
            bytes.splice(offset, data.length, ...data);
            this.data = bytes;
            this.offset = offset + data.length;
        }
    };
    Object.defineProperties(BinaryBuffer.prototype, {
        size: {
            get() {
                return this.data.length;
            }
        },
        isEmpty: {
            get() {
                if (this.offset > this.data.length) {
                    throw new Error(`current offset ${this.offset} is outside the bounds of the buffer`);
                }
                return this.data.length - this.offset === 0;
            }
        },
        bytesLeft: {
            get() {
                return this.data.length - this.offset;
            }
        },
        position: {
            get() {
                return this.offset;
            }
        }
    });

    const shortCommandMask = 0xe0;
    const extraCommandMask = 0x1f;
    const fromBytes$E = (bytes) => {
        if (bytes.length === 0) {
            throw new Error('Invalid buffer size');
        }
        const header = {
            shortCode: bytes[0] & shortCommandMask,
            extraCode: bytes[0] & extraCommandMask
        };
        if (header.shortCode !== 0) {
            return {
                headerSize: 1,
                commandId: bytes[0] & (~header.extraCode),
                commandSize: header.extraCode
            };
        }
        if (header.extraCode === extraCommandMask) {
            if (bytes.length < 3) {
                throw new Error('Invalid buffer size');
            }
            return {
                headerSize: 3,
                commandId: (bytes[1] << 8) | extraCommandMask,
                commandSize: bytes[2]
            };
        }
        if (bytes.length < 2) {
            throw new Error('Invalid buffer size');
        }
        return {
            headerSize: 2,
            commandId: header.extraCode,
            commandSize: bytes[1]
        };
    };

    const setTime2000$1 = 0x02;
    const setParameter$1 = 0x03;
    const getParameter$1 = 0x04;
    const getArchiveHours$1 = 0x05;
    const getArchiveDays$1 = 0x06;
    const current = 0x07;
    const time2000 = 0x09;
    const getArchiveEvents$1 = 0x0b;
    const correctTime2000$1 = 0x0c;
    const status = 0x14;
    const newEvent = 0x15;
    const dayMc = 0x16;
    const hourMc = 0x17;
    const currentMc = 0x18;
    const softRestart$1 = 0x19;
    const getArchiveHoursMc$1 = 0x1a;
    const getArchiveDaysMc$1 = 0x1b;
    const dataSegment$1 = 0x1e;
    const day = 0x20;
    const hour = 0x40;
    const lastEvent = 0x60;
    const getLmicInfo$1 = 0x21f;
    const getBatteryStatus$1 = 0x51f;
    const usWaterMeterCommand$1 = 0x71f;
    const exAbsHourMc = 0xa1f;
    const exAbsDayMc = 0xb1f;
    const getExAbsArchiveHoursMc$1 = 0xc1f;
    const getExAbsArchiveDaysMc$1 = 0xd1f;
    const exAbsCurrentMc = 0xf1f;
    const usWaterMeterBatteryStatus = 0x141f;
    const writeImage$1 = 0x2a1f;
    const verifyImage$1 = 0x2b1f;
    const updateRun$1 = 0x2c1f;
    const getArchiveHoursMcEx$1 = 0x301f;
    const hourMcEx = 0x311f;
    const getChannelsStatus$1 = 0x321f;
    const getChannelsTypes$1 = 0x331f;
    const signalQuality = 0x341f;

    var uplinkIds = /*#__PURE__*/Object.freeze({
        __proto__: null,
        correctTime2000: correctTime2000$1,
        current: current,
        currentMc: currentMc,
        dataSegment: dataSegment$1,
        day: day,
        dayMc: dayMc,
        exAbsCurrentMc: exAbsCurrentMc,
        exAbsDayMc: exAbsDayMc,
        exAbsHourMc: exAbsHourMc,
        getArchiveDays: getArchiveDays$1,
        getArchiveDaysMc: getArchiveDaysMc$1,
        getArchiveEvents: getArchiveEvents$1,
        getArchiveHours: getArchiveHours$1,
        getArchiveHoursMc: getArchiveHoursMc$1,
        getArchiveHoursMcEx: getArchiveHoursMcEx$1,
        getBatteryStatus: getBatteryStatus$1,
        getChannelsStatus: getChannelsStatus$1,
        getChannelsTypes: getChannelsTypes$1,
        getExAbsArchiveDaysMc: getExAbsArchiveDaysMc$1,
        getExAbsArchiveHoursMc: getExAbsArchiveHoursMc$1,
        getLmicInfo: getLmicInfo$1,
        getParameter: getParameter$1,
        hour: hour,
        hourMc: hourMc,
        hourMcEx: hourMcEx,
        lastEvent: lastEvent,
        newEvent: newEvent,
        setParameter: setParameter$1,
        setTime2000: setTime2000$1,
        signalQuality: signalQuality,
        softRestart: softRestart$1,
        status: status,
        time2000: time2000,
        updateRun: updateRun$1,
        usWaterMeterBatteryStatus: usWaterMeterBatteryStatus,
        usWaterMeterCommand: usWaterMeterCommand$1,
        verifyImage: verifyImage$1,
        writeImage: writeImage$1
    });

    var invertObject = (source) => {
        const target = {};
        for (const property in source) {
            const value = source[property];
            target[value] = property;
        }
        return target;
    };

    var uplinkNames = invertObject(uplinkIds);

    const id$B = correctTime2000$1;
    const COMMAND_BODY_SIZE$8 = 1;
    const fromBytes$D = (bytes) => {
        if (bytes.length !== COMMAND_BODY_SIZE$8) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        const parameters = {
            status: buffer.getUint8()
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };

    const fromObject = (bitMask = {}, booleanObject = {}) => {
        let result = 0;
        for (const name in booleanObject) {
            if (name in bitMask && booleanObject[name]) {
                result |= bitMask[name];
            }
        }
        return result;
    };
    const toObject = (bitMask = {}, value = 0) => {
        const result = {};
        for (const name in bitMask) {
            result[name] = (value & bitMask[name]) !== 0;
        }
        return result;
    };
    const extractBits = (value, bitsNumber, startIndex) => (((1 << bitsNumber) - 1) & (value >> (startIndex - 1)));

    var getHexFromBytes = (bytes, options = {}) => {
        const { separator, prefix } = Object.assign({}, hexFormatOptions, options);
        return bytes
            .map((byte) => `${prefix}${byte.toString(16).padStart(2, '0')}`)
            .join(separator);
    };

    var getBytesFromHex$1 = (hex) => {
        let cleanHex = hex.trim();
        if (!cleanHex) {
            return [];
        }
        cleanHex = cleanHex
            .replace(/0x/g, '')
            .split(/\s+/)
            .map(byte => byte.padStart(2, '0'))
            .join('');
        if (cleanHex.length % 2 !== 0) {
            cleanHex = `0${cleanHex}`;
        }
        const resultLength = cleanHex.length / 2;
        const bytes = new Array(resultLength);
        for (let index = 0; index < resultLength; index++) {
            bytes[index] = parseInt(cleanHex.substring(index * 2, index * 2 + 2), 16);
        }
        return bytes;
    };

    var roundNumber = (value, decimalPlaces = 4) => {
        const places = Math.pow(10, decimalPlaces);
        return Math.round((value * places) * (1 + Number.EPSILON)) / places;
    };

    const INITIAL_YEAR_TIMESTAMP = 946684800000;
    const MILLISECONDS_IN_SECONDS = 1000;
    const getTime2000FromDate = (date) => (date.getTime() - INITIAL_YEAR_TIMESTAMP) / MILLISECONDS_IN_SECONDS;

    const GASI1 = 1;
    const GASI2 = 2;
    const GASI3 = 3;
    const NOVATOR = 4;
    const IMP2EU = 5;
    const IMP4EU = 6;
    const MTXLORA = 7;
    const IMP2AS = 8;
    const IMP2IN = 9;
    const IMP4IN = 10;
    const ELIMP = 11;
    const GASIC = 12;
    const US_WATER = 13;
    const PLC2LORA = 14;
    const LORA = 21;
    const NBIOT = 24;

    const REPORTING_DATA_INTERVAL = 1;
    const DAY_CHECKOUT_HOUR = 4;
    const REPORTING_DATA_TYPE = 5;
    const PRIORITY_DATA_DELIVERY_TYPE = 8;
    const ACTIVATION_METHOD = 9;
    const BATTERY_DEPASSIVATION_INFO = 10;
    const BATTERY_MINIMAL_LOAD_TIME = 11;
    const CHANNELS_CONFIG = 13;
    const RX2_CONFIG = 18;
    const ABSOLUTE_DATA = 23;
    const ABSOLUTE_DATA_ENABLE = 24;
    const SERIAL_NUMBER = 25;
    const GEOLOCATION = 26;
    const EXTRA_FRAME_INTERVAL = 28;
    const ABSOLUTE_DATA_MULTI_CHANNEL = 29;
    const ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL = 30;
    const PULSE_CHANNELS_SCAN_CONFIG = 31;
    const PULSE_CHANNELS_SET_CONFIG = 32;
    const BATTERY_DEPASSIVATION_CONFIG = 33;
    const MQTT_SESSION_CONFIG = 34;
    const MQTT_BROKER_ADDRESS = 35;
    const MQTT_SSL_ENABLE = 36;
    const MQTT_TOPIC_PREFIX = 37;
    const MQTT_DATA_RECEIVE_CONFIG = 38;
    const MQTT_DATA_SEND_CONFIG = 39;
    const NBIOT_SSL_CONFIG = 40;
    const NBIOT_SSL_CACERT_WRITE = 41;
    const NBIOT_SSL_CACERT_SET = 42;
    const NBIOT_SSL_CLIENT_CERT_WRITE = 43;
    const NBIOT_SSL_CLIENT_CERT_SET = 44;
    const NBIOT_SSL_CLIENT_KEY_WRITE = 45;
    const NBIOT_SSL_CLIENT_KEY_SET = 46;
    const NBIOT_DEVICE_SOFTWARE_UPDATE = 47;
    const NBIOT_MODULE_FIRMWARE_UPDATE = 48;
    const REPORTING_DATA_CONFIG = 49;
    const EVENTS_CONFIG = 50;
    const NBIOT_MODULE_INFO = 51;
    const NBIOT_BANDS = 52;
    const NBIOT_APN = 53;
    const NBIOT_LED_INDICATION = 54;
    const NBIOT_SIM = 55;
    const CHANNEL_TYPE = 56;
    const EXTRA_PAYLOAD_ENABLE = 57;
    const TIME_SYNCHRONIZATION_PERIOD_VIA_MAC = 58;
    const KEEP_LORA_CONNECTION_ON_REMOVAL = 59;
    const NBIOT_NTP_SERVER = 60;
    const ACTIVATE_MODULE = 61;

    var deviceParameters = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ABSOLUTE_DATA: ABSOLUTE_DATA,
        ABSOLUTE_DATA_ENABLE: ABSOLUTE_DATA_ENABLE,
        ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL: ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL,
        ABSOLUTE_DATA_MULTI_CHANNEL: ABSOLUTE_DATA_MULTI_CHANNEL,
        ACTIVATE_MODULE: ACTIVATE_MODULE,
        ACTIVATION_METHOD: ACTIVATION_METHOD,
        BATTERY_DEPASSIVATION_CONFIG: BATTERY_DEPASSIVATION_CONFIG,
        BATTERY_DEPASSIVATION_INFO: BATTERY_DEPASSIVATION_INFO,
        BATTERY_MINIMAL_LOAD_TIME: BATTERY_MINIMAL_LOAD_TIME,
        CHANNELS_CONFIG: CHANNELS_CONFIG,
        CHANNEL_TYPE: CHANNEL_TYPE,
        DAY_CHECKOUT_HOUR: DAY_CHECKOUT_HOUR,
        EVENTS_CONFIG: EVENTS_CONFIG,
        EXTRA_FRAME_INTERVAL: EXTRA_FRAME_INTERVAL,
        EXTRA_PAYLOAD_ENABLE: EXTRA_PAYLOAD_ENABLE,
        GEOLOCATION: GEOLOCATION,
        KEEP_LORA_CONNECTION_ON_REMOVAL: KEEP_LORA_CONNECTION_ON_REMOVAL,
        MQTT_BROKER_ADDRESS: MQTT_BROKER_ADDRESS,
        MQTT_DATA_RECEIVE_CONFIG: MQTT_DATA_RECEIVE_CONFIG,
        MQTT_DATA_SEND_CONFIG: MQTT_DATA_SEND_CONFIG,
        MQTT_SESSION_CONFIG: MQTT_SESSION_CONFIG,
        MQTT_SSL_ENABLE: MQTT_SSL_ENABLE,
        MQTT_TOPIC_PREFIX: MQTT_TOPIC_PREFIX,
        NBIOT_APN: NBIOT_APN,
        NBIOT_BANDS: NBIOT_BANDS,
        NBIOT_DEVICE_SOFTWARE_UPDATE: NBIOT_DEVICE_SOFTWARE_UPDATE,
        NBIOT_LED_INDICATION: NBIOT_LED_INDICATION,
        NBIOT_MODULE_FIRMWARE_UPDATE: NBIOT_MODULE_FIRMWARE_UPDATE,
        NBIOT_MODULE_INFO: NBIOT_MODULE_INFO,
        NBIOT_NTP_SERVER: NBIOT_NTP_SERVER,
        NBIOT_SIM: NBIOT_SIM,
        NBIOT_SSL_CACERT_SET: NBIOT_SSL_CACERT_SET,
        NBIOT_SSL_CACERT_WRITE: NBIOT_SSL_CACERT_WRITE,
        NBIOT_SSL_CLIENT_CERT_SET: NBIOT_SSL_CLIENT_CERT_SET,
        NBIOT_SSL_CLIENT_CERT_WRITE: NBIOT_SSL_CLIENT_CERT_WRITE,
        NBIOT_SSL_CLIENT_KEY_SET: NBIOT_SSL_CLIENT_KEY_SET,
        NBIOT_SSL_CLIENT_KEY_WRITE: NBIOT_SSL_CLIENT_KEY_WRITE,
        NBIOT_SSL_CONFIG: NBIOT_SSL_CONFIG,
        PRIORITY_DATA_DELIVERY_TYPE: PRIORITY_DATA_DELIVERY_TYPE,
        PULSE_CHANNELS_SCAN_CONFIG: PULSE_CHANNELS_SCAN_CONFIG,
        PULSE_CHANNELS_SET_CONFIG: PULSE_CHANNELS_SET_CONFIG,
        REPORTING_DATA_CONFIG: REPORTING_DATA_CONFIG,
        REPORTING_DATA_INTERVAL: REPORTING_DATA_INTERVAL,
        REPORTING_DATA_TYPE: REPORTING_DATA_TYPE,
        RX2_CONFIG: RX2_CONFIG,
        SERIAL_NUMBER: SERIAL_NUMBER,
        TIME_SYNCHRONIZATION_PERIOD_VIA_MAC: TIME_SYNCHRONIZATION_PERIOD_VIA_MAC
    });

    var deviceParameterNames = invertObject(deviceParameters);

    const EMPTY_VALUE = 0xffffffff;

    const IDLE = 0;
    const PULSE_SENSOR = 1;
    const POWER_CHANNEL = 2;
    const BINARY_SENSOR = 3;
    const TEMPERATURE_SENSOR = 4;

    var channelTypes = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BINARY_SENSOR: BINARY_SENSOR,
        IDLE: IDLE,
        POWER_CHANNEL: POWER_CHANNEL,
        PULSE_SENSOR: PULSE_SENSOR,
        TEMPERATURE_SENSOR: TEMPERATURE_SENSOR
    });

    const SF12B125 = 0;
    const SF11B125 = 1;
    const SF10B125 = 2;
    const SF9B125 = 3;
    const SF8B125 = 4;
    const SF7B125 = 5;
    const SF7B250 = 6;

    var rx2SpreadFactors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        SF10B125: SF10B125,
        SF11B125: SF11B125,
        SF12B125: SF12B125,
        SF7B125: SF7B125,
        SF7B250: SF7B250,
        SF8B125: SF8B125,
        SF9B125: SF9B125
    });

    var spreadFactorNames = invertObject(rx2SpreadFactors);

    const INITIAL_YEAR = 2000;
    const MONTH_BIT_SIZE = 4;
    const DATE_BIT_SIZE = 5;
    const YEAR_START_INDEX = 1;
    const UNKNOWN_BATTERY_VOLTAGE = 4095;
    const EXTEND_BIT_MASK = 0x80;
    const LAST_BIT_INDEX = 7;
    const DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT = 600;
    const PARAMETER_RX2_FREQUENCY_COEFFICIENT = 100;
    const SERIAL_NUMBER_SIZE = 6;
    const MAGNETIC_INFLUENCE_BIT_INDEX = 8;
    const GAS_HARDWARE_TYPES = [
        GASI2,
        GASI3,
        GASI1,
        GASIC,
        NBIOT
    ];
    const TWO_CHANNELS_HARDWARE_TYPES = [
        IMP2AS,
        IMP2EU,
        IMP2IN,
        NOVATOR
    ];
    const ELIMP_HARDWARE_TYPES = [
        ELIMP
    ];
    const FOUR_CHANNELS_HARDWARE_TYPES = [
        IMP4EU,
        IMP4IN
    ];
    const MTX_HARDWARE_TYPES = [
        MTXLORA
    ];
    const gasBitMask = {
        isBatteryLow: Math.pow(2, 0),
        isMagneticInfluence: Math.pow(2, 1),
        isButtonReleased: Math.pow(2, 2),
        isConnectionLost: Math.pow(2, 3)
    };
    const twoChannelBitMask = {
        isBatteryLow: Math.pow(2, 0),
        isConnectionLost: Math.pow(2, 3),
        isFirstChannelInactive: Math.pow(2, 4),
        isSecondChannelInactive: Math.pow(2, 5)
    };
    const elimpBitMask = {
        isConnectionLost: Math.pow(2, 3)
    };
    const fourChannelBitMask = {
        isBatteryLow: Math.pow(2, 0),
        isConnectionLost: Math.pow(2, 3),
        isFirstChannelInactive: Math.pow(2, 4),
        isSecondChannelInactive: Math.pow(2, 5),
        isThirdChannelInactive: Math.pow(2, 6),
        isForthChannelInactive: Math.pow(2, 8)
    };
    const mtxBitMask = {
        isMeterCaseOpen: Math.pow(2, 0),
        isMagneticInfluence: Math.pow(2, 1),
        isParametersSetRemotely: Math.pow(2, 2),
        isParametersSetLocally: Math.pow(2, 3),
        isMeterProgramRestarted: Math.pow(2, 4),
        isLockedOut: Math.pow(2, 5),
        isTimeSet: Math.pow(2, 6),
        isTimeCorrected: Math.pow(2, 7),
        isMeterFailure: Math.pow(2, 8),
        isMeterTerminalBoxOpen: Math.pow(2, 9),
        isModuleCompartmentOpen: Math.pow(2, 10),
        isTariffPlanChanged: Math.pow(2, 11),
        isNewTariffPlanReceived: Math.pow(2, 12)
    };
    const usWaterMeterEventBitMask = {
        transportMode: 0x01,
        frequencyOutput: 0x02,
        reverseFlow: 0x04,
        tamperBreak: 0x08,
        leakage: 0x10,
        pipeBreak: 0x20,
        pipeEmpty: 0x40,
        batteryDischarge: 0x80
    };
    const fourChannelsBitMask = {
        channel1: Math.pow(2, 0),
        channel2: Math.pow(2, 1),
        channel3: Math.pow(2, 2),
        channel4: Math.pow(2, 3)
    };
    const getChannelsMaskFromNumber = (value) => {
        const object = toObject(fourChannelsBitMask, value);
        return { channel1: object.channel1, channel2: object.channel2, channel3: object.channel3, channel4: object.channel4 };
    };
    const setChannelsMaskToNumber = (channelsMask) => {
        const { channel1, channel2, channel3, channel4 } = channelsMask;
        return fromObject(fourChannelsBitMask, { channel1, channel2, channel3, channel4 });
    };
    const getChannelsMask = (buffer) => getChannelsMaskFromNumber(buffer.getUint8());
    const setChannelsMask = (buffer, channelsMask) => (buffer.setUint8(setChannelsMaskToNumber(channelsMask)));
    const byteToPulseCoefficientMap = {
        128: 1,
        129: 5,
        130: 10,
        131: 100,
        132: 1000,
        133: 10000,
        134: 100000
    };
    const pulseCoefficientToByteMap = invertObject(byteToPulseCoefficientMap);
    const isMSBSet = (value) => !!(value & 0x80);
    const getNbiotSslWrite = (buffer) => ({
        size: buffer.getUint16(),
        position: buffer.getUint16(),
        chunk: buffer.getBytesLeft()
    });
    const setNbiotSslWrite = (buffer, parameter) => {
        if (parameter.size !== parameter.chunk.length) {
            throw new Error('ssl chunk size parameter doesn\'t match actual ssl chunk size');
        }
        buffer.setUint16(parameter.size);
        buffer.setUint16(parameter.position);
        buffer.setBytes(parameter.chunk);
    };
    const getNbiotSslSet = (buffer) => ({ crc32: buffer.getUint32() });
    const setNbiotSslSet = (buffer, parameter) => {
        buffer.setUint32(parameter.crc32);
    };
    const deviceParameterConvertersMap = {
        [REPORTING_DATA_INTERVAL]: {
            get: (buffer) => ({
                specialSchedulePeriod: buffer.getUint8() * DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT,
                firstDaysSpecialSchedule: buffer.getUint8(),
                lastDaysSpecialSchedule: buffer.getUint8(),
                period: buffer.getUint8() * DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.specialSchedulePeriod / DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT);
                buffer.setUint8(parameter.firstDaysSpecialSchedule);
                buffer.setUint8(parameter.lastDaysSpecialSchedule);
                buffer.setUint8(parameter.period / DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT);
            }
        },
        [DAY_CHECKOUT_HOUR]: {
            get: (buffer) => ({
                value: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.value);
            }
        },
        [REPORTING_DATA_TYPE]: {
            get: (buffer) => ({
                type: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.type);
            }
        },
        [PRIORITY_DATA_DELIVERY_TYPE]: {
            get: (buffer) => ({ value: buffer.getUint8() }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.value);
            }
        },
        [ACTIVATION_METHOD]: {
            get: (buffer) => ({
                type: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.type);
            }
        },
        [BATTERY_DEPASSIVATION_INFO]: {
            get: (buffer) => ({
                loadTime: buffer.getUint16(),
                internalResistance: buffer.getUint16(),
                lowVoltage: buffer.getUint16()
            }),
            set: (buffer, parameter) => {
                buffer.setUint16(parameter.loadTime);
                buffer.setUint16(parameter.internalResistance);
                buffer.setUint16(parameter.lowVoltage);
            }
        },
        [BATTERY_MINIMAL_LOAD_TIME]: {
            get: (buffer) => ({
                value: buffer.getUint32()
            }),
            set: (buffer, parameter) => {
                buffer.setUint32(parameter.value);
            }
        },
        [CHANNELS_CONFIG]: {
            get: (buffer) => ({ value: buffer.getUint8() }),
            set: (buffer, parameter) => {
                if (parameter.value < 0 || parameter.value > 18) {
                    throw new Error('channels config must be between 0-18');
                }
                buffer.setUint8(parameter.value);
            }
        },
        [RX2_CONFIG]: {
            get: (buffer) => {
                const spreadFactor = buffer.getUint8();
                const spreadFactorName = spreadFactorNames[spreadFactor];
                const frequency = buffer.getUint24() * PARAMETER_RX2_FREQUENCY_COEFFICIENT;
                return { spreadFactor, spreadFactorName, frequency };
            },
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.spreadFactor);
                buffer.setUint24(parameter.frequency / PARAMETER_RX2_FREQUENCY_COEFFICIENT);
            }
        },
        [ABSOLUTE_DATA]: {
            get: (buffer) => ({
                meterValue: buffer.getUint32(),
                pulseCoefficient: getPulseCoefficient(buffer),
                value: buffer.getUint32()
            }),
            set: (buffer, parameter) => {
                buffer.setUint32(parameter.meterValue);
                setPulseCoefficient(buffer, parameter.pulseCoefficient);
                buffer.setUint32(parameter.value);
            }
        },
        [ABSOLUTE_DATA_ENABLE]: {
            get: (buffer) => ({ state: buffer.getUint8() }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.state);
            }
        },
        [SERIAL_NUMBER]: {
            get: (buffer) => ({
                value: getHexFromBytes(buffer.getBytes(SERIAL_NUMBER_SIZE))
            }),
            set: (buffer, parameter) => {
                getBytesFromHex$1(parameter.value).forEach(byte => buffer.setUint8(byte));
            }
        },
        [GEOLOCATION]: {
            get: (buffer) => ({
                latitude: roundNumber(buffer.getFloat32()),
                longitude: roundNumber(buffer.getFloat32()),
                altitude: roundNumber(buffer.getUint16())
            }),
            set: (buffer, parameter) => {
                buffer.setFloat32(roundNumber(parameter.latitude));
                buffer.setFloat32(roundNumber(parameter.longitude));
                buffer.setUint16(roundNumber(parameter.altitude));
            }
        },
        [EXTRA_FRAME_INTERVAL]: {
            get: (buffer) => ({ value: buffer.getUint16() }),
            set: (buffer, parameter) => {
                buffer.setUint16(parameter.value);
            }
        },
        [ABSOLUTE_DATA_MULTI_CHANNEL]: {
            get: (buffer) => ({
                channel: getChannelValue(buffer),
                meterValue: buffer.getUint32(),
                pulseCoefficient: getPulseCoefficient(buffer),
                value: buffer.getUint32()
            }),
            set: (buffer, parameter) => {
                setChannelValue(buffer, parameter.channel);
                buffer.setUint32(parameter.meterValue);
                setPulseCoefficient(buffer, parameter.pulseCoefficient);
                buffer.setUint32(parameter.value);
            }
        },
        [ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL]: {
            get: (buffer) => ({
                channel: getChannelValue(buffer),
                state: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                setChannelValue(buffer, parameter.channel);
                buffer.setUint8(parameter.state);
            }
        },
        [PULSE_CHANNELS_SCAN_CONFIG]: {
            get: (buffer) => ({
                channelList: getChannels(buffer),
                pullUpTime: buffer.getUint8(),
                scanTime: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                if (parameter.pullUpTime < 17) {
                    throw new Error('minimal value for pullUpTime - 17');
                }
                if (parameter.scanTime < 15) {
                    throw new Error('minimal value for scanTime - 15');
                }
                setChannels(buffer, parameter.channelList.map(index => ({ index })));
                buffer.setUint8(parameter.pullUpTime);
                buffer.setUint8(parameter.scanTime);
            }
        },
        [PULSE_CHANNELS_SET_CONFIG]: {
            get: getChannelsMask,
            set: setChannelsMask
        },
        [BATTERY_DEPASSIVATION_CONFIG]: {
            get: (buffer) => ({
                resistanceStartThreshold: buffer.getUint16(),
                resistanceStopThreshold: buffer.getUint16()
            }),
            set: (buffer, parameter) => {
                buffer.setUint16(parameter.resistanceStartThreshold);
                buffer.setUint16(parameter.resistanceStopThreshold);
            }
        },
        [MQTT_SESSION_CONFIG]: {
            get: (buffer) => ({
                clientId: buffer.getString(),
                username: buffer.getString(),
                password: buffer.getString(),
                cleanSession: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setString(parameter.clientId);
                buffer.setString(parameter.username);
                buffer.setString(parameter.password);
                buffer.setUint8(parameter.cleanSession);
            }
        },
        [MQTT_BROKER_ADDRESS]: {
            get: (buffer) => ({
                hostName: buffer.getString(),
                port: buffer.getUint16()
            }),
            set: (buffer, parameter) => {
                buffer.setString(parameter.hostName);
                buffer.setUint16(parameter.port);
            }
        },
        [MQTT_SSL_ENABLE]: {
            get: (buffer) => ({
                enable: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.enable);
            }
        },
        [MQTT_TOPIC_PREFIX]: {
            get: (buffer) => ({
                topicPrefix: buffer.getString()
            }),
            set: (buffer, parameter) => {
                buffer.setString(parameter.topicPrefix);
            }
        },
        [MQTT_DATA_RECEIVE_CONFIG]: {
            get: (buffer) => ({
                qos: buffer.getUint8(),
                count: buffer.getUint8(),
                timeout: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.qos);
                buffer.setUint8(parameter.count);
                buffer.setUint8(parameter.timeout);
            }
        },
        [MQTT_DATA_SEND_CONFIG]: {
            get: (buffer) => ({
                qos: buffer.getUint8(),
                retain: buffer.getUint8(),
                newestSendFirst: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.qos);
                buffer.setUint8(parameter.retain);
                buffer.setUint8(parameter.newestSendFirst);
            }
        },
        [NBIOT_SSL_CONFIG]: {
            get: (buffer) => ({
                securityLevel: buffer.getUint8(),
                version: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.securityLevel);
                buffer.setUint8(parameter.version);
            }
        },
        [NBIOT_SSL_CACERT_WRITE]: {
            get: getNbiotSslWrite,
            set: setNbiotSslWrite
        },
        [NBIOT_SSL_CACERT_SET]: {
            get: getNbiotSslSet,
            set: setNbiotSslSet
        },
        [NBIOT_SSL_CLIENT_CERT_WRITE]: {
            get: getNbiotSslWrite,
            set: setNbiotSslWrite
        },
        [NBIOT_SSL_CLIENT_CERT_SET]: {
            get: getNbiotSslSet,
            set: setNbiotSslSet
        },
        [NBIOT_SSL_CLIENT_KEY_WRITE]: {
            get: getNbiotSslWrite,
            set: setNbiotSslWrite
        },
        [NBIOT_SSL_CLIENT_KEY_SET]: {
            get: getNbiotSslSet,
            set: setNbiotSslSet
        },
        [NBIOT_DEVICE_SOFTWARE_UPDATE]: {
            get: (buffer) => ({
                softwareImageUrl: buffer.getString()
            }),
            set: (buffer, parameter) => {
                buffer.setString(parameter.softwareImageUrl);
            }
        },
        [NBIOT_MODULE_FIRMWARE_UPDATE]: {
            get: (buffer) => ({
                moduleFirmwareImageUrl: buffer.getString()
            }),
            set: (buffer, parameter) => {
                buffer.setString(parameter.moduleFirmwareImageUrl);
            }
        },
        [REPORTING_DATA_CONFIG]: {
            get: (buffer) => ({
                dataType: buffer.getUint8(),
                hour: buffer.getUint8(),
                minutes: buffer.getUint8(),
                countToSend: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.dataType);
                buffer.setUint8(parameter.hour);
                buffer.setUint8(parameter.minutes);
                buffer.setUint8(parameter.countToSend);
            }
        },
        [EVENTS_CONFIG]: {
            get: (buffer) => ({
                eventId: buffer.getUint8(),
                sendEvent: buffer.getUint8(),
                saveEvent: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.eventId);
                buffer.setUint8(parameter.sendEvent);
                buffer.setUint8(parameter.saveEvent);
            }
        },
        [NBIOT_MODULE_INFO]: {
            get: (buffer) => ({
                moduleInfo: buffer.getString()
            }),
            set: (buffer, parameter) => {
                buffer.setString(parameter.moduleInfo);
            }
        },
        [NBIOT_BANDS]: {
            get: (buffer) => {
                const count = buffer.getUint8();
                const bands = [];
                for (let index = 0; index < count; index++) {
                    bands.push(buffer.getUint8());
                }
                return { bands };
            },
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.bands.length);
                for (const band of parameter.bands) {
                    buffer.setUint8(band);
                }
            }
        },
        [NBIOT_APN]: {
            get: (buffer) => ({
                apn: buffer.getString()
            }),
            set: (buffer, parameter) => {
                buffer.setString(parameter.apn);
            }
        },
        [NBIOT_LED_INDICATION]: {
            get: (buffer) => ({
                enableLed: buffer.getUint8(),
                enableNbiotNetworkLed: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.enableLed);
                buffer.setUint8(parameter.enableNbiotNetworkLed);
            }
        },
        [NBIOT_SIM]: {
            get: (buffer) => ({
                enable: buffer.getUint8(),
                pin: buffer.getUint16()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.enable);
                buffer.setUint16(parameter.pin);
            }
        },
        [CHANNEL_TYPE]: {
            get: (buffer) => (getChannelType(buffer)),
            set: (buffer, parameter) => (setChannelType(buffer, parameter))
        },
        [EXTRA_PAYLOAD_ENABLE]: {
            get: (buffer) => ({
                enable: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.enable);
            }
        },
        [TIME_SYNCHRONIZATION_PERIOD_VIA_MAC]: {
            get: (buffer) => ({
                period: buffer.getUint32()
            }),
            set: (buffer, parameter) => {
                buffer.setUint32(parameter.period);
            }
        },
        [KEEP_LORA_CONNECTION_ON_REMOVAL]: {
            get: (buffer) => ({
                value: buffer.getUint8() !== 0
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.value ? 1 : 0);
            }
        },
        [NBIOT_NTP_SERVER]: {
            get: (buffer) => ({
                server: buffer.getString(),
                port: buffer.getUint16()
            }),
            set: (buffer, parameter) => {
                buffer.setString(parameter.server);
                buffer.setUint16(parameter.port);
            }
        },
        [ACTIVATE_MODULE]: {
            get: (buffer) => ({
                enable: buffer.getUint8()
            }),
            set: (buffer, parameter) => {
                buffer.setUint8(parameter.enable);
            }
        }
    };
    const getMagneticInfluenceBit = (byte) => (!!extractBits(byte, 1, MAGNETIC_INFLUENCE_BIT_INDEX));
    const getExtendedValue = function (buffer) {
        let value = 0;
        let isByteExtended = true;
        let position = 0;
        while (isByteExtended && buffer.offset <= buffer.data.length) {
            const byte = buffer.getUint8();
            isByteExtended = !!(byte & EXTEND_BIT_MASK);
            value += ((byte & 0x7f) << (7 * position)) >>> 0;
            ++position;
        }
        return value;
    };
    const getTime = function (buffer) {
        return buffer.getUint32();
    };
    const getBatteryVoltage = function (buffer) {
        const lowVoltageByte = buffer.getUint8();
        const lowAndHightVoltageByte = buffer.getUint8();
        const highVoltageByte = buffer.getUint8();
        let underLowLoad = lowVoltageByte << 4;
        underLowLoad |= (lowAndHightVoltageByte & 0xf0) >> 4;
        let underHighLoad = ((lowAndHightVoltageByte & 0x0f) << 8) | highVoltageByte;
        if (underHighLoad === UNKNOWN_BATTERY_VOLTAGE) {
            underHighLoad = undefined;
        }
        if (underLowLoad === UNKNOWN_BATTERY_VOLTAGE) {
            underLowLoad = undefined;
        }
        return { underLowLoad, underHighLoad };
    };
    const getLegacyCounterValue = function (buffer) {
        return buffer.getUint24();
    };
    const getLegacyCounter = function (buffer, byte = buffer.getUint8(), isArchiveValue = false) {
        const value = getLegacyCounterValue(buffer);
        return {
            isMagneticInfluence: getMagneticInfluenceBit(byte),
            value: isArchiveValue && value === EMPTY_VALUE ? 0 : value
        };
    };
    const getChannels = function (buffer) {
        const channelList = [];
        let extended = true;
        let channelIndex = 1;
        while (extended) {
            const byte = buffer.getUint8();
            const bits = byte.toString(2).padStart(LAST_BIT_INDEX + 1, '0').split('').reverse();
            bits.forEach((bit, index) => {
                const value = Number(bit);
                if (index === LAST_BIT_INDEX) {
                    extended = !!value;
                }
                else {
                    if (value) {
                        channelList.push(channelIndex);
                    }
                    ++channelIndex;
                }
            });
        }
        return channelList;
    };
    const setChannels = function (buffer, channelList) {
        if (channelList.length === 0) {
            buffer.setUint8(0);
            return;
        }
        channelList.sort((a, b) => a.index - b.index);
        const maxChannel = Math.max(...channelList.map(({ index }) => index));
        const size = (maxChannel - (maxChannel % 8)) / 8;
        const data = new Array(size + 1).fill(0);
        let byte = 0;
        data.forEach((_, byteIndex) => {
            let channelIndex = (byteIndex * LAST_BIT_INDEX) + 1;
            const maxChannelIndex = channelIndex + LAST_BIT_INDEX;
            while (channelIndex < maxChannelIndex) {
                const channel = channelList.find((item => item.index === channelIndex));
                if (channel !== undefined) {
                    byte |= 1 << ((channel.index - 1) % LAST_BIT_INDEX);
                }
                ++channelIndex;
            }
            if (data[byteIndex + 1] !== undefined) {
                byte |= 1 << LAST_BIT_INDEX;
            }
            data[byteIndex] = byte;
            byte = 0;
        });
        data.forEach((value) => buffer.setUint8(value));
    };
    const getChannelValue = function (buffer) {
        return buffer.getUint8() + 1;
    };
    const setChannelValue = function (buffer, value) {
        if (value < 1) {
            throw new Error('channel must be 1 or greater');
        }
        buffer.setUint8(value - 1);
    };
    const getChannelsValuesWithHourDiff = function (buffer, isArchiveValue = false) {
        const date = getDate(buffer);
        const { hour, hours } = getHours(buffer);
        const channels = getChannels(buffer);
        const channelList = [];
        date.setUTCHours(hour);
        channels.forEach(channelIndex => {
            const diff = [];
            const value = getExtendedValue(buffer);
            for (let diffHour = 1; diffHour < hours; ++diffHour) {
                diff.push(getExtendedValue(buffer));
            }
            channelList.push({
                value: isArchiveValue && value === EMPTY_VALUE ? 0 : value,
                diff,
                index: channelIndex
            });
        });
        return { startTime2000: getTime2000FromDate(date), hours, channelList };
    };
    const getHours = function (buffer, byte = buffer.getUint8()) {
        if (byte === 0) {
            return { hours: 0, hour: 0 };
        }
        const hours = ((byte & 0xe0) >> 5) + 1;
        const hour = byte & 0x1f;
        return { hours, hour };
    };
    const getDate = function (buffer) {
        const yearMonthByte = buffer.getUint8();
        const monthDateByte = buffer.getUint8();
        const year = yearMonthByte >> YEAR_START_INDEX;
        const month = ((yearMonthByte & 0x01) << MONTH_BIT_SIZE - YEAR_START_INDEX) | (monthDateByte >> DATE_BIT_SIZE);
        const monthDay = monthDateByte & 0x1f;
        return new Date(Date.UTC(year + INITIAL_YEAR, month - 1, monthDay, 0, 0, 0, 0));
    };
    const getPulseCoefficient = function (buffer) {
        const pulseCoefficient = buffer.getUint8();
        if (isMSBSet(pulseCoefficient)) {
            const value = byteToPulseCoefficientMap[pulseCoefficient];
            if (value) {
                return value;
            }
            throw new Error('pulseCoefficient MSB is set, but value unknown');
        }
        return pulseCoefficient;
    };
    const setPulseCoefficient = function (buffer, value) {
        if (value in pulseCoefficientToByteMap) {
            const byte = pulseCoefficientToByteMap[value];
            if (byte) {
                buffer.setUint8(byte);
            }
            else {
                throw new Error('pulseCoefficient MSB is set, but value unknown');
            }
        }
        else {
            buffer.setUint8(value);
        }
    };
    const getChannelsWithAbsoluteValues = function (buffer) {
        const channels = getChannels(buffer);
        const channelList = [];
        channels.forEach(channelIndex => {
            channelList.push({
                pulseCoefficient: getPulseCoefficient(buffer),
                value: getExtendedValue(buffer),
                index: channelIndex
            });
        });
        return channelList;
    };
    const getChannelsAbsoluteValuesWithHourDiff = function (buffer, hours) {
        const channels = getChannels(buffer);
        const channelList = [];
        channels.forEach(channelIndex => {
            const pulseCoefficient = getPulseCoefficient(buffer);
            const value = getExtendedValue(buffer);
            const diff = [];
            for (let hourIndex = 1; hourIndex < hours; ++hourIndex) {
                diff.push(getExtendedValue(buffer));
            }
            channelList.push({
                diff,
                value,
                pulseCoefficient,
                index: channelIndex
            });
        });
        return channelList;
    };
    const getEventStatus = function (buffer, hardwareType) {
        let status;
        if (GAS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(gasBitMask, buffer.getUint8());
        }
        else if (TWO_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(twoChannelBitMask, buffer.getUint8());
        }
        else if (ELIMP_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(elimpBitMask, buffer.getUint8());
        }
        else if (FOUR_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(fourChannelBitMask, buffer.getUint16(true));
        }
        else if (MTX_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(mtxBitMask, buffer.getUint16(true));
        }
        else if (hardwareType === US_WATER) {
            const event = toObject(usWaterMeterEventBitMask, buffer.getUint8());
            status = { event, error: buffer.getUint8() };
        }
        else {
            throw new Error('wrong hardwareType');
        }
        return status;
    };
    const getResponseParameter = function (buffer) {
        const id = buffer.getUint8();
        const name = deviceParameterNames[id];
        let data;
        if (!deviceParameterConvertersMap[id] || !deviceParameterConvertersMap[id].get) {
            throw new Error(`parameter ${id} is not supported`);
        }
        switch (id) {
            case MQTT_SESSION_CONFIG:
            case NBIOT_SSL_CACERT_WRITE:
            case NBIOT_SSL_CLIENT_CERT_WRITE:
            case NBIOT_SSL_CLIENT_KEY_WRITE:
            case NBIOT_SSL_CACERT_SET:
            case NBIOT_SSL_CLIENT_CERT_SET:
            case NBIOT_SSL_CLIENT_KEY_SET:
            case NBIOT_DEVICE_SOFTWARE_UPDATE:
            case NBIOT_MODULE_FIRMWARE_UPDATE:
                data = null;
                break;
            default:
                data = deviceParameterConvertersMap[id].get(buffer);
        }
        return { id, name, data };
    };
    const getLegacyHourDiff = function (buffer) {
        const stateWithValueByte = buffer.getUint8();
        const valueLowerByte = buffer.getUint8();
        return {
            isMagneticInfluence: getMagneticInfluenceBit(stateWithValueByte),
            value: ((stateWithValueByte & 0x1f) << 8) | valueLowerByte
        };
    };
    const getLegacyHourCounterWithDiff = function (buffer, isArchiveValue = false) {
        const date = getDate(buffer);
        const byte = buffer.getUint8();
        const { hour } = getHours(buffer, byte);
        const value = getLegacyCounterValue(buffer);
        const counter = {
            isMagneticInfluence: getMagneticInfluenceBit(byte),
            value: isArchiveValue && value === EMPTY_VALUE ? 0 : value
        };
        const diff = [];
        while (buffer.offset < buffer.data.length) {
            diff.push(getLegacyHourDiff(buffer));
        }
        date.setUTCHours(hour);
        return { startTime2000: getTime2000FromDate(date), counter, diff };
    };
    const getChannelsValuesWithHourDiffExtended = function (buffer, isArchiveValue = false) {
        const date = getDate(buffer);
        const hour = buffer.getUint8();
        const hours = buffer.getUint8();
        const channels = getChannels(buffer);
        const channelList = [];
        date.setUTCHours(hour);
        channels.forEach(channelIndex => {
            const diff = [];
            const value = getExtendedValue(buffer);
            for (let diffHour = 0; diffHour < hours; ++diffHour) {
                diff.push(getExtendedValue(buffer));
            }
            channelList.push({
                value: isArchiveValue && value === EMPTY_VALUE ? 0 : value,
                diff,
                index: channelIndex
            });
        });
        return { startTime2000: getTime2000FromDate(date), hour, hours, channelList };
    };
    const getDataSegment = function (buffer) {
        const segmentationSessionId = buffer.getUint8();
        const flag = buffer.getUint8();
        return {
            segmentationSessionId,
            segmentIndex: extractBits(flag, 3, 1),
            segmentsNumber: extractBits(flag, 3, 5),
            isLast: Boolean(extractBits(flag, 1, 8)),
            data: buffer.getBytesLeft()
        };
    };
    const getBinarySensor = function (buffer) {
        const activeStateTimeMs = buffer.getUint16();
        return { activeStateTimeMs };
    };
    const setBinarySensor = function (buffer, parameters) {
        buffer.setUint16(parameters.activeStateTimeMs);
    };
    const getTemperatureSensor = function (buffer) {
        const measurementPeriod = buffer.getUint16();
        const hysteresisSec = buffer.getUint8();
        const highTemperatureThreshold = buffer.getInt8();
        const lowTemperatureThreshold = buffer.getInt8();
        return {
            measurementPeriod,
            hysteresisSec,
            highTemperatureThreshold,
            lowTemperatureThreshold
        };
    };
    const setTemperatureSensor = function (buffer, parameters) {
        buffer.setUint16(parameters.measurementPeriod);
        buffer.setUint8(parameters.hysteresisSec);
        buffer.setInt8(parameters.highTemperatureThreshold);
        buffer.setInt8(parameters.lowTemperatureThreshold);
    };
    const getChannelType = function (buffer) {
        const channel = getChannelValue(buffer);
        const type = buffer.getUint8();
        let parameters = {};
        switch (type) {
            case BINARY_SENSOR:
                parameters = getBinarySensor(buffer);
                break;
            case TEMPERATURE_SENSOR:
                parameters = getTemperatureSensor(buffer);
                break;
        }
        return {
            channel,
            type,
            parameters
        };
    };
    const setChannelType = function (buffer, { type, channel, parameters }) {
        setChannelValue(buffer, channel);
        buffer.setUint8(type);
        switch (type) {
            case BINARY_SENSOR:
                setBinarySensor(buffer, parameters);
                break;
            case TEMPERATURE_SENSOR:
                setTemperatureSensor(buffer, parameters);
                break;
        }
    };

    const id$A = current;
    const COMMAND_BODY_MAX_SIZE$9 = 4;
    const fromBytes$C = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE$9) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        return getLegacyCounter(buffer);
    };

    const id$z = currentMc;
    const COMMAND_BODY_MAX_SIZE$8 = 37;
    const fromBytes$B = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE$8) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const parameters = { channelList: [] };
        const buffer = new BinaryBuffer(bytes, false);
        const channelList = getChannels(buffer);
        parameters.channelList = channelList.map(channelIndex => ({
            value: getExtendedValue(buffer),
            index: channelIndex
        }));
        return parameters;
    };

    const setTime2000 = 0x02;
    const setParameter = 0x03;
    const getParameter = 0x04;
    const getArchiveHours = 0x05;
    const getArchiveDays = 0x06;
    const getCurrent = 0x07;
    const getTime2000 = 0x09;
    const getArchiveEvents = 0x0b;
    const correctTime2000 = 0x0c;
    const getStatus = 0x14;
    const getCurrentMc = 0x18;
    const softRestart = 0x19;
    const getArchiveHoursMc = 0x1a;
    const getArchiveDaysMc = 0x1b;
    const dataSegment = 0x1e;
    const getLmicInfo = 0x21f;
    const getBatteryStatus = 0x51f;
    const usWaterMeterCommand = 0x71f;
    const getExAbsArchiveHoursMc = 0xc1f;
    const getExAbsArchiveDaysMc = 0xd1f;
    const getExAbsCurrentMc = 0xf1f;
    const writeImage = 0x2a1f;
    const verifyImage = 0x2b1f;
    const updateRun = 0x2c1f;
    const getArchiveHoursMcEx = 0x301f;
    const getChannelsStatus = 0x321f;
    const getChannelsTypes = 0x331f;
    const getSignalQuality = 0x341f;

    var downlinkIds = /*#__PURE__*/Object.freeze({
        __proto__: null,
        correctTime2000: correctTime2000,
        dataSegment: dataSegment,
        getArchiveDays: getArchiveDays,
        getArchiveDaysMc: getArchiveDaysMc,
        getArchiveEvents: getArchiveEvents,
        getArchiveHours: getArchiveHours,
        getArchiveHoursMc: getArchiveHoursMc,
        getArchiveHoursMcEx: getArchiveHoursMcEx,
        getBatteryStatus: getBatteryStatus,
        getChannelsStatus: getChannelsStatus,
        getChannelsTypes: getChannelsTypes,
        getCurrent: getCurrent,
        getCurrentMc: getCurrentMc,
        getExAbsArchiveDaysMc: getExAbsArchiveDaysMc,
        getExAbsArchiveHoursMc: getExAbsArchiveHoursMc,
        getExAbsCurrentMc: getExAbsCurrentMc,
        getLmicInfo: getLmicInfo,
        getParameter: getParameter,
        getSignalQuality: getSignalQuality,
        getStatus: getStatus,
        getTime2000: getTime2000,
        setParameter: setParameter,
        setTime2000: setTime2000,
        softRestart: softRestart,
        updateRun: updateRun,
        usWaterMeterCommand: usWaterMeterCommand,
        verifyImage: verifyImage,
        writeImage: writeImage
    });

    invertObject(downlinkIds);

    const id$y = dataSegment;
    const fromBytes$A = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        return getDataSegment(buffer);
    };

    const id$x = day;
    const fromBytes$z = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        const date = getDate(buffer);
        const byte = buffer.getUint8();
        const { hour } = getHours(buffer, byte);
        const isMagneticInfluence = getMagneticInfluenceBit(byte);
        const value = getLegacyCounterValue(buffer);
        date.setUTCHours(hour);
        return { value, isMagneticInfluence, startTime2000: getTime2000FromDate(date) };
    };

    const id$w = dayMc;
    const COMMAND_BODY_MAX_SIZE$7 = 32;
    const fromBytes$y = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE$7) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        const date = getDate(buffer);
        const channels = getChannels(buffer);
        const channelList = channels.map(channelIndex => ({
            value: getExtendedValue(buffer),
            index: channelIndex
        }));
        return { startTime2000: getTime2000FromDate(date), channelList };
    };

    const id$v = exAbsCurrentMc;
    const fromBytes$x = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        return { channelList: getChannelsWithAbsoluteValues(buffer) };
    };

    const id$u = exAbsDayMc;
    const COMMAND_BODY_MAX_SIZE$6 = 89;
    const fromBytes$w = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE$6) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        const date = getDate(buffer);
        const channelList = getChannelsWithAbsoluteValues(buffer);
        return { startTime2000: getTime2000FromDate(date), channelList };
    };

    const id$t = exAbsHourMc;
    const COMMAND_BODY_MAX_SIZE$5 = 168;
    const fromBytes$v = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE$5) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        const date = getDate(buffer);
        const { hour, hours } = getHours(buffer);
        const channelList = getChannelsAbsoluteValuesWithHourDiff(buffer, hours);
        date.setUTCHours(hour);
        return { startTime2000: getTime2000FromDate(date), hours, channelList };
    };

    const id$s = getArchiveDays$1;
    const fromBytes$u = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        const date = getDate(buffer);
        const dayList = [];
        while (buffer.offset < buffer.data.length) {
            dayList.push(getLegacyCounter(buffer, undefined, true));
        }
        return { startTime2000: getTime2000FromDate(date), dayList };
    };

    const id$r = getArchiveDaysMc$1;
    const fromBytes$t = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        const date = getDate(buffer);
        const channels = getChannels(buffer);
        const days = buffer.getUint8();
        const channelList = [];
        channels.forEach(channelIndex => {
            const dayList = [];
            channelList.push({ dayList, index: channelIndex });
            for (let day = 0; day < days; ++day) {
                const value = getExtendedValue(buffer);
                dayList.push(value === EMPTY_VALUE ? 0 : value);
            }
        });
        return { startTime2000: getTime2000FromDate(date), days, channelList };
    };

    const MAGNET_ON = 1;
    const MAGNET_OFF = 2;
    const ACTIVATE = 3;
    const DEACTIVATE = 4;
    const BATTERY_ALARM = 5;
    const CAN_OFF = 6;
    const INSERT = 7;
    const REMOVE = 8;
    const COUNTER_OVER = 9;
    const SET_TIME = 10;
    const ACTIVATE_MTX = 11;
    const CONNECT = 12;
    const DISCONNECT = 13;
    const DEPASS_DONE = 14;
    const OPTOLOW = 15;
    const OPTOFLASH = 16;
    const MTX = 17;
    const JOIN_ACCEPT = 18;
    const WATER_EVENT = 19;
    const WATER_NO_RESPONSE = 20;
    const OPTOSENSOR_ERROR = 21;
    const BINARY_SENSOR_ON = 22;
    const BINARY_SENSOR_OFF = 23;
    const TEMPERATURE_SENSOR_HYSTERESIS = 24;
    const TEMPERATURE_SENSOR_LOW_TEMPERATURE = 25;
    const TEMPERATURE_SENSOR_HIGH_TEMPERATURE = 26;

    var events = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTIVATE: ACTIVATE,
        ACTIVATE_MTX: ACTIVATE_MTX,
        BATTERY_ALARM: BATTERY_ALARM,
        BINARY_SENSOR_OFF: BINARY_SENSOR_OFF,
        BINARY_SENSOR_ON: BINARY_SENSOR_ON,
        CAN_OFF: CAN_OFF,
        CONNECT: CONNECT,
        COUNTER_OVER: COUNTER_OVER,
        DEACTIVATE: DEACTIVATE,
        DEPASS_DONE: DEPASS_DONE,
        DISCONNECT: DISCONNECT,
        INSERT: INSERT,
        JOIN_ACCEPT: JOIN_ACCEPT,
        MAGNET_OFF: MAGNET_OFF,
        MAGNET_ON: MAGNET_ON,
        MTX: MTX,
        OPTOFLASH: OPTOFLASH,
        OPTOLOW: OPTOLOW,
        OPTOSENSOR_ERROR: OPTOSENSOR_ERROR,
        REMOVE: REMOVE,
        SET_TIME: SET_TIME,
        TEMPERATURE_SENSOR_HIGH_TEMPERATURE: TEMPERATURE_SENSOR_HIGH_TEMPERATURE,
        TEMPERATURE_SENSOR_HYSTERESIS: TEMPERATURE_SENSOR_HYSTERESIS,
        TEMPERATURE_SENSOR_LOW_TEMPERATURE: TEMPERATURE_SENSOR_LOW_TEMPERATURE,
        WATER_EVENT: WATER_EVENT,
        WATER_NO_RESPONSE: WATER_NO_RESPONSE
    });

    var eventNames = invertObject(events);

    const id$q = getArchiveEvents$1;
    const getEvent = (buffer) => {
        const time2000 = getTime(buffer);
        const eventId = buffer.getUint8();
        const sequenceNumber = buffer.getUint8();
        return {
            time2000,
            id: eventId,
            name: eventNames[eventId],
            sequenceNumber
        };
    };
    const fromBytes$s = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        const eventList = [];
        while (buffer.bytesLeft > 0) {
            eventList.push(getEvent(buffer));
        }
        return { eventList };
    };

    const id$p = getArchiveHours$1;
    const fromBytes$r = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        return getLegacyHourCounterWithDiff(buffer, true);
    };

    const id$o = getArchiveHoursMc$1;
    const COMMAND_BODY_MAX_SIZE$4 = 164;
    const fromBytes$q = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE$4) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        return getChannelsValuesWithHourDiff(buffer, true);
    };

    const id$n = getArchiveHoursMcEx$1;
    const COMMAND_BODY_MAX_SIZE$3 = 255;
    const fromBytes$p = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE$3) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        return getChannelsValuesWithHourDiffExtended(buffer, true);
    };

    const id$m = getBatteryStatus$1;
    const fromBytes$o = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        return {
            voltageUnderLowLoad: buffer.getUint16(),
            voltageUnderHighLoad: buffer.getUint16(),
            internalResistance: buffer.getUint16(),
            temperature: buffer.getUint8(),
            remainingCapacity: buffer.getUint8(),
            isLastDayOverconsumption: buffer.getUint8() === 1,
            averageDailyOverconsumptionCounter: buffer.getUint16()
        };
    };

    var channelNames = invertObject(channelTypes);

    const id$l = getChannelsStatus$1;
    const getBinarySensorStatus = (buffer) => ({
        state: buffer.getUint8() !== 0
    });
    const getTemperatureSensorStatus = (buffer) => ({
        temperature: buffer.getInt8(),
        time2000: getTime(buffer)
    });
    const fromBytes$n = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        const result = [];
        while (buffer.bytesLeft !== 0) {
            const type = buffer.getUint8();
            const channelStatus = {
                type,
                typeName: channelNames[type],
                channel: getChannelValue(buffer)
            };
            switch (channelStatus.type) {
                case BINARY_SENSOR:
                    channelStatus.status = getBinarySensorStatus(buffer);
                    break;
                case TEMPERATURE_SENSOR:
                    channelStatus.status = getTemperatureSensorStatus(buffer);
                    break;
            }
            result.push(channelStatus);
        }
        return result;
    };

    const id$k = getChannelsTypes$1;
    const fromBytes$m = (bytes) => ({
        channels: bytes.map(type => ({ type, typeName: channelNames[type] }))
    });

    const id$j = getExAbsArchiveDaysMc$1;
    const fromBytes$l = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        const date = getDate(buffer);
        const channels = getChannels(buffer);
        const days = buffer.getUint8();
        const channelList = [];
        channels.forEach(channelIndex => {
            const dayList = [];
            const pulseCoefficient = getPulseCoefficient(buffer);
            channelList.push({
                pulseCoefficient,
                dayList,
                index: channelIndex
            });
            for (let day = 0; day < days; ++day) {
                const value = getExtendedValue(buffer);
                dayList.push(value === EMPTY_VALUE ? 0 : value);
            }
        });
        return { channelList, days, startTime2000: getTime2000FromDate(date) };
    };

    const id$i = getExAbsArchiveHoursMc$1;
    const fromBytes$k = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        return getChannelsValuesWithHourDiff(buffer, true);
    };

    const id$h = getLmicInfo$1;
    const COMMAND_BODY_SIZE$7 = 2;
    const lmicCapabilitiesBitMask = {
        isMulticastSupported: 1 << 0,
        isFragmentedDataSupported: 1 << 1
    };
    const fromBytes$j = (bytes) => {
        if (bytes.length !== COMMAND_BODY_SIZE$7) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes);
        const capabilities = toObject(lmicCapabilitiesBitMask, buffer.getUint8());
        const version = buffer.getUint8();
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return { capabilities, version };
    };

    const id$g = getParameter$1;
    const fromBytes$i = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        return getResponseParameter(buffer);
    };

    const id$f = signalQuality;
    const COMMAND_BODY_SIZE$6 = 6;
    const fromBytes$h = (bytes) => {
        if (bytes.length !== COMMAND_BODY_SIZE$6) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        const parameters = {
            rssi: buffer.getInt8(),
            rsrp: buffer.getInt8(),
            rsrq: buffer.getInt8(),
            sinr: buffer.getInt8(),
            txPower: buffer.getInt8(),
            ecl: buffer.getUint8()
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };

    const id$e = hour;
    const fromBytes$g = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        return getLegacyHourCounterWithDiff(buffer);
    };

    const id$d = hourMc;
    const COMMAND_BODY_MAX_SIZE$2 = 164;
    const fromBytes$f = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE$2) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        return getChannelsValuesWithHourDiff(buffer);
    };

    const id$c = hourMcEx;
    const COMMAND_BODY_MAX_SIZE$1 = 255;
    const fromBytes$e = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE$1) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        return getChannelsValuesWithHourDiffExtended(buffer);
    };

    const id$b = lastEvent;
    const fromBytes$d = (bytes, config) => {
        if (!config.hardwareType) {
            throw new Error('hardwareType in config is mandatory');
        }
        const buffer = new BinaryBuffer(bytes, false);
        const sequenceNumber = buffer.getUint8();
        const status = getEventStatus(buffer, config.hardwareType);
        return { sequenceNumber, status };
    };

    const id$a = newEvent;
    const COMMAND_BODY_MAX_SIZE = 14;
    const MTX_ADDRESS_SIZE = 8;
    const getVoltage = (buffer) => buffer.getUint16();
    const getDeviceId = (buffer) => (getHexFromBytes(buffer.getBytes(MTX_ADDRESS_SIZE)));
    const fromBytes$c = (bytes) => {
        if (bytes.length > COMMAND_BODY_MAX_SIZE) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        const eventId = buffer.getUint8();
        const eventName = eventNames[eventId];
        const sequenceNumber = buffer.getUint8();
        let eventData;
        switch (eventId) {
            case MAGNET_ON:
            case MAGNET_OFF:
            case ACTIVATE:
            case DEACTIVATE:
            case CAN_OFF:
            case INSERT:
            case REMOVE:
            case COUNTER_OVER:
            case OPTOLOW:
            case OPTOFLASH:
            case JOIN_ACCEPT:
            case DEPASS_DONE:
            case WATER_NO_RESPONSE:
            case OPTOSENSOR_ERROR:
                eventData = { time2000: getTime(buffer) };
                break;
            case BATTERY_ALARM:
                eventData = { voltage: getVoltage(buffer) };
                break;
            case ACTIVATE_MTX:
                eventData = { time2000: getTime(buffer), deviceId: getDeviceId(buffer) };
                break;
            case CONNECT:
            case DISCONNECT:
                eventData = { channel: buffer.getUint8() + 1, value: getExtendedValue(buffer) };
                break;
            case MTX:
                eventData = { status: getEventStatus(buffer, MTXLORA) };
                break;
            case BINARY_SENSOR_ON:
            case BINARY_SENSOR_OFF:
                eventData = { time2000: getTime(buffer), channel: getChannelValue(buffer) };
                break;
            case TEMPERATURE_SENSOR_HYSTERESIS:
            case TEMPERATURE_SENSOR_LOW_TEMPERATURE:
            case TEMPERATURE_SENSOR_HIGH_TEMPERATURE:
                eventData = { time2000: getTime(buffer), channel: getChannelValue(buffer), temperature: buffer.getInt8() };
                break;
            case WATER_EVENT:
                eventData = { time2000: getTime(buffer), status: getEventStatus(buffer, US_WATER) };
                break;
            default:
                throw new Error(`Event ${eventId} is not supported`);
        }
        return { id: eventId, name: eventName, sequenceNumber, data: eventData };
    };

    const id$9 = setParameter$1;
    const COMMAND_BODY_SIZE$5 = 2;
    const fromBytes$b = (bytes) => {
        if (bytes.length !== COMMAND_BODY_SIZE$5) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        const parameters = {
            id: buffer.getUint8(),
            status: buffer.getUint8()
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };

    const id$8 = setTime2000$1;
    const COMMAND_BODY_SIZE$4 = 1;
    const fromBytes$a = (bytes) => {
        if (bytes.length !== COMMAND_BODY_SIZE$4) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        const parameters = {
            status: buffer.getUint8()
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };

    const id$7 = softRestart$1;
    const COMMAND_BODY_SIZE$3 = 0;
    const fromBytes$9 = (bytes) => {
        if (bytes.length !== COMMAND_BODY_SIZE$3) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };

    const id$6 = status;
    const UNKNOWN_BATTERY_RESISTANCE = 65535;
    const UNKNOWN_BATTERY_CAPACITY = 255;
    const fromBytes$8 = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        const software = { type: buffer.getUint8(), version: buffer.getUint8() };
        const hardware = { type: buffer.getUint8(), version: buffer.getUint8() };
        let data;
        switch (hardware.type) {
            case GASI1:
            case GASI2:
            case GASI3:
            case NOVATOR:
            case IMP2EU:
            case IMP4EU:
            case IMP2AS:
            case IMP2IN:
            case IMP4IN:
            case GASIC:
            case NBIOT:
            case US_WATER:
                {
                    const statusData = {
                        batteryVoltage: getBatteryVoltage(buffer),
                        batteryInternalResistance: buffer.getUint16(),
                        temperature: buffer.getUint8(),
                        remainingBatteryCapacity: buffer.getUint8(),
                        lastEventSequenceNumber: buffer.getUint8()
                    };
                    if (statusData.batteryInternalResistance === UNKNOWN_BATTERY_RESISTANCE) {
                        statusData.batteryInternalResistance = undefined;
                    }
                    if (statusData.remainingBatteryCapacity === UNKNOWN_BATTERY_CAPACITY) {
                        statusData.remainingBatteryCapacity = undefined;
                    }
                    else if (statusData.remainingBatteryCapacity !== undefined) {
                        statusData.remainingBatteryCapacity = roundNumber((statusData.remainingBatteryCapacity * 100) / (UNKNOWN_BATTERY_CAPACITY - 1), 1);
                    }
                    if (!buffer.isEmpty) {
                        statusData.downlinkQuality = buffer.getUint8();
                    }
                    data = statusData;
                }
                break;
            case MTXLORA:
            case PLC2LORA:
            case LORA:
                data = {
                    time2000: buffer.getUint32(),
                    resetReason: buffer.getUint8(),
                    rssiLastDownlinkFrame: buffer.getUint8(),
                    snrLastDownlinkFrame: buffer.getUint8(),
                    downlinkRequestsNumber: buffer.getUint8(),
                    downlinkFragmentsNumber: buffer.getUint8(),
                    uplinkResponsesNumber: buffer.getUint8(),
                    uplinkFragmentsNumber: buffer.getUint8(),
                    signalMarginToGateway: buffer.getUint8(),
                    signalMarginFromGateway: buffer.getUint8(),
                    detectedGatewaysNumber: buffer.getUint8(),
                    gatewayDownlinkErrorRate: buffer.getUint8(),
                    lastEventSequenceNumber: buffer.getUint8()
                };
                break;
            case ELIMP:
            default:
                throw new Error(`${id$6}: hardware type ${hardware.type} is not supported`);
        }
        return { software, hardware, data };
    };

    const id$5 = time2000;
    const COMMAND_BODY_SIZE$2 = 5;
    const fromBytes$7 = (bytes) => {
        if (bytes.length !== COMMAND_BODY_SIZE$2) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        const parameters = {
            sequenceNumber: buffer.getUint8(),
            time2000: getTime(buffer)
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };

    const id$4 = updateRun$1;
    const COMMAND_BODY_SIZE$1 = 0;
    const fromBytes$6 = (bytes) => {
        if (bytes.length !== COMMAND_BODY_SIZE$1) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };

    const id$3 = usWaterMeterBatteryStatus;
    const fromBytes$5 = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        return {
            voltage: getBatteryVoltage(buffer),
            internalResistance: buffer.getUint16(),
            lastDepassivationTime: buffer.getUint16()
        };
    };

    const id$2 = usWaterMeterCommand$1;
    const fromBytes$4 = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        const length = buffer.getUint8();
        return { length, data: bytes.slice(1) };
    };

    const id$1 = verifyImage$1;
    const COMMAND_BODY_SIZE = 1;
    const fromBytes$3 = (bytes) => {
        if (bytes.length !== COMMAND_BODY_SIZE) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBuffer(bytes, false);
        return { status: buffer.getUint8() };
    };

    const id = writeImage$1;
    const fromBytes$2 = (bytes) => {
        const buffer = new BinaryBuffer(bytes, false);
        return {
            offset: buffer.getUint32(),
            status: buffer.getUint8()
        };
    };

    var calculateLrc = (data, initialLrc = 0x55) => {
        let lrc = initialLrc;
        data.forEach(item => {
            lrc ^= item;
        });
        return lrc;
    };

    const HEADER_MAX_SIZE = 3;
    const getFromBytes = (fromBytesMap, nameMap) => (bytes = [], config) => {
        const commands = [];
        const message = {
            commands,
            bytes,
            lrc: { received: undefined, calculated: 0 }
        };
        let processedBytes = 0;
        let receivedLrc;
        let calculatedLrc;
        if (!bytes.length) {
            return message;
        }
        do {
            const headerInfo = fromBytes$E(bytes.slice(processedBytes, processedBytes + HEADER_MAX_SIZE));
            const headerData = bytes.slice(processedBytes, processedBytes + headerInfo.headerSize);
            const bodyData = bytes.slice(processedBytes + headerInfo.headerSize, processedBytes + headerInfo.headerSize + headerInfo.commandSize);
            const command = {
                id: headerInfo.commandId,
                name: nameMap[headerInfo.commandId],
                headerSize: headerInfo.headerSize,
                bytes: [...headerData, ...bodyData]
            };
            processedBytes = processedBytes + headerInfo.headerSize + headerInfo.commandSize;
            if (config) {
                command.config = config;
            }
            try {
                if (!fromBytesMap[headerInfo.commandId]) {
                    throw new Error(`Unsupported command id: ${headerInfo.commandId}!`);
                }
                command.parameters = fromBytesMap[headerInfo.commandId](bodyData, config);
                commands.push(command);
            }
            catch (error) {
                commands.push({
                    command,
                    error: error.message
                });
            }
        } while (processedBytes < bytes.length - 1);
        if (bytes.length - processedBytes === 1) {
            receivedLrc = bytes[bytes.length - 1];
            calculatedLrc = calculateLrc(bytes.slice(0, -1));
        }
        else {
            calculatedLrc = calculateLrc(bytes);
        }
        message.lrc.calculated = calculatedLrc;
        message.lrc.received = receivedLrc;
        if (receivedLrc === calculatedLrc) {
            return message;
        }
        return {
            message,
            error: 'Mismatch LRC.'
        };
    };

    const fromBytesMap = {};
    const nameMap = uplinkNames;
    const fromBytes$1 = getFromBytes(fromBytesMap, nameMap);
    fromBytesMap[id$B] = fromBytes$D;
    fromBytesMap[id$A] = fromBytes$C;
    fromBytesMap[id$z] = fromBytes$B;
    fromBytesMap[id$y] = fromBytes$A;
    fromBytesMap[id$x] = fromBytes$z;
    fromBytesMap[id$w] = fromBytes$y;
    fromBytesMap[id$v] = fromBytes$x;
    fromBytesMap[id$u] = fromBytes$w;
    fromBytesMap[id$t] = fromBytes$v;
    fromBytesMap[id$s] = fromBytes$u;
    fromBytesMap[id$r] = fromBytes$t;
    fromBytesMap[id$q] = fromBytes$s;
    fromBytesMap[id$p] = fromBytes$r;
    fromBytesMap[id$o] = fromBytes$q;
    fromBytesMap[id$n] = fromBytes$p;
    fromBytesMap[id$m] = fromBytes$o;
    fromBytesMap[id$l] = fromBytes$n;
    fromBytesMap[id$k] = fromBytes$m;
    fromBytesMap[id$j] = fromBytes$l;
    fromBytesMap[id$i] = fromBytes$k;
    fromBytesMap[id$h] = fromBytes$j;
    fromBytesMap[id$g] = fromBytes$i;
    fromBytesMap[id$e] = fromBytes$g;
    fromBytesMap[id$d] = fromBytes$f;
    fromBytesMap[id$c] = fromBytes$e;
    fromBytesMap[id$b] = fromBytes$d;
    fromBytesMap[id$a] = fromBytes$c;
    fromBytesMap[id$9] = fromBytes$b;
    fromBytesMap[id$8] = fromBytes$a;
    fromBytesMap[id$f] = fromBytes$h;
    fromBytesMap[id$7] = fromBytes$9;
    fromBytesMap[id$6] = fromBytes$8;
    fromBytesMap[id$5] = fromBytes$7;
    fromBytesMap[id$4] = fromBytes$6;
    fromBytesMap[id$3] = fromBytes$5;
    fromBytesMap[id$2] = fromBytes$4;
    fromBytesMap[id$1] = fromBytes$3;
    fromBytesMap[id] = fromBytes$2;

    // export
    getBytesFromHex = getBytesFromHex$1;
    fromBytes = fromBytes$1;

})();
//#endregion


// these options can be edited
// available hardware types can be found here:
// https://github.com/jooby-dev/jooby-docs/blob/main/docs/analog/basics.md#hardware-types
const config = {
    // required field
    hardwareType: 12
};

const INITIAL_YEAR_TIMESTAMP = 946684800;


function decodeUplink ( bytes ) {
    const message = fromBytes(bytes, config);
    const data = {};

    if ( !message.error ) {
        message.commands.forEach(command => {
            const parameters = command.parameters;

            switch ( command.name ) {
                case 'hourMc':
                    data.hourMcStartTime = parameters.startTime2000 + INITIAL_YEAR_TIMESTAMP;
                    data.hourMcHours = parameters.hours;
                    parameters.channelList.forEach(channel => {
                        data['hourMcChannel' + channel.index + 'StartValue'] = channel.value;
                        data['hourMcChannel' + channel.index + 'CurrentValue'] = channel.value + channel.diff.reduce((a, b) => a + b, 0);
                    });
                    break;

                case 'lastEvent':
                    data.lastEventSequenceNumber = parameters.sequenceNumber;
                    data.lastEventStatusIsBatteryLow = parameters.status.isBatteryLow;
                    data.lastEventStatusIsMagneticInfluence = parameters.status.isMagneticInfluence;
                    data.lastEventStatusIsButtonReleased = parameters.status.isButtonReleased;
                    data.lastEventStatusIsConnectionLost = parameters.status.isConnectionLost;
                    break;
            }
        });
    }

    return data;
};


const payloadItem = payload.find(item => item.variable === 'payload');

if ( payloadItem ) {
    const data = decodeUplink(getBytesFromHex(payloadItem.value));

    for ( const name in data ) {
        payload.push({
            variable: name,
            value: data[name]
        });
    }
}
