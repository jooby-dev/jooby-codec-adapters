// this is for testing only!

var logs = '';


//#region [autogenerated jooby-codec bundle from index.js]
(function () {
  'use strict';

  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
        t && (r = t);
        var n = 0,
          F = function () {};
        return {
          s: F,
          n: function () {
            return n >= r.length ? {
              done: true
            } : {
              done: false,
              value: r[n++]
            };
          },
          e: function (r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = true,
      u = false;
    return {
      s: function () {
        t = t.call(r);
      },
      n: function () {
        var r = t.next();
        return a = r.done, r;
      },
      e: function (r) {
        u = true, o = r;
      },
      f: function () {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
    }
  }

  var hexFormatOptions = {
    separator: ' ',
    prefix: ''
  };

  var INT8_SIZE = 1;
  var INT16_SIZE = 2;
  var INT24_SIZE = 3;
  var INT32_SIZE = 4;
  var log = Math.log,
    pow = Math.pow,
    LN2 = Math.LN2;
  var readFloat = function readFloat(buffer, offset, isLittleEndian, mLen, bytes) {
    var e,
      m,
      eLen = bytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLittleEndian ? bytes - 1 : 0,
      d = isLittleEndian ? -1 : 1,
      s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 0x100 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 0x100 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : s ? -Infinity : Infinity;
    } else {
      m = m + pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * pow(2, e - mLen);
  };
  var writeFloat = function writeFloat(buffer, offset, value, isLittleEndian, mLen, bytes) {
    var e,
      m,
      c,
      eLen = bytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0,
      i = isLittleEndian ? 0 : bytes - 1,
      d = isLittleEndian ? 1 : -1,
      s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value < 0 && (value = -value);
    if (value !== value || value === Infinity) {
      m = value !== value ? 1 : 0;
      e = eMax;
    } else {
      e = log(value) / LN2 | 0;
      if (value * (c = pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * pow(2, eBias - 1) * pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 0x100, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 0x100, eLen -= 8);
    buffer[offset + i - d] |= s * 0x80;
  };
  var be2 = [1, 0];
  var be3 = [2, 1, 0];
  var be4 = [3, 2, 1, 0];
  var le2 = [0, 1];
  var le3 = [0, 1, 2];
  var le4 = [0, 1, 2, 3];
  var readUint8 = function readUint8(buffer, offset) {
    return buffer[offset];
  };
  var readUint16 = function readUint16(buffer, offset, isLittleEndian) {
    var order = isLittleEndian ? le2 : be2;
    var b0 = buffer[offset + order[0]];
    var b1 = buffer[offset + order[1]] << 8;
    return b0 | b1;
  };
  var readUint24 = function readUint24(buffer, offset, isLittleEndian) {
    var order = isLittleEndian ? le3 : be3;
    var b0 = buffer[offset + order[0]];
    var b1 = buffer[offset + order[1]] << 8;
    var b2 = buffer[offset + order[2]] << 16;
    return b0 | b1 | b2;
  };
  var readUint32 = function readUint32(buffer, offset, isLittleEndian) {
    var order = isLittleEndian ? le4 : be4;
    var b0 = buffer[offset + order[3]] * 0x1000000;
    var b1 = buffer[offset + order[2]] * 0x10000;
    var b2 = buffer[offset + order[1]] * 0x100;
    var b3 = buffer[offset + order[0]];
    return b0 + b1 + b2 + b3;
  };
  var writeUint8 = function writeUint8(buffer, offset, value) {
    buffer[offset] = value & 0xff;
  };
  var writeUint16 = function writeUint16(buffer, offset, value, isLittleEndian) {
    var order = isLittleEndian ? le2 : be2;
    buffer[offset + order[0]] = value & 0xff;
    buffer[offset + order[1]] = value >>> 8 & 0xff;
  };
  var writeUint24 = function writeUint24(buffer, offset, value, isLittleEndian) {
    var order = isLittleEndian ? le3 : be3;
    buffer[offset + order[0]] = value & 0xff;
    buffer[offset + order[1]] = value >>> 8 & 0xff;
    buffer[offset + order[2]] = value >>> 16 & 0xff;
  };
  var writeUint32 = function writeUint32(buffer, offset, value, isLittleEndian) {
    var order = isLittleEndian ? le4 : be4;
    buffer[offset + order[0]] = value & 0xff;
    buffer[offset + order[1]] = value >>> 8 & 0xff;
    buffer[offset + order[2]] = value >>> 16 & 0xff;
    buffer[offset + order[3]] = value >>> 24 & 0xff;
  };
  function BinaryBuffer(dataOrLength) {
    var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (typeof dataOrLength === 'number') {
      var bytes = new Array(dataOrLength).fill(0);
      this.data = bytes;
    } else {
      this.data = dataOrLength;
    }
    this.offset = 0;
    this.isLittleEndian = isLittleEndian;
  }
  BinaryBuffer.prototype = {
    toUint8Array: function toUint8Array() {
      return this.data;
    },
    seek: function seek(position) {
      if (position < 0 || position >= this.data.length) {
        throw new Error('Invalid position.');
      }
      this.offset = position;
    },
    setInt8: function setInt8(value) {
      writeUint8(this.data, this.offset, value < 0 ? value | 0x100 : value);
      this.offset += INT8_SIZE;
    },
    getInt8: function getInt8() {
      var result = readUint8(this.data, this.offset);
      this.offset += INT8_SIZE;
      return result & 0x80 ? result ^ -256 : result;
    },
    setUint8: function setUint8(value) {
      writeUint8(this.data, this.offset, value);
      this.offset += INT8_SIZE;
    },
    getUint8: function getUint8() {
      var result = readUint8(this.data, this.offset);
      this.offset += INT8_SIZE;
      return result;
    },
    setInt16: function setInt16(value) {
      var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
      writeUint16(this.data, this.offset, value < 0 ? value | 0x10000 : value, isLittleEndian);
      this.offset += INT16_SIZE;
    },
    getInt16: function getInt16() {
      var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
      var result = readUint16(this.data, this.offset, isLittleEndian);
      this.offset += INT16_SIZE;
      return result & 0x8000 ? result ^ -65536 : result;
    },
    setUint16: function setUint16(value) {
      var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
      writeUint16(this.data, this.offset, value, isLittleEndian);
      this.offset += INT16_SIZE;
    },
    getUint16: function getUint16() {
      var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
      var result = readUint16(this.data, this.offset, isLittleEndian);
      this.offset += INT16_SIZE;
      return result;
    },
    setInt24: function setInt24(value) {
      var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
      writeUint24(this.data, this.offset, value < 0 ? value | 0x1000000 : value, isLittleEndian);
      this.offset += INT24_SIZE;
    },
    getInt24: function getInt24() {
      var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
      var result = readUint24(this.data, this.offset, isLittleEndian);
      this.offset += INT24_SIZE;
      return result & 0x800000 ? result ^ -16777216 : result;
    },
    setUint24: function setUint24(value) {
      var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
      writeUint24(this.data, this.offset, value, isLittleEndian);
      this.offset += INT24_SIZE;
    },
    getUint24: function getUint24() {
      var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
      var result = readUint24(this.data, this.offset, isLittleEndian);
      this.offset += INT24_SIZE;
      return result;
    },
    setInt32: function setInt32(value) {
      var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
      writeUint32(this.data, this.offset, value < 0 ? value | 0x100000000 : value, isLittleEndian);
      this.offset += INT32_SIZE;
    },
    getInt32: function getInt32() {
      var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
      var result = readUint32(this.data, this.offset, isLittleEndian);
      this.offset += INT32_SIZE;
      return result & 0x80000000 ? result ^ -4294967296 : result;
    },
    setUint32: function setUint32(value) {
      var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
      writeUint32(this.data, this.offset, value, isLittleEndian);
      this.offset += INT32_SIZE;
    },
    getUint32: function getUint32() {
      var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
      var result = readUint32(this.data, this.offset, isLittleEndian);
      this.offset += INT32_SIZE;
      return result;
    },
    setFloat32: function setFloat32(value) {
      var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
      writeFloat(this.data, this.offset, value, isLittleEndian, 23, 4);
      this.offset += INT32_SIZE;
    },
    getFloat32: function getFloat32() {
      var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
      var result = readFloat(this.data, this.offset, isLittleEndian, 23, 4);
      this.offset += INT32_SIZE;
      return result;
    },
    setString: function setString(value) {
      this.setUint8(value.length);
      for (var index = 0; index < value.length; ++index) {
        this.setUint8(value.charCodeAt(index));
      }
    },
    getString: function getString() {
      var size = this.getUint8();
      var endIndex = this.offset + size;
      var chars = [];
      while (this.offset < endIndex) {
        chars.push(String.fromCharCode(this.getUint8()));
      }
      return chars.join('');
    },
    getBytesToOffset: function getBytesToOffset() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.offset;
      return this.data.slice(0, offset);
    },
    getBytesLeft: function getBytesLeft() {
      return this.getBytes(this.bytesLeft);
    },
    getBytes: function getBytes(length) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;
      this.offset = offset + length;
      return this.data.slice(offset, this.offset);
    },
    setBytes: function setBytes(data) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;
      var bytes = this.data;
      bytes.splice.apply(bytes, [offset, data.length].concat(_toConsumableArray(data)));
      this.data = bytes;
      this.offset = offset + data.length;
    }
  };
  Object.defineProperties(BinaryBuffer.prototype, {
    size: {
      get: function get() {
        return this.data.length;
      }
    },
    isEmpty: {
      get: function get() {
        if (this.offset > this.data.length) {
          throw new Error("current offset ".concat(this.offset, " is outside the bounds of the buffer"));
        }
        return this.data.length - this.offset === 0;
      }
    },
    bytesLeft: {
      get: function get() {
        return this.data.length - this.offset;
      }
    },
    position: {
      get: function get() {
        return this.offset;
      }
    }
  });

  var extraCommandMask = 0x1f;
  var toBytes$t = function toBytes(commandId, commandSize) {
    if ((commandId & extraCommandMask) === 0) {
      if (commandSize > extraCommandMask) {
        throw new Error("Wrong command id/size. Id: ".concat(commandId, ", size: ").concat(commandSize, "."));
      }
      return [commandId | commandSize];
    }
    if (commandId > extraCommandMask) {
      return [extraCommandMask, commandId >> 8, commandSize];
    }
    return [commandId, commandSize];
  };

  var toBytes$s = function toBytes(commandId) {
    var commandBytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var headerData = toBytes$t(commandId, commandBytes.length);
    return [].concat(_toConsumableArray(headerData), _toConsumableArray(commandBytes));
  };

  var getHexFromBytes = (function (bytes) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _Object$assign = Object.assign({}, hexFormatOptions, options),
      separator = _Object$assign.separator,
      prefix = _Object$assign.prefix;
    return bytes.map(function (_byte) {
      return "".concat(prefix).concat(_byte.toString(16).padStart(2, '0'));
    }).join(separator);
  });

  var validateCommandPayload = (function (commandName, bytes, expectedLength) {
    if (!commandName) {
      throw new Error('Command name is required.');
    }
    if (bytes && !Array.isArray(bytes)) {
      throw new Error("Invalid payload for ".concat(commandName, ". Expected array, got: ").concat(_typeof(bytes), "."));
    }
    if (bytes.length !== expectedLength) {
      var hex = getHexFromBytes(bytes, {
        separator: ''
      });
      throw new Error("Wrong buffer size for ".concat(commandName, ": ").concat(bytes.length, ". Expected: ").concat(expectedLength, ". Payload: 0x").concat(hex, "."));
    }
  });

  var setTime2000$1 = 0x02;
  var setParameter$2 = 0x03;
  var getParameter$2 = 0x04;
  var getArchiveHours$1 = 0x05;
  var getArchiveDays$1 = 0x06;
  var getCurrent$1 = 0x07;
  var getTime2000$1 = 0x09;
  var getArchiveEvents$1 = 0x0b;
  var correctTime2000$1 = 0x0c;
  var getStatus$1 = 0x14;
  var getCurrentMc$1 = 0x18;
  var softRestart$1 = 0x19;
  var getArchiveHoursMc$1 = 0x1a;
  var getArchiveDaysMc$1 = 0x1b;
  var dataSegment$1 = 0x1e;
  var getLmicInfo$1 = 0x21f;
  var getBatteryStatus$1 = 0x51f;
  var usWaterMeterCommand$1 = 0x71f;
  var getExAbsArchiveHoursMc$1 = 0xc1f;
  var getExAbsArchiveDaysMc$1 = 0xd1f;
  var getExAbsCurrentMc$1 = 0xf1f;
  var writeImage$1 = 0x2a1f;
  var verifyImage$1 = 0x2b1f;
  var updateRun$1 = 0x2c1f;
  var getArchiveHoursMcEx$1 = 0x301f;
  var getChannelsStatus$1 = 0x321f;
  var getChannelsTypes$1 = 0x331f;
  var getSignalQuality$1 = 0x341f;

  var downlinkIds = /*#__PURE__*/Object.freeze({
    __proto__: null,
    correctTime2000: correctTime2000$1,
    dataSegment: dataSegment$1,
    getArchiveDays: getArchiveDays$1,
    getArchiveDaysMc: getArchiveDaysMc$1,
    getArchiveEvents: getArchiveEvents$1,
    getArchiveHours: getArchiveHours$1,
    getArchiveHoursMc: getArchiveHoursMc$1,
    getArchiveHoursMcEx: getArchiveHoursMcEx$1,
    getBatteryStatus: getBatteryStatus$1,
    getChannelsStatus: getChannelsStatus$1,
    getChannelsTypes: getChannelsTypes$1,
    getCurrent: getCurrent$1,
    getCurrentMc: getCurrentMc$1,
    getExAbsArchiveDaysMc: getExAbsArchiveDaysMc$1,
    getExAbsArchiveHoursMc: getExAbsArchiveHoursMc$1,
    getExAbsCurrentMc: getExAbsCurrentMc$1,
    getLmicInfo: getLmicInfo$1,
    getParameter: getParameter$2,
    getSignalQuality: getSignalQuality$1,
    getStatus: getStatus$1,
    getTime2000: getTime2000$1,
    setParameter: setParameter$2,
    setTime2000: setTime2000$1,
    softRestart: softRestart$1,
    updateRun: updateRun$1,
    usWaterMeterCommand: usWaterMeterCommand$1,
    verifyImage: verifyImage$1,
    writeImage: writeImage$1
  });

  var invertObject = (function (source) {
    var target = {};
    for (var property in source) {
      var value = source[property];
      target[value] = property;
    }
    return target;
  });

  var commandNames = invertObject(downlinkIds);

  var id$r = correctTime2000$1;
  var name$r = commandNames[correctTime2000$1];
  var headerSize$r = 2;
  var COMMAND_BODY_SIZE$l = 2;
  var examples$r = {
    'correct time 120 seconds to the past': {
      id: id$r,
      name: name$r,
      headerSize: headerSize$r,
      parameters: {
        sequenceNumber: 45,
        seconds: -120
      },
      bytes: [0x0c, 0x02, 0x2d, 0x88]
    },
    'correct time 95 seconds to the future': {
      id: id$r,
      name: name$r,
      headerSize: headerSize$r,
      parameters: {
        sequenceNumber: 46,
        seconds: 95
      },
      bytes: [0x0c, 0x02, 0x2e, 0x5f]
    }
  };
  var fromBytes$r = function fromBytes(bytes) {
    validateCommandPayload(name$r, bytes, COMMAND_BODY_SIZE$l);
    var buffer = new BinaryBuffer(bytes, false);
    var parameters = {
      sequenceNumber: buffer.getUint8(),
      seconds: buffer.getInt8()
    };
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return parameters;
  };
  var toBytes$r = function toBytes(parameters) {
    var sequenceNumber = parameters.sequenceNumber,
      seconds = parameters.seconds;
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$l, false);
    buffer.setUint8(sequenceNumber);
    buffer.setInt8(seconds);
    return toBytes$s(id$r, buffer.data);
  };

  var correctTime2000 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$r,
    fromBytes: fromBytes$r,
    headerSize: headerSize$r,
    id: id$r,
    name: name$r,
    toBytes: toBytes$r
  });

  var fromObject = function fromObject() {
    var bitMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var booleanObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var result = 0;
    for (var name in booleanObject) {
      if (name in bitMask && booleanObject[name]) {
        result |= bitMask[name];
      }
    }
    return result;
  };
  var toObject = function toObject() {
    var bitMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var result = {};
    for (var name in bitMask) {
      result[name] = (value & bitMask[name]) !== 0;
    }
    return result;
  };
  var extractBits = function extractBits(value, bitsNumber, startIndex) {
    return (1 << bitsNumber) - 1 & value >> startIndex - 1;
  };
  var fillBits = function fillBits(value, bitsNumber, startIndex, valueToSet) {
    var mask = (1 << bitsNumber) - 1 << startIndex - 1;
    var newValueToSet = valueToSet;
    var result = value;
    result &= ~mask;
    newValueToSet <<= startIndex - 1;
    result |= newValueToSet;
    return result;
  };

  var getBytesFromHex = (function (hex) {
    var cleanHex = hex.trim();
    if (!cleanHex) {
      return [];
    }
    cleanHex = cleanHex.replace(/0x/g, '').split(/\s+/).map(function (_byte) {
      return _byte.padStart(2, '0');
    }).join('');
    if (cleanHex.length % 2 !== 0) {
      cleanHex = "0".concat(cleanHex);
    }
    var resultLength = cleanHex.length / 2;
    var bytes = new Array(resultLength);
    for (var index = 0; index < resultLength; index++) {
      bytes[index] = parseInt(cleanHex.substring(index * 2, index * 2 + 2), 16);
    }
    return bytes;
  });

  var roundNumber = (function (value) {
    var decimalPlaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
    var places = Math.pow(10, decimalPlaces);
    return Math.round(value * places * (1 + Number.EPSILON)) / places;
  });

  var INITIAL_YEAR_TIMESTAMP = 946684800000;
  var MILLISECONDS_IN_SECONDS = 1000;
  var getDateFromTime2000 = function getDateFromTime2000(time2000) {
    return new Date(INITIAL_YEAR_TIMESTAMP + time2000 * MILLISECONDS_IN_SECONDS);
  };
  var getTime2000FromDate = function getTime2000FromDate(date) {
    return (date.getTime() - INITIAL_YEAR_TIMESTAMP) / MILLISECONDS_IN_SECONDS;
  };

  var REPORTING_DATA_INTERVAL = 1;
  var DAY_CHECKOUT_HOUR = 4;
  var REPORTING_DATA_TYPE = 5;
  var PRIORITY_DATA_DELIVERY_TYPE = 8;
  var ACTIVATION_METHOD = 9;
  var BATTERY_DEPASSIVATION_INFO = 10;
  var BATTERY_MINIMAL_LOAD_TIME = 11;
  var CHANNELS_CONFIG = 13;
  var RX2_CONFIG = 18;
  var ABSOLUTE_DATA = 23;
  var ABSOLUTE_DATA_ENABLE = 24;
  var SERIAL_NUMBER = 25;
  var GEOLOCATION = 26;
  var EXTRA_FRAME_INTERVAL = 28;
  var ABSOLUTE_DATA_MULTI_CHANNEL = 29;
  var ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL = 30;
  var PULSE_CHANNELS_SCAN_CONFIG = 31;
  var PULSE_CHANNELS_SET_CONFIG = 32;
  var BATTERY_DEPASSIVATION_CONFIG = 33;
  var MQTT_SESSION_CONFIG = 34;
  var MQTT_BROKER_ADDRESS = 35;
  var MQTT_SSL_ENABLE = 36;
  var MQTT_TOPIC_PREFIX = 37;
  var MQTT_DATA_RECEIVE_CONFIG = 38;
  var MQTT_DATA_SEND_CONFIG = 39;
  var NBIOT_SSL_CONFIG = 40;
  var NBIOT_SSL_CACERT_WRITE = 41;
  var NBIOT_SSL_CACERT_SET = 42;
  var NBIOT_SSL_CLIENT_CERT_WRITE = 43;
  var NBIOT_SSL_CLIENT_CERT_SET = 44;
  var NBIOT_SSL_CLIENT_KEY_WRITE = 45;
  var NBIOT_SSL_CLIENT_KEY_SET = 46;
  var NBIOT_DEVICE_SOFTWARE_UPDATE = 47;
  var NBIOT_MODULE_FIRMWARE_UPDATE = 48;
  var REPORTING_DATA_CONFIG = 49;
  var EVENTS_CONFIG = 50;
  var NBIOT_MODULE_INFO = 51;
  var NBIOT_BANDS = 52;
  var NBIOT_APN = 53;
  var NBIOT_LED_INDICATION = 54;
  var NBIOT_SIM = 55;
  var CHANNEL_TYPE = 56;
  var EXTRA_PAYLOAD_ENABLE = 57;
  var TIME_SYNCHRONIZATION_PERIOD_VIA_MAC = 58;
  var KEEP_LORA_CONNECTION_ON_REMOVAL = 59;
  var NBIOT_NTP_SERVER = 60;
  var ACTIVATE_MODULE = 61;

  var deviceParameters = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ABSOLUTE_DATA: ABSOLUTE_DATA,
    ABSOLUTE_DATA_ENABLE: ABSOLUTE_DATA_ENABLE,
    ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL: ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL,
    ABSOLUTE_DATA_MULTI_CHANNEL: ABSOLUTE_DATA_MULTI_CHANNEL,
    ACTIVATE_MODULE: ACTIVATE_MODULE,
    ACTIVATION_METHOD: ACTIVATION_METHOD,
    BATTERY_DEPASSIVATION_CONFIG: BATTERY_DEPASSIVATION_CONFIG,
    BATTERY_DEPASSIVATION_INFO: BATTERY_DEPASSIVATION_INFO,
    BATTERY_MINIMAL_LOAD_TIME: BATTERY_MINIMAL_LOAD_TIME,
    CHANNELS_CONFIG: CHANNELS_CONFIG,
    CHANNEL_TYPE: CHANNEL_TYPE,
    DAY_CHECKOUT_HOUR: DAY_CHECKOUT_HOUR,
    EVENTS_CONFIG: EVENTS_CONFIG,
    EXTRA_FRAME_INTERVAL: EXTRA_FRAME_INTERVAL,
    EXTRA_PAYLOAD_ENABLE: EXTRA_PAYLOAD_ENABLE,
    GEOLOCATION: GEOLOCATION,
    KEEP_LORA_CONNECTION_ON_REMOVAL: KEEP_LORA_CONNECTION_ON_REMOVAL,
    MQTT_BROKER_ADDRESS: MQTT_BROKER_ADDRESS,
    MQTT_DATA_RECEIVE_CONFIG: MQTT_DATA_RECEIVE_CONFIG,
    MQTT_DATA_SEND_CONFIG: MQTT_DATA_SEND_CONFIG,
    MQTT_SESSION_CONFIG: MQTT_SESSION_CONFIG,
    MQTT_SSL_ENABLE: MQTT_SSL_ENABLE,
    MQTT_TOPIC_PREFIX: MQTT_TOPIC_PREFIX,
    NBIOT_APN: NBIOT_APN,
    NBIOT_BANDS: NBIOT_BANDS,
    NBIOT_DEVICE_SOFTWARE_UPDATE: NBIOT_DEVICE_SOFTWARE_UPDATE,
    NBIOT_LED_INDICATION: NBIOT_LED_INDICATION,
    NBIOT_MODULE_FIRMWARE_UPDATE: NBIOT_MODULE_FIRMWARE_UPDATE,
    NBIOT_MODULE_INFO: NBIOT_MODULE_INFO,
    NBIOT_NTP_SERVER: NBIOT_NTP_SERVER,
    NBIOT_SIM: NBIOT_SIM,
    NBIOT_SSL_CACERT_SET: NBIOT_SSL_CACERT_SET,
    NBIOT_SSL_CACERT_WRITE: NBIOT_SSL_CACERT_WRITE,
    NBIOT_SSL_CLIENT_CERT_SET: NBIOT_SSL_CLIENT_CERT_SET,
    NBIOT_SSL_CLIENT_CERT_WRITE: NBIOT_SSL_CLIENT_CERT_WRITE,
    NBIOT_SSL_CLIENT_KEY_SET: NBIOT_SSL_CLIENT_KEY_SET,
    NBIOT_SSL_CLIENT_KEY_WRITE: NBIOT_SSL_CLIENT_KEY_WRITE,
    NBIOT_SSL_CONFIG: NBIOT_SSL_CONFIG,
    PRIORITY_DATA_DELIVERY_TYPE: PRIORITY_DATA_DELIVERY_TYPE,
    PULSE_CHANNELS_SCAN_CONFIG: PULSE_CHANNELS_SCAN_CONFIG,
    PULSE_CHANNELS_SET_CONFIG: PULSE_CHANNELS_SET_CONFIG,
    REPORTING_DATA_CONFIG: REPORTING_DATA_CONFIG,
    REPORTING_DATA_INTERVAL: REPORTING_DATA_INTERVAL,
    REPORTING_DATA_TYPE: REPORTING_DATA_TYPE,
    RX2_CONFIG: RX2_CONFIG,
    SERIAL_NUMBER: SERIAL_NUMBER,
    TIME_SYNCHRONIZATION_PERIOD_VIA_MAC: TIME_SYNCHRONIZATION_PERIOD_VIA_MAC
  });

  var deviceParameterNames = invertObject(deviceParameters);

  var IDLE = 0;
  var PULSE_SENSOR = 1;
  var POWER_CHANNEL = 2;
  var BINARY_SENSOR = 3;
  var TEMPERATURE_SENSOR = 4;
  var BINARY_SENSOR_CONFIGURABLE = 5;

  var SF12B125 = 0;
  var SF11B125 = 1;
  var SF10B125 = 2;
  var SF9B125 = 3;
  var SF8B125 = 4;
  var SF7B125 = 5;
  var SF7B250 = 6;

  var rx2SpreadFactors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SF10B125: SF10B125,
    SF11B125: SF11B125,
    SF12B125: SF12B125,
    SF7B125: SF7B125,
    SF7B250: SF7B250,
    SF8B125: SF8B125,
    SF9B125: SF9B125
  });

  var spreadFactorNames = invertObject(rx2SpreadFactors);

  var _parametersSizeMap, _deviceParameterConve;
  var INITIAL_YEAR = 2000;
  var MONTH_BIT_SIZE = 4;
  var DATE_BIT_SIZE = 5;
  var YEAR_START_INDEX = 1;
  var LAST_BIT_INDEX = 7;
  var DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT = 600;
  var PARAMETER_RX2_FREQUENCY_COEFFICIENT = 100;
  var SERIAL_NUMBER_SIZE = 6;
  var getChannelTypeSize = function getChannelTypeSize(_ref) {
    var type = _ref.type;
    var size = 1;
    switch (type) {
      case IDLE:
      case PULSE_SENSOR:
      case POWER_CHANNEL:
        break;
      case BINARY_SENSOR:
        size += 2;
        break;
      case TEMPERATURE_SENSOR:
        size += 5;
        break;
      case BINARY_SENSOR_CONFIGURABLE:
        size += 4;
        break;
    }
    return size;
  };
  var parametersSizeMap = (_parametersSizeMap = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parametersSizeMap, REPORTING_DATA_INTERVAL, 1 + 4), DAY_CHECKOUT_HOUR, 1 + 1), REPORTING_DATA_TYPE, 1 + 1), PRIORITY_DATA_DELIVERY_TYPE, 1 + 1), ACTIVATION_METHOD, 1 + 1), BATTERY_DEPASSIVATION_INFO, 1 + 6), BATTERY_MINIMAL_LOAD_TIME, 1 + 4), CHANNELS_CONFIG, 1 + 1), RX2_CONFIG, 1 + 4), ABSOLUTE_DATA, 1 + 9), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parametersSizeMap, ABSOLUTE_DATA_ENABLE, 1 + 1), SERIAL_NUMBER, 1 + 6), GEOLOCATION, 1 + 10), EXTRA_FRAME_INTERVAL, 1 + 2), ABSOLUTE_DATA_MULTI_CHANNEL, 1 + 10), ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL, 1 + 2), PULSE_CHANNELS_SCAN_CONFIG, 1 + 3), PULSE_CHANNELS_SET_CONFIG, 1 + 1), BATTERY_DEPASSIVATION_CONFIG, 1 + 4), MQTT_SSL_ENABLE, 1 + 1), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_parametersSizeMap, MQTT_DATA_RECEIVE_CONFIG, 1 + 3), MQTT_DATA_SEND_CONFIG, 1 + 3), NBIOT_SSL_CONFIG, 1 + 2), NBIOT_SSL_CACERT_SET, 1 + 4), NBIOT_SSL_CLIENT_CERT_SET, 1 + 4), NBIOT_SSL_CLIENT_KEY_SET, 1 + 4), REPORTING_DATA_CONFIG, 1 + 4), EVENTS_CONFIG, 1 + 3), NBIOT_LED_INDICATION, 1 + 2), NBIOT_SIM, 1 + 3), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_parametersSizeMap, EXTRA_PAYLOAD_ENABLE, 1 + 1), TIME_SYNCHRONIZATION_PERIOD_VIA_MAC, 1 + 4), KEEP_LORA_CONNECTION_ON_REMOVAL, 1 + 1), ACTIVATE_MODULE, 1 + 1));
  var fourChannelsBitMask = {
    channel1: Math.pow(2, 0),
    channel2: Math.pow(2, 1),
    channel3: Math.pow(2, 2),
    channel4: Math.pow(2, 3)
  };
  var getChannelsMaskFromNumber = function getChannelsMaskFromNumber(value) {
    var object = toObject(fourChannelsBitMask, value);
    return {
      channel1: object.channel1,
      channel2: object.channel2,
      channel3: object.channel3,
      channel4: object.channel4
    };
  };
  var setChannelsMaskToNumber = function setChannelsMaskToNumber(channelsMask) {
    var channel1 = channelsMask.channel1,
      channel2 = channelsMask.channel2,
      channel3 = channelsMask.channel3,
      channel4 = channelsMask.channel4;
    return fromObject(fourChannelsBitMask, {
      channel1: channel1,
      channel2: channel2,
      channel3: channel3,
      channel4: channel4
    });
  };
  var getChannelsMask = function getChannelsMask(buffer) {
    return getChannelsMaskFromNumber(buffer.getUint8());
  };
  var setChannelsMask = function setChannelsMask(buffer, channelsMask) {
    return buffer.setUint8(setChannelsMaskToNumber(channelsMask));
  };
  var byteToPulseCoefficientMap = {
    128: 1,
    129: 5,
    130: 10,
    131: 100,
    132: 1000,
    133: 10000,
    134: 100000
  };
  var pulseCoefficientToByteMap = invertObject(byteToPulseCoefficientMap);
  var isMSBSet = function isMSBSet(value) {
    return !!(value & 0x80);
  };
  var getNbiotSslWrite = function getNbiotSslWrite(buffer) {
    return {
      size: buffer.getUint16(),
      position: buffer.getUint16(),
      chunk: buffer.getBytesLeft()
    };
  };
  var setNbiotSslWrite = function setNbiotSslWrite(buffer, parameter) {
    if (parameter.size !== parameter.chunk.length) {
      throw new Error('ssl chunk size parameter doesn\'t match actual ssl chunk size');
    }
    buffer.setUint16(parameter.size);
    buffer.setUint16(parameter.position);
    buffer.setBytes(parameter.chunk);
  };
  var getNbiotSslSet = function getNbiotSslSet(buffer) {
    return {
      crc32: buffer.getUint32()
    };
  };
  var setNbiotSslSet = function setNbiotSslSet(buffer, parameter) {
    buffer.setUint32(parameter.crc32);
  };
  var deviceParameterConvertersMap = (_deviceParameterConve = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_deviceParameterConve, REPORTING_DATA_INTERVAL, {
    get: function get(buffer) {
      return {
        specialSchedulePeriod: buffer.getUint8() * DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT,
        firstDaysSpecialSchedule: buffer.getUint8(),
        lastDaysSpecialSchedule: buffer.getUint8(),
        period: buffer.getUint8() * DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.specialSchedulePeriod / DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT);
      buffer.setUint8(parameter.firstDaysSpecialSchedule);
      buffer.setUint8(parameter.lastDaysSpecialSchedule);
      buffer.setUint8(parameter.period / DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT);
    }
  }), DAY_CHECKOUT_HOUR, {
    get: function get(buffer) {
      return {
        value: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.value);
    }
  }), REPORTING_DATA_TYPE, {
    get: function get(buffer) {
      return {
        type: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.type);
    }
  }), PRIORITY_DATA_DELIVERY_TYPE, {
    get: function get(buffer) {
      return {
        value: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.value);
    }
  }), ACTIVATION_METHOD, {
    get: function get(buffer) {
      return {
        type: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.type);
    }
  }), BATTERY_DEPASSIVATION_INFO, {
    get: function get(buffer) {
      return {
        loadTime: buffer.getUint16(),
        internalResistance: buffer.getUint16(),
        lowVoltage: buffer.getUint16()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint16(parameter.loadTime);
      buffer.setUint16(parameter.internalResistance);
      buffer.setUint16(parameter.lowVoltage);
    }
  }), BATTERY_MINIMAL_LOAD_TIME, {
    get: function get(buffer) {
      return {
        value: buffer.getUint32()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint32(parameter.value);
    }
  }), CHANNELS_CONFIG, {
    get: function get(buffer) {
      return {
        value: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      if (parameter.value < 0 || parameter.value > 18) {
        throw new Error('channels config must be between 0-18');
      }
      buffer.setUint8(parameter.value);
    }
  }), RX2_CONFIG, {
    get: function get(buffer) {
      var spreadFactor = buffer.getUint8();
      var spreadFactorName = spreadFactorNames[spreadFactor];
      var frequency = buffer.getUint24() * PARAMETER_RX2_FREQUENCY_COEFFICIENT;
      return {
        spreadFactor: spreadFactor,
        spreadFactorName: spreadFactorName,
        frequency: frequency
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.spreadFactor);
      buffer.setUint24(parameter.frequency / PARAMETER_RX2_FREQUENCY_COEFFICIENT);
    }
  }), ABSOLUTE_DATA, {
    get: function get(buffer) {
      return {
        meterValue: buffer.getUint32(),
        pulseCoefficient: getPulseCoefficient(buffer),
        value: buffer.getUint32()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint32(parameter.meterValue);
      setPulseCoefficient(buffer, parameter.pulseCoefficient);
      buffer.setUint32(parameter.value);
    }
  }), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_deviceParameterConve, ABSOLUTE_DATA_ENABLE, {
    get: function get(buffer) {
      return {
        state: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.state);
    }
  }), SERIAL_NUMBER, {
    get: function get(buffer) {
      return {
        value: getHexFromBytes(buffer.getBytes(SERIAL_NUMBER_SIZE))
      };
    },
    set: function set(buffer, parameter) {
      getBytesFromHex(parameter.value).forEach(function (_byte) {
        return buffer.setUint8(_byte);
      });
    }
  }), GEOLOCATION, {
    get: function get(buffer) {
      return {
        latitude: roundNumber(buffer.getFloat32()),
        longitude: roundNumber(buffer.getFloat32()),
        altitude: roundNumber(buffer.getUint16())
      };
    },
    set: function set(buffer, parameter) {
      buffer.setFloat32(roundNumber(parameter.latitude));
      buffer.setFloat32(roundNumber(parameter.longitude));
      buffer.setUint16(roundNumber(parameter.altitude));
    }
  }), EXTRA_FRAME_INTERVAL, {
    get: function get(buffer) {
      return {
        value: buffer.getUint16()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint16(parameter.value);
    }
  }), ABSOLUTE_DATA_MULTI_CHANNEL, {
    get: function get(buffer) {
      return {
        channel: getChannelValue(buffer),
        meterValue: buffer.getUint32(),
        pulseCoefficient: getPulseCoefficient(buffer),
        value: buffer.getUint32()
      };
    },
    set: function set(buffer, parameter) {
      setChannelValue(buffer, parameter.channel);
      buffer.setUint32(parameter.meterValue);
      setPulseCoefficient(buffer, parameter.pulseCoefficient);
      buffer.setUint32(parameter.value);
    }
  }), ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL, {
    get: function get(buffer) {
      return {
        channel: getChannelValue(buffer),
        state: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      setChannelValue(buffer, parameter.channel);
      buffer.setUint8(parameter.state);
    }
  }), PULSE_CHANNELS_SCAN_CONFIG, {
    get: function get(buffer) {
      return {
        channelList: getChannels(buffer),
        pullUpTime: buffer.getUint8(),
        scanTime: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      if (parameter.pullUpTime < 17) {
        throw new Error('minimal value for pullUpTime - 17');
      }
      if (parameter.scanTime < 15) {
        throw new Error('minimal value for scanTime - 15');
      }
      setChannels(buffer, parameter.channelList.map(function (index) {
        return {
          index: index
        };
      }));
      buffer.setUint8(parameter.pullUpTime);
      buffer.setUint8(parameter.scanTime);
    }
  }), PULSE_CHANNELS_SET_CONFIG, {
    get: getChannelsMask,
    set: setChannelsMask
  }), BATTERY_DEPASSIVATION_CONFIG, {
    get: function get(buffer) {
      return {
        resistanceStartThreshold: buffer.getUint16(),
        resistanceStopThreshold: buffer.getUint16()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint16(parameter.resistanceStartThreshold);
      buffer.setUint16(parameter.resistanceStopThreshold);
    }
  }), MQTT_SESSION_CONFIG, {
    get: function get(buffer) {
      return {
        clientId: buffer.getString(),
        username: buffer.getString(),
        password: buffer.getString(),
        cleanSession: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setString(parameter.clientId);
      buffer.setString(parameter.username);
      buffer.setString(parameter.password);
      buffer.setUint8(parameter.cleanSession);
    }
  }), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_deviceParameterConve, MQTT_BROKER_ADDRESS, {
    get: function get(buffer) {
      return {
        hostName: buffer.getString(),
        port: buffer.getUint16()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setString(parameter.hostName);
      buffer.setUint16(parameter.port);
    }
  }), MQTT_SSL_ENABLE, {
    get: function get(buffer) {
      return {
        enable: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.enable);
    }
  }), MQTT_TOPIC_PREFIX, {
    get: function get(buffer) {
      return {
        topicPrefix: buffer.getString()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setString(parameter.topicPrefix);
    }
  }), MQTT_DATA_RECEIVE_CONFIG, {
    get: function get(buffer) {
      return {
        qos: buffer.getUint8(),
        count: buffer.getUint8(),
        timeout: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.qos);
      buffer.setUint8(parameter.count);
      buffer.setUint8(parameter.timeout);
    }
  }), MQTT_DATA_SEND_CONFIG, {
    get: function get(buffer) {
      return {
        qos: buffer.getUint8(),
        retain: buffer.getUint8(),
        newestSendFirst: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.qos);
      buffer.setUint8(parameter.retain);
      buffer.setUint8(parameter.newestSendFirst);
    }
  }), NBIOT_SSL_CONFIG, {
    get: function get(buffer) {
      return {
        securityLevel: buffer.getUint8(),
        version: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.securityLevel);
      buffer.setUint8(parameter.version);
    }
  }), NBIOT_SSL_CACERT_WRITE, {
    get: getNbiotSslWrite,
    set: setNbiotSslWrite
  }), NBIOT_SSL_CACERT_SET, {
    get: getNbiotSslSet,
    set: setNbiotSslSet
  }), NBIOT_SSL_CLIENT_CERT_WRITE, {
    get: getNbiotSslWrite,
    set: setNbiotSslWrite
  }), NBIOT_SSL_CLIENT_CERT_SET, {
    get: getNbiotSslSet,
    set: setNbiotSslSet
  }), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_deviceParameterConve, NBIOT_SSL_CLIENT_KEY_WRITE, {
    get: getNbiotSslWrite,
    set: setNbiotSslWrite
  }), NBIOT_SSL_CLIENT_KEY_SET, {
    get: getNbiotSslSet,
    set: setNbiotSslSet
  }), NBIOT_DEVICE_SOFTWARE_UPDATE, {
    get: function get(buffer) {
      return {
        softwareImageUrl: buffer.getString()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setString(parameter.softwareImageUrl);
    }
  }), NBIOT_MODULE_FIRMWARE_UPDATE, {
    get: function get(buffer) {
      return {
        moduleFirmwareImageUrl: buffer.getString()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setString(parameter.moduleFirmwareImageUrl);
    }
  }), REPORTING_DATA_CONFIG, {
    get: function get(buffer) {
      return {
        dataType: buffer.getUint8(),
        hour: buffer.getUint8(),
        minutes: buffer.getUint8(),
        countToSend: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.dataType);
      buffer.setUint8(parameter.hour);
      buffer.setUint8(parameter.minutes);
      buffer.setUint8(parameter.countToSend);
    }
  }), EVENTS_CONFIG, {
    get: function get(buffer) {
      return {
        eventId: buffer.getUint8(),
        sendEvent: buffer.getUint8(),
        saveEvent: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.eventId);
      buffer.setUint8(parameter.sendEvent);
      buffer.setUint8(parameter.saveEvent);
    }
  }), NBIOT_MODULE_INFO, {
    get: function get(buffer) {
      return {
        moduleInfo: buffer.getString()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setString(parameter.moduleInfo);
    }
  }), NBIOT_BANDS, {
    get: function get(buffer) {
      var count = buffer.getUint8();
      var bands = [];
      for (var index = 0; index < count; index++) {
        bands.push(buffer.getUint8());
      }
      return {
        bands: bands
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.bands.length);
      var _iterator = _createForOfIteratorHelper(parameter.bands),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var band = _step.value;
          buffer.setUint8(band);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }), NBIOT_APN, {
    get: function get(buffer) {
      return {
        apn: buffer.getString()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setString(parameter.apn);
    }
  }), NBIOT_LED_INDICATION, {
    get: function get(buffer) {
      return {
        enableLed: buffer.getUint8(),
        enableNbiotNetworkLed: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.enableLed);
      buffer.setUint8(parameter.enableNbiotNetworkLed);
    }
  }), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_deviceParameterConve, NBIOT_SIM, {
    get: function get(buffer) {
      return {
        enable: buffer.getUint8(),
        pin: buffer.getUint16()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.enable);
      buffer.setUint16(parameter.pin);
    }
  }), CHANNEL_TYPE, {
    get: function get(buffer) {
      return getChannelType(buffer);
    },
    set: function set(buffer, parameter) {
      return setChannelType(buffer, parameter);
    }
  }), EXTRA_PAYLOAD_ENABLE, {
    get: function get(buffer) {
      return {
        enable: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.enable);
    }
  }), TIME_SYNCHRONIZATION_PERIOD_VIA_MAC, {
    get: function get(buffer) {
      return {
        period: buffer.getUint32()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint32(parameter.period);
    }
  }), KEEP_LORA_CONNECTION_ON_REMOVAL, {
    get: function get(buffer) {
      return {
        value: buffer.getUint8() !== 0
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.value ? 1 : 0);
    }
  }), NBIOT_NTP_SERVER, {
    get: function get(buffer) {
      return {
        server: buffer.getString(),
        port: buffer.getUint16()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setString(parameter.server);
      buffer.setUint16(parameter.port);
    }
  }), ACTIVATE_MODULE, {
    get: function get(buffer) {
      return {
        enable: buffer.getUint8()
      };
    },
    set: function set(buffer, parameter) {
      buffer.setUint8(parameter.enable);
    }
  }));
  var getParameterSize = function getParameterSize(parameter) {
    var size;
    var data;
    switch (parameter.id) {
      case MQTT_SESSION_CONFIG:
        data = parameter.data;
        size = 1 + 1;
        size += data.clientId.length + 1;
        size += data.username.length + 1;
        size += data.password.length + 1;
        break;
      case MQTT_BROKER_ADDRESS:
        data = parameter.data;
        size = 1 + 2;
        size += data.hostName.length + 1;
        break;
      case MQTT_TOPIC_PREFIX:
        data = parameter.data;
        size = 1;
        size += data.topicPrefix.length + 1;
        break;
      case NBIOT_SSL_CACERT_WRITE:
      case NBIOT_SSL_CLIENT_CERT_WRITE:
      case NBIOT_SSL_CLIENT_KEY_WRITE:
        data = parameter.data;
        size = 1 + 2 + 2;
        size += data.chunk.length;
        break;
      case NBIOT_DEVICE_SOFTWARE_UPDATE:
        data = parameter.data;
        size = 1;
        size += data.softwareImageUrl.length + 1;
        break;
      case NBIOT_MODULE_FIRMWARE_UPDATE:
        data = parameter.data;
        size = 1;
        size += data.moduleFirmwareImageUrl.length + 1;
        break;
      case NBIOT_MODULE_INFO:
        data = parameter.data;
        size = 1 + 1 + data.moduleInfo.length;
        break;
      case NBIOT_BANDS:
        data = parameter.data;
        size = 1 + 1;
        size += data.bands.length;
        break;
      case NBIOT_APN:
        data = parameter.data;
        size = 1 + 1 + data.apn.length;
        break;
      case CHANNEL_TYPE:
        data = parameter.data;
        size = 1 + getChannelTypeSize(data);
        break;
      case NBIOT_NTP_SERVER:
        data = parameter.data;
        size = 1 + 1 + data.server.length + 2;
        break;
      default:
        size = parametersSizeMap[parameter.id];
    }
    if (size === undefined) {
      throw new Error('unknown parameter id');
    }
    return size;
  };
  var getRequestParameterSize = function getRequestParameterSize(parameter) {
    var size;
    switch (parameter.id) {
      case ABSOLUTE_DATA_MULTI_CHANNEL:
      case ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL:
      case REPORTING_DATA_CONFIG:
      case EVENTS_CONFIG:
      case CHANNEL_TYPE:
        size = 2;
        break;
      default:
        size = 1;
        break;
    }
    return size;
  };
  var getTime = function getTime(buffer) {
    return buffer.getUint32();
  };
  var setTime = function setTime(buffer, value) {
    buffer.setUint32(value);
  };
  var getChannels = function getChannels(buffer) {
    var channelList = [];
    var extended = true;
    var channelIndex = 1;
    while (extended) {
      var _byte8 = buffer.getUint8();
      var bits = _byte8.toString(2).padStart(LAST_BIT_INDEX + 1, '0').split('').reverse();
      bits.forEach(function (bit, index) {
        var value = Number(bit);
        if (index === LAST_BIT_INDEX) {
          extended = !!value;
        } else {
          if (value) {
            channelList.push(channelIndex);
          }
          ++channelIndex;
        }
      });
    }
    return channelList;
  };
  var setChannels = function setChannels(buffer, channelList) {
    if (channelList.length === 0) {
      buffer.setUint8(0);
      return;
    }
    channelList.sort(function (a, b) {
      return a.index - b.index;
    });
    var maxChannel = Math.max.apply(Math, _toConsumableArray(channelList.map(function (_ref2) {
      var index = _ref2.index;
      return index;
    })));
    var size = (maxChannel - maxChannel % 8) / 8;
    var data = new Array(size + 1).fill(0);
    var _byte9 = 0;
    data.forEach(function (_, byteIndex) {
      var channelIndex = byteIndex * LAST_BIT_INDEX + 1;
      var maxChannelIndex = channelIndex + LAST_BIT_INDEX;
      while (channelIndex < maxChannelIndex) {
        var channel = channelList.find(function (item) {
          return item.index === channelIndex;
        });
        if (channel !== undefined) {
          _byte9 |= 1 << (channel.index - 1) % LAST_BIT_INDEX;
        }
        ++channelIndex;
      }
      if (data[byteIndex + 1] !== undefined) {
        _byte9 |= 1 << LAST_BIT_INDEX;
      }
      data[byteIndex] = _byte9;
      _byte9 = 0;
    });
    data.forEach(function (value) {
      return buffer.setUint8(value);
    });
  };
  var getChannelValue = function getChannelValue(buffer) {
    return buffer.getUint8() + 1;
  };
  var setChannelValue = function setChannelValue(buffer, value) {
    if (value < 1) {
      throw new Error('channel must be 1 or greater');
    }
    buffer.setUint8(value - 1);
  };
  var getHours = function getHours(buffer) {
    var _byte0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : buffer.getUint8();
    if (_byte0 === 0) {
      return {
        hours: 0,
        hour: 0
      };
    }
    var hours = ((_byte0 & 0xe0) >> 5) + 1;
    var hour = _byte0 & 0x1f;
    return {
      hours: hours,
      hour: hour
    };
  };
  var setHours = function setHours(buffer, hour, hours) {
    if (hour === 0 && hours === 0) {
      buffer.setUint8(0);
      return;
    }
    buffer.setUint8((hours - 1 & 0x07) << 5 | hour & 0x1f);
  };
  var getDate = function getDate(buffer) {
    var yearMonthByte = buffer.getUint8();
    var monthDateByte = buffer.getUint8();
    var year = yearMonthByte >> YEAR_START_INDEX;
    var month = (yearMonthByte & 0x01) << MONTH_BIT_SIZE - YEAR_START_INDEX | monthDateByte >> DATE_BIT_SIZE;
    var monthDay = monthDateByte & 0x1f;
    return new Date(Date.UTC(year + INITIAL_YEAR, month - 1, monthDay, 0, 0, 0, 0));
  };
  var setDate = function setDate(buffer, dateOrTime) {
    var date;
    if (dateOrTime instanceof Date) {
      date = dateOrTime;
    } else {
      date = getDateFromTime2000(dateOrTime);
    }
    var year = date.getUTCFullYear() - INITIAL_YEAR;
    var month = date.getUTCMonth() + 1;
    var day = date.getUTCDate();
    var yearMonthByte = year << YEAR_START_INDEX | month >> MONTH_BIT_SIZE - YEAR_START_INDEX;
    var monthDateByte = (month & 0x07) << DATE_BIT_SIZE | day;
    [yearMonthByte, monthDateByte].forEach(function (_byte1) {
      return buffer.setUint8(_byte1);
    });
  };
  var getPulseCoefficient = function getPulseCoefficient(buffer) {
    var pulseCoefficient = buffer.getUint8();
    if (isMSBSet(pulseCoefficient)) {
      var value = byteToPulseCoefficientMap[pulseCoefficient];
      if (value) {
        return value;
      }
      throw new Error('pulseCoefficient MSB is set, but value unknown');
    }
    return pulseCoefficient;
  };
  var setPulseCoefficient = function setPulseCoefficient(buffer, value) {
    if (value in pulseCoefficientToByteMap) {
      var _byte10 = pulseCoefficientToByteMap[value];
      if (_byte10) {
        buffer.setUint8(_byte10);
      } else {
        throw new Error('pulseCoefficient MSB is set, but value unknown');
      }
    } else {
      buffer.setUint8(value);
    }
  };
  var getParameter$1 = function getParameter(buffer) {
    var id = buffer.getUint8();
    var name = deviceParameterNames[id];
    if (!deviceParameterConvertersMap[id] || !deviceParameterConvertersMap[id].get) {
      throw new Error("parameter ".concat(id, " is not supported"));
    }
    var data = deviceParameterConvertersMap[id].get(buffer);
    return {
      id: id,
      name: name,
      data: data
    };
  };
  var setParameter$1 = function setParameter(buffer, parameter) {
    var id = parameter.id,
      data = parameter.data;
    if (!deviceParameterConvertersMap[id] || !deviceParameterConvertersMap[id].set) {
      throw new Error("parameter ".concat(id, " is not supported"));
    }
    buffer.setUint8(id);
    deviceParameterConvertersMap[id].set(buffer, data);
  };
  var getRequestParameter = function getRequestParameter(buffer) {
    var id = buffer.getUint8();
    var name = deviceParameterNames[id];
    var data = null;
    switch (id) {
      case ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL:
      case ABSOLUTE_DATA_MULTI_CHANNEL:
      case CHANNEL_TYPE:
        data = {
          channel: getChannelValue(buffer)
        };
        break;
      case REPORTING_DATA_CONFIG:
        data = {
          dataType: buffer.getUint8()
        };
        break;
      case EVENTS_CONFIG:
        data = {
          eventId: buffer.getUint8()
        };
        break;
    }
    return {
      id: id,
      name: name,
      data: data
    };
  };
  var setRequestParameter = function setRequestParameter(buffer, parameter) {
    var id = parameter.id,
      parameterData = parameter.data;
    var data;
    buffer.setUint8(id);
    switch (id) {
      case ABSOLUTE_DATA_MULTI_CHANNEL:
      case ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL:
      case CHANNEL_TYPE:
        data = parameterData;
        setChannelValue(buffer, data.channel);
        break;
      case REPORTING_DATA_CONFIG:
        data = parameterData;
        buffer.setUint8(data.dataType);
        break;
      case EVENTS_CONFIG:
        data = parameterData;
        buffer.setUint8(data.eventId);
        break;
    }
  };
  var getDataSegment = function getDataSegment(buffer) {
    var segmentationSessionId = buffer.getUint8();
    var flag = buffer.getUint8();
    return {
      segmentationSessionId: segmentationSessionId,
      segmentIndex: extractBits(flag, 3, 1),
      segmentsNumber: extractBits(flag, 3, 5),
      isLast: Boolean(extractBits(flag, 1, 8)),
      data: buffer.getBytesLeft()
    };
  };
  var setDataSegment = function setDataSegment(buffer, parameters) {
    var flag = fillBits(0, 3, 1, parameters.segmentIndex);
    flag = fillBits(flag, 3, 5, parameters.segmentsNumber);
    flag = fillBits(flag, 1, 8, +parameters.isLast);
    buffer.setUint8(parameters.segmentationSessionId);
    buffer.setUint8(flag);
    buffer.setBytes(parameters.data);
  };
  var getBinarySensor = function getBinarySensor(buffer) {
    var activeStateTimeMs = buffer.getUint16();
    return {
      activeStateTimeMs: activeStateTimeMs
    };
  };
  var setBinarySensor = function setBinarySensor(buffer, parameters) {
    buffer.setUint16(parameters.activeStateTimeMs);
  };
  var getBinarySensorConfigurable = function getBinarySensorConfigurable(buffer) {
    var type = buffer.getUint8();
    var activeStateTimeMs = buffer.getUint16();
    var halState = buffer.getUint8();
    return {
      type: type,
      activeStateTimeMs: activeStateTimeMs,
      halState: halState
    };
  };
  var setBinarySensorConfigurable = function setBinarySensorConfigurable(buffer, parameters) {
    buffer.setUint8(parameters.type);
    buffer.setUint16(parameters.activeStateTimeMs);
    buffer.setUint8(parameters.halState);
  };
  var getTemperatureSensor = function getTemperatureSensor(buffer) {
    var measurementPeriod = buffer.getUint16();
    var hysteresisSec = buffer.getUint8();
    var highTemperatureThreshold = buffer.getInt8();
    var lowTemperatureThreshold = buffer.getInt8();
    return {
      measurementPeriod: measurementPeriod,
      hysteresisSec: hysteresisSec,
      highTemperatureThreshold: highTemperatureThreshold,
      lowTemperatureThreshold: lowTemperatureThreshold
    };
  };
  var setTemperatureSensor = function setTemperatureSensor(buffer, parameters) {
    buffer.setUint16(parameters.measurementPeriod);
    buffer.setUint8(parameters.hysteresisSec);
    buffer.setInt8(parameters.highTemperatureThreshold);
    buffer.setInt8(parameters.lowTemperatureThreshold);
  };
  var getChannelType = function getChannelType(buffer) {
    var channel = getChannelValue(buffer);
    var type = buffer.getUint8();
    var parameters = {};
    switch (type) {
      case BINARY_SENSOR:
        parameters = getBinarySensor(buffer);
        break;
      case TEMPERATURE_SENSOR:
        parameters = getTemperatureSensor(buffer);
        break;
      case BINARY_SENSOR_CONFIGURABLE:
        parameters = getBinarySensorConfigurable(buffer);
        break;
    }
    return {
      channel: channel,
      type: type,
      parameters: parameters
    };
  };
  var setChannelType = function setChannelType(buffer, _ref7) {
    var type = _ref7.type,
      channel = _ref7.channel,
      parameters = _ref7.parameters;
    setChannelValue(buffer, channel);
    buffer.setUint8(type);
    switch (type) {
      case BINARY_SENSOR:
        setBinarySensor(buffer, parameters);
        break;
      case TEMPERATURE_SENSOR:
        setTemperatureSensor(buffer, parameters);
        break;
      case BINARY_SENSOR_CONFIGURABLE:
        setBinarySensorConfigurable(buffer, parameters);
        break;
    }
  };

  var HEX = 1;

  var getBase64FromBytes = (function (bytes) {
    return btoa(bytes.map(function (_byte) {
      return String.fromCharCode(_byte);
    }).join(''));
  });

  var defaultFormatOptions = {
    bytesConversionFormat: HEX,
    bytesConversionFormatOptions: {}
  };
  var getStringFromBytes = function getStringFromBytes(bytes) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFormatOptions;
    var _options$bytesConvers = options.bytesConversionFormat,
      bytesConversionFormat = _options$bytesConvers === void 0 ? defaultFormatOptions.bytesConversionFormat : _options$bytesConvers,
      _options$bytesConvers2 = options.bytesConversionFormatOptions,
      bytesConversionFormatOptions = _options$bytesConvers2 === void 0 ? defaultFormatOptions.bytesConversionFormatOptions : _options$bytesConvers2;
    return bytesConversionFormat === HEX ? getHexFromBytes(bytes, bytesConversionFormatOptions) : getBase64FromBytes(bytes);
  };

  var id$q = dataSegment$1;
  var name$q = commandNames[dataSegment$1];
  var headerSize$q = 2;
  var COMMAND_BODY_MIN_SIZE$1 = 2;
  var examples$q = {
    'DataSegment request': {
      id: id$q,
      name: name$q,
      headerSize: headerSize$q,
      parameters: {
        segmentationSessionId: 2,
        segmentIndex: 3,
        segmentsNumber: 5,
        isLast: false,
        data: [0x00, 0x01, 0x02, 0x03, 0x04]
      },
      bytes: [0x1e, 0x07, 0x02, 0x53, 0x00, 0x01, 0x02, 0x03, 0x04]
    }
  };
  var fromBytes$q = function fromBytes(bytes) {
    var buffer = new BinaryBuffer(bytes, false);
    return getDataSegment(buffer);
  };
  var toBytes$q = function toBytes(parameters) {
    var buffer = new BinaryBuffer(COMMAND_BODY_MIN_SIZE$1 + parameters.data.length, false);
    setDataSegment(buffer, parameters);
    return toBytes$s(id$q, buffer.data);
  };
  var toJson$2 = function toJson(parameters, options) {
    return JSON.stringify(_objectSpread2(_objectSpread2({}, parameters), {}, {
      data: getStringFromBytes(parameters.data, options)
    }));
  };

  var dataSegment = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$q,
    fromBytes: fromBytes$q,
    headerSize: headerSize$q,
    id: id$q,
    name: name$q,
    toBytes: toBytes$q,
    toJson: toJson$2
  });

  var id$p = getArchiveDays$1;
  var name$p = commandNames[getArchiveDays$1];
  var headerSize$p = 2;
  var COMMAND_BODY_SIZE$k = 3;
  var examples$p = {
    '1 day counter from 2023.03.10 00:00:00 GMT': {
      id: id$p,
      name: name$p,
      headerSize: headerSize$p,
      parameters: {
        startTime2000: 731721600,
        days: 1
      },
      bytes: [0x06, 0x03, 0x2e, 0x6a, 0x01]
    }
  };
  var fromBytes$p = function fromBytes(bytes) {
    validateCommandPayload(name$p, bytes, COMMAND_BODY_SIZE$k);
    var buffer = new BinaryBuffer(bytes, false);
    var date = getDate(buffer);
    var days = buffer.getUint8();
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return {
      startTime2000: getTime2000FromDate(date),
      days: days
    };
  };
  var toBytes$p = function toBytes(parameters) {
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$k, false);
    var startTime2000 = parameters.startTime2000,
      days = parameters.days;
    var date = getDateFromTime2000(startTime2000);
    setDate(buffer, date);
    buffer.setUint8(days);
    return toBytes$s(id$p, buffer.data);
  };

  var getArchiveDays = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$p,
    fromBytes: fromBytes$p,
    headerSize: headerSize$p,
    id: id$p,
    name: name$p,
    toBytes: toBytes$p
  });

  var id$o = getArchiveDaysMc$1;
  var name$o = commandNames[getArchiveDaysMc$1];
  var headerSize$o = 2;
  var COMMAND_BODY_SIZE$j = 4;
  var examples$o = {
    '1 day pulse counter for 1 channel from 2023.03.10 00:00:00 GMT': {
      id: id$o,
      name: name$o,
      headerSize: headerSize$o,
      parameters: {
        startTime2000: 731721600,
        days: 1,
        channelList: [1]
      },
      bytes: [0x1b, 0x04, 0x2e, 0x6a, 0x01, 0x01]
    }
  };
  var fromBytes$o = function fromBytes(bytes) {
    validateCommandPayload(name$o, bytes, COMMAND_BODY_SIZE$j);
    var buffer = new BinaryBuffer(bytes, false);
    var date = getDate(buffer);
    var channelList = getChannels(buffer);
    var days = buffer.getUint8();
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return {
      startTime2000: getTime2000FromDate(date),
      days: days,
      channelList: channelList
    };
  };
  var toBytes$o = function toBytes(parameters) {
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$j, false);
    var startTime2000 = parameters.startTime2000,
      days = parameters.days,
      channelList = parameters.channelList;
    var date = getDateFromTime2000(startTime2000);
    setDate(buffer, date);
    setChannels(buffer, channelList.map(function (index) {
      return {
        index: index
      };
    }));
    buffer.setUint8(days);
    return toBytes$s(id$o, buffer.data);
  };

  var getArchiveDaysMc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$o,
    fromBytes: fromBytes$o,
    headerSize: headerSize$o,
    id: id$o,
    name: name$o,
    toBytes: toBytes$o
  });

  var id$n = getArchiveEvents$1;
  var name$n = commandNames[getArchiveEvents$1];
  var headerSize$n = 2;
  var COMMAND_BODY_SIZE$i = 5;
  var examples$n = {
    'request 4 events from 2023.04.03 14:01:17 GMT': {
      id: id$n,
      name: name$n,
      headerSize: headerSize$n,
      parameters: {
        startTime2000: 733845677,
        events: 4
      },
      bytes: [0x0b, 0x05, 0x2b, 0xbd, 0x98, 0xad, 0x04]
    }
  };
  var fromBytes$n = function fromBytes(bytes) {
    validateCommandPayload(name$n, bytes, COMMAND_BODY_SIZE$i);
    var buffer = new BinaryBuffer(bytes, false);
    var startTime2000 = getTime(buffer);
    var events = buffer.getUint8();
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return {
      startTime2000: startTime2000,
      events: events
    };
  };
  var toBytes$n = function toBytes(parameters) {
    var startTime2000 = parameters.startTime2000,
      events = parameters.events;
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$i, false);
    setTime(buffer, startTime2000);
    buffer.setUint8(events);
    return toBytes$s(id$n, buffer.data);
  };

  var getArchiveEvents = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$n,
    fromBytes: fromBytes$n,
    headerSize: headerSize$n,
    id: id$n,
    name: name$n,
    toBytes: toBytes$n
  });

  var id$m = getArchiveHours$1;
  var name$m = commandNames[getArchiveHours$1];
  var headerSize$m = 2;
  var COMMAND_BODY_SIZE$h = 4;
  var examples$m = {
    '2 hours counter from 2023.12.23 12:00:00 GMT': {
      id: id$m,
      name: name$m,
      headerSize: headerSize$m,
      parameters: {
        startTime2000: 756648000,
        hours: 2
      },
      bytes: [0x05, 0x04, 0x2f, 0x97, 0x0c, 0x02]
    }
  };
  var fromBytes$m = function fromBytes(bytes) {
    validateCommandPayload(name$m, bytes, COMMAND_BODY_SIZE$h);
    var buffer = new BinaryBuffer(bytes, false);
    var date = getDate(buffer);
    var _getHours = getHours(buffer),
      hour = _getHours.hour;
    var hours = buffer.getUint8();
    date.setUTCHours(hour);
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return {
      startTime2000: getTime2000FromDate(date),
      hours: hours
    };
  };
  var toBytes$m = function toBytes(parameters) {
    var startTime2000 = parameters.startTime2000,
      hours = parameters.hours;
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$h, false);
    var date = getDateFromTime2000(startTime2000);
    var hour = date.getUTCHours();
    setDate(buffer, date);
    setHours(buffer, hour, 1);
    buffer.setUint8(hours);
    return toBytes$s(id$m, buffer.data);
  };

  var getArchiveHours = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$m,
    fromBytes: fromBytes$m,
    headerSize: headerSize$m,
    id: id$m,
    name: name$m,
    toBytes: toBytes$m
  });

  var id$l = getArchiveHoursMc$1;
  var name$l = commandNames[getArchiveHoursMc$1];
  var headerSize$l = 2;
  var COMMAND_BODY_SIZE$g = 4;
  var examples$l = {
    'hour pulse counter and 1 hour diff for 1 channel from 2023.12.23 12:00:00 GMT': {
      id: id$l,
      name: name$l,
      headerSize: headerSize$l,
      parameters: {
        startTime2000: 756648000,
        hours: 2,
        channelList: [1]
      },
      bytes: [0x1a, 0x04, 0x2f, 0x97, 0x2c, 0x01]
    }
  };
  var fromBytes$l = function fromBytes(bytes) {
    validateCommandPayload(name$l, bytes, COMMAND_BODY_SIZE$g);
    var buffer = new BinaryBuffer(bytes, false);
    var date = getDate(buffer);
    var _getHours = getHours(buffer),
      hour = _getHours.hour,
      hours = _getHours.hours;
    var channelList = getChannels(buffer);
    date.setUTCHours(hour);
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return {
      startTime2000: getTime2000FromDate(date),
      hours: hours,
      channelList: channelList
    };
  };
  var toBytes$l = function toBytes(parameters) {
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$g, false);
    var hours = parameters.hours,
      startTime2000 = parameters.startTime2000,
      channelList = parameters.channelList;
    var date = getDateFromTime2000(startTime2000);
    var hour = date.getUTCHours();
    setDate(buffer, date);
    setHours(buffer, hour, hours);
    setChannels(buffer, channelList.map(function (index) {
      return {
        index: index
      };
    }));
    return toBytes$s(id$l, buffer.data);
  };

  var getArchiveHoursMc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$l,
    fromBytes: fromBytes$l,
    headerSize: headerSize$l,
    id: id$l,
    name: name$l,
    toBytes: toBytes$l
  });

  var id$k = getArchiveHoursMcEx$1;
  var name$k = commandNames[getArchiveHoursMcEx$1];
  var headerSize$k = 3;
  var COMMAND_BODY_SIZE$f = 5;
  var examples$k = {
    '1 hour absolute values for 1 channel from 2023.12.23 12:00:00 GMT': {
      id: id$k,
      name: name$k,
      headerSize: headerSize$k,
      parameters: {
        startTime2000: 756648000,
        hour: 12,
        hours: 2,
        channelList: [1]
      },
      bytes: [0x1f, 0x30, 0x05, 0x2f, 0x97, 0x0c, 0x02, 0x01]
    }
  };
  var fromBytes$k = function fromBytes(bytes) {
    var buffer = new BinaryBuffer(bytes, false);
    var date = getDate(buffer);
    var hour = buffer.getUint8();
    var hours = buffer.getUint8();
    var channelList = getChannels(buffer);
    date.setUTCHours(hour);
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return {
      startTime2000: getTime2000FromDate(date),
      hour: hour,
      hours: hours,
      channelList: channelList
    };
  };
  var toBytes$k = function toBytes(parameters) {
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$f, false);
    var channelList = parameters.channelList,
      hour = parameters.hour,
      hours = parameters.hours,
      startTime2000 = parameters.startTime2000;
    var date = getDateFromTime2000(startTime2000);
    setDate(buffer, date);
    buffer.setUint8(hour);
    buffer.setUint8(hours);
    setChannels(buffer, channelList.map(function (index) {
      return {
        index: index
      };
    }));
    return toBytes$s(id$k, buffer.data);
  };

  var getArchiveHoursMcEx = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$k,
    fromBytes: fromBytes$k,
    headerSize: headerSize$k,
    id: id$k,
    name: name$k,
    toBytes: toBytes$k
  });

  var id$j = getBatteryStatus$1;
  var name$j = commandNames[getBatteryStatus$1];
  var headerSize$j = 3;
  var COMMAND_BODY_SIZE$e = 0;
  var examples$j = {
    'simple request': {
      id: id$j,
      name: name$j,
      headerSize: headerSize$j,
      parameters: {},
      bytes: [0x1f, 0x05, 0x00]
    }
  };
  var fromBytes$j = function fromBytes(bytes) {
    validateCommandPayload(name$j, bytes, COMMAND_BODY_SIZE$e);
    return {};
  };
  var toBytes$j = function toBytes() {
    return toBytes$s(id$j);
  };

  var getBatteryStatus = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$j,
    fromBytes: fromBytes$j,
    headerSize: headerSize$j,
    id: id$j,
    name: name$j,
    toBytes: toBytes$j
  });

  var id$i = getChannelsStatus$1;
  var name$i = commandNames[getChannelsStatus$1];
  var headerSize$i = 3;
  var examples$i = {
    'request the status of all channels': {
      id: id$i,
      name: name$i,
      headerSize: headerSize$i,
      parameters: {},
      bytes: [0x1f, 0x32, 0x00]
    },
    'request the status of the subsystems assigned to channels 0 and 1': {
      id: id$i,
      name: name$i,
      headerSize: headerSize$i,
      parameters: {
        channel1: true,
        channel2: true,
        channel3: false,
        channel4: false
      },
      bytes: [0x1f, 0x32, 0x01, 0x03]
    }
  };
  var fromBytes$i = function fromBytes(bytes) {
    return bytes.length === 0 ? {} : getChannelsMaskFromNumber(bytes[0]);
  };
  var toBytes$i = function toBytes(parameters) {
    return toBytes$s(id$i, Object.keys(parameters).length !== 0 ? [setChannelsMaskToNumber(parameters)] : []);
  };

  var getChannelsStatus = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$i,
    fromBytes: fromBytes$i,
    headerSize: headerSize$i,
    id: id$i,
    name: name$i,
    toBytes: toBytes$i
  });

  var id$h = getChannelsTypes$1;
  var name$h = commandNames[getChannelsTypes$1];
  var headerSize$h = 3;
  var COMMAND_BODY_SIZE$d = 0;
  var examples$h = {
    'request the channels map': {
      id: id$h,
      name: name$h,
      headerSize: headerSize$h,
      parameters: {},
      bytes: [0x1f, 0x33, 0x00]
    }
  };
  var fromBytes$h = function fromBytes(bytes) {
    validateCommandPayload(name$h, bytes, COMMAND_BODY_SIZE$d);
    return {};
  };
  var toBytes$h = function toBytes() {
    return toBytes$s(id$h);
  };

  var getChannelsTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$h,
    fromBytes: fromBytes$h,
    headerSize: headerSize$h,
    id: id$h,
    name: name$h,
    toBytes: toBytes$h
  });

  var id$g = getCurrent$1;
  var name$g = commandNames[getCurrent$1];
  var headerSize$g = 2;
  var COMMAND_BODY_SIZE$c = 0;
  var examples$g = {
    'simple request': {
      id: id$g,
      headerSize: headerSize$g,
      name: name$g,
      parameters: {},
      bytes: [0x07, 0x00]
    }
  };
  var fromBytes$g = function fromBytes(bytes) {
    validateCommandPayload(name$g, bytes, COMMAND_BODY_SIZE$c);
    return {};
  };
  var toBytes$g = function toBytes() {
    return toBytes$s(id$g);
  };

  var getCurrent = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$g,
    fromBytes: fromBytes$g,
    headerSize: headerSize$g,
    id: id$g,
    name: name$g,
    toBytes: toBytes$g
  });

  var id$f = getCurrentMc$1;
  var name$f = commandNames[getCurrentMc$1];
  var headerSize$f = 2;
  var COMMAND_BODY_SIZE$b = 0;
  var examples$f = {
    'simple request': {
      id: id$f,
      name: name$f,
      headerSize: headerSize$f,
      parameters: {},
      bytes: [0x18, 0x00]
    }
  };
  var fromBytes$f = function fromBytes(bytes) {
    validateCommandPayload(name$f, bytes, COMMAND_BODY_SIZE$b);
    return {};
  };
  var toBytes$f = function toBytes() {
    return toBytes$s(id$f);
  };

  var getCurrentMc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$f,
    fromBytes: fromBytes$f,
    headerSize: headerSize$f,
    id: id$f,
    name: name$f,
    toBytes: toBytes$f
  });

  var id$e = getExAbsArchiveDaysMc$1;
  var name$e = commandNames[getExAbsArchiveDaysMc$1];
  var headerSize$e = 3;
  var COMMAND_BODY_SIZE$a = 4;
  var examples$e = {
    '1 day absolute value for 1 channel from 2023.12.24 00:00:00 GMT': {
      id: id$e,
      name: name$e,
      headerSize: headerSize$e,
      parameters: {
        startTime2000: 756691200,
        days: 1,
        channelList: [1]
      },
      bytes: [0x1f, 0x0d, 0x04, 0x2f, 0x98, 0x01, 0x01]
    }
  };
  var fromBytes$e = function fromBytes(bytes) {
    validateCommandPayload(name$e, bytes, COMMAND_BODY_SIZE$a);
    var buffer = new BinaryBuffer(bytes, false);
    var date = getDate(buffer);
    var channelList = getChannels(buffer);
    var days = buffer.getUint8();
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return {
      startTime2000: getTime2000FromDate(date),
      days: days,
      channelList: channelList
    };
  };
  var toBytes$e = function toBytes(parameters) {
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$a, false);
    var startTime2000 = parameters.startTime2000,
      days = parameters.days,
      channelList = parameters.channelList;
    setDate(buffer, startTime2000);
    setChannels(buffer, channelList.map(function (index) {
      return {
        index: index
      };
    }));
    buffer.setUint8(days);
    return toBytes$s(id$e, buffer.data);
  };

  var getExAbsArchiveDaysMc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$e,
    fromBytes: fromBytes$e,
    headerSize: headerSize$e,
    id: id$e,
    name: name$e,
    toBytes: toBytes$e
  });

  var id$d = getExAbsArchiveHoursMc$1;
  var name$d = commandNames[getExAbsArchiveHoursMc$1];
  var headerSize$d = 3;
  var COMMAND_BODY_SIZE$9 = 4;
  var examples$d = {
    '1 hour absolute values for 1 channel from 2023.12.23 12:00:00 GMT': {
      id: id$d,
      name: name$d,
      headerSize: headerSize$d,
      parameters: {
        channelList: [1],
        hours: 1,
        startTime2000: 756648000
      },
      bytes: [0x1f, 0x0c, 0x04, 0x2f, 0x97, 0x0c, 0x01]
    }
  };
  var fromBytes$d = function fromBytes(bytes) {
    var buffer = new BinaryBuffer(bytes, false);
    var date = getDate(buffer);
    var _getHours = getHours(buffer),
      hour = _getHours.hour,
      hours = _getHours.hours;
    var channelList = getChannels(buffer);
    date.setUTCHours(hour);
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return {
      channelList: channelList,
      hours: hours,
      startTime2000: getTime2000FromDate(date)
    };
  };
  var toBytes$d = function toBytes(parameters) {
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$9, false);
    var startTime2000 = parameters.startTime2000,
      hours = parameters.hours,
      channelList = parameters.channelList;
    var date = getDateFromTime2000(startTime2000);
    var hour = date.getUTCHours();
    setDate(buffer, date);
    setHours(buffer, hour, hours);
    setChannels(buffer, channelList.map(function (index) {
      return {
        index: index
      };
    }));
    return toBytes$s(id$d, buffer.data);
  };

  var getExAbsArchiveHoursMc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$d,
    fromBytes: fromBytes$d,
    headerSize: headerSize$d,
    id: id$d,
    name: name$d,
    toBytes: toBytes$d
  });

  var id$c = getExAbsCurrentMc$1;
  var name$c = commandNames[getExAbsCurrentMc$1];
  var headerSize$c = 3;
  var COMMAND_BODY_SIZE$8 = 0;
  var examples$c = {
    'simple request': {
      id: id$c,
      name: name$c,
      headerSize: headerSize$c,
      parameters: {},
      bytes: [0x1f, 0x0f, 0x00]
    }
  };
  var fromBytes$c = function fromBytes(bytes) {
    validateCommandPayload(name$c, bytes, COMMAND_BODY_SIZE$8);
    return {};
  };
  var toBytes$c = function toBytes() {
    return toBytes$s(id$c);
  };

  var getExAbsCurrentMc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$c,
    fromBytes: fromBytes$c,
    headerSize: headerSize$c,
    id: id$c,
    name: name$c,
    toBytes: toBytes$c
  });

  var id$b = getLmicInfo$1;
  var name$b = commandNames[getLmicInfo$1];
  var headerSize$b = 3;
  var COMMAND_BODY_SIZE$7 = 0;
  var examples$b = {
    'simple request': {
      id: id$b,
      name: name$b,
      headerSize: headerSize$b,
      parameters: {},
      bytes: [0x1f, 0x02, 0x00]
    }
  };
  var fromBytes$b = function fromBytes(bytes) {
    validateCommandPayload(name$b, bytes, COMMAND_BODY_SIZE$7);
    return {};
  };
  var toBytes$b = function toBytes() {
    return toBytes$s(id$b);
  };

  var getLmicInfo = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$b,
    fromBytes: fromBytes$b,
    headerSize: headerSize$b,
    id: id$b,
    name: name$b,
    toBytes: toBytes$b
  });

  var id$a = getParameter$2;
  var name$a = commandNames[getParameter$2];
  var headerSize$a = 2;
  var examples$a = {
    'request absolute data (not multichannel device)': {
      id: id$a,
      name: name$a,
      headerSize: headerSize$a,
      parameters: {
        id: 23,
        name: 'ABSOLUTE_DATA',
        data: null
      },
      bytes: [0x04, 0x01, 0x17]
    },
    'request for state of absolute data (not multichannel device)': {
      id: id$a,
      name: name$a,
      headerSize: headerSize$a,
      parameters: {
        id: 24,
        name: 'ABSOLUTE_DATA_ENABLE',
        data: null
      },
      bytes: [0x04, 0x01, 0x18]
    },
    'request for state of absolute for multichannel device (1 channel)': {
      id: id$a,
      name: name$a,
      headerSize: headerSize$a,
      parameters: {
        id: 29,
        name: 'ABSOLUTE_DATA_MULTI_CHANNEL',
        data: {
          channel: 1
        }
      },
      bytes: [0x04, 0x02, 0x1d, 0x00]
    },
    'request for state of absolute data for multichannel device (1 channel)': {
      id: id$a,
      name: name$a,
      headerSize: headerSize$a,
      parameters: {
        id: 30,
        name: 'ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL',
        data: {
          channel: 1
        }
      },
      bytes: [0x04, 0x02, 0x1e, 0x00]
    },
    'request for configuration for specific reporting data type': {
      id: id$a,
      name: name$a,
      headerSize: headerSize$a,
      parameters: {
        id: 49,
        name: 'REPORTING_DATA_CONFIG',
        data: {
          dataType: 0
        }
      },
      bytes: [0x04, 0x02, 0x31, 0x00]
    },
    'request for configuration for specific event id': {
      id: id$a,
      name: name$a,
      headerSize: headerSize$a,
      parameters: {
        id: 50,
        name: 'EVENTS_CONFIG',
        data: {
          eventId: 1
        }
      },
      bytes: [0x04, 0x02, 0x32, 0x01]
    },
    'get channel settings. channel: 2': {
      id: id$a,
      name: name$a,
      headerSize: headerSize$a,
      parameters: {
        id: 56,
        name: 'CHANNEL_TYPE',
        data: {
          channel: 2
        }
      },
      bytes: [0x04, 0x02, 0x38, 0x01]
    }
  };
  var fromBytes$a = function fromBytes(bytes) {
    var buffer = new BinaryBuffer(bytes, false);
    return getRequestParameter(buffer);
  };
  var toBytes$a = function toBytes(parameters) {
    var buffer = new BinaryBuffer(getRequestParameterSize(parameters), false);
    setRequestParameter(buffer, parameters);
    return toBytes$s(id$a, buffer.data);
  };

  var getParameter = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$a,
    fromBytes: fromBytes$a,
    headerSize: headerSize$a,
    id: id$a,
    name: name$a,
    toBytes: toBytes$a
  });

  var id$9 = getSignalQuality$1;
  var name$9 = commandNames[getSignalQuality$1];
  var headerSize$9 = 3;
  var COMMAND_BODY_SIZE$6 = 0;
  var examples$9 = {
    'simple request': {
      id: id$9,
      name: name$9,
      headerSize: headerSize$9,
      parameters: {},
      bytes: [0x1f, 0x34, 0x00]
    }
  };
  var fromBytes$9 = function fromBytes(bytes) {
    validateCommandPayload(name$9, bytes, COMMAND_BODY_SIZE$6);
    return {};
  };
  var toBytes$9 = function toBytes() {
    return toBytes$s(id$9, []);
  };

  var getSignalQuality = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$9,
    fromBytes: fromBytes$9,
    headerSize: headerSize$9,
    id: id$9,
    name: name$9,
    toBytes: toBytes$9
  });

  var id$8 = getStatus$1;
  var name$8 = commandNames[getStatus$1];
  var headerSize$8 = 2;
  var COMMAND_BODY_SIZE$5 = 0;
  var examples$8 = {
    'simple request': {
      id: id$8,
      name: name$8,
      headerSize: headerSize$8,
      parameters: {},
      bytes: [0x14, 0x00]
    }
  };
  var fromBytes$8 = function fromBytes(bytes) {
    validateCommandPayload(name$8, bytes, COMMAND_BODY_SIZE$5);
    return {};
  };
  var toBytes$8 = function toBytes() {
    return toBytes$s(id$8);
  };

  var getStatus = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$8,
    fromBytes: fromBytes$8,
    headerSize: headerSize$8,
    id: id$8,
    name: name$8,
    toBytes: toBytes$8
  });

  var id$7 = getTime2000$1;
  var name$7 = commandNames[getTime2000$1];
  var headerSize$7 = 2;
  var COMMAND_BODY_SIZE$4 = 0;
  var examples$7 = {
    'simple request': {
      id: id$7,
      name: name$7,
      headerSize: headerSize$7,
      parameters: {},
      bytes: [0x09, 0x00]
    }
  };
  var fromBytes$7 = function fromBytes(bytes) {
    validateCommandPayload(name$7, bytes, COMMAND_BODY_SIZE$4);
    return {};
  };
  var toBytes$7 = function toBytes() {
    return toBytes$s(id$7, []);
  };

  var getTime2000 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$7,
    fromBytes: fromBytes$7,
    headerSize: headerSize$7,
    id: id$7,
    name: name$7,
    toBytes: toBytes$7
  });

  var id$6 = setParameter$2;
  var name$6 = commandNames[setParameter$2];
  var headerSize$6 = 2;
  var examples$6 = {
    '01_LoRa: set minimal reporting data interval to 1 hour': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: REPORTING_DATA_INTERVAL,
        name: deviceParameterNames[REPORTING_DATA_INTERVAL],
        data: {
          specialSchedulePeriod: 0,
          firstDaysSpecialSchedule: 0,
          lastDaysSpecialSchedule: 0,
          period: 3600
        }
      },
      bytes: [0x03, 0x05, 0x01, 0x00, 0x00, 0x00, 0x06]
    },
    '04_LoRa: set day checkout hour to 12:00': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: DAY_CHECKOUT_HOUR,
        name: deviceParameterNames[DAY_CHECKOUT_HOUR],
        data: {
          value: 12
        }
      },
      bytes: [0x03, 0x02, 0x04, 0x0c]
    },
    '05_LoRa: set reporting data type to "day"': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: REPORTING_DATA_TYPE,
        name: deviceParameterNames[REPORTING_DATA_TYPE],
        data: {
          type: 1
        }
      },
      bytes: [0x03, 0x02, 0x05, 0x01]
    },
    '08_LoRa: set "with confirmation" for delivery of priority data': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: PRIORITY_DATA_DELIVERY_TYPE,
        name: deviceParameterNames[PRIORITY_DATA_DELIVERY_TYPE],
        data: {
          value: 0
        }
      },
      bytes: [0x03, 0x02, 0x08, 0x00]
    },
    '09_LoRa: set activation method to "ABP"': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: ACTIVATION_METHOD,
        name: deviceParameterNames[ACTIVATION_METHOD],
        data: {
          type: 1
        }
      },
      bytes: [0x03, 0x02, 0x09, 0x01]
    },
    '10_LoRa: set battery depassivation info': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: BATTERY_DEPASSIVATION_INFO,
        name: deviceParameterNames[BATTERY_DEPASSIVATION_INFO],
        data: {
          loadTime: 100,
          internalResistance: 3222,
          lowVoltage: 233
        }
      },
      bytes: [0x03, 0x07, 0x0a, 0x00, 0x64, 0x0c, 0x96, 0x00, 0xe9]
    },
    '11_LoRa: set battery minimal load time to "100"': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: BATTERY_MINIMAL_LOAD_TIME,
        name: deviceParameterNames[BATTERY_MINIMAL_LOAD_TIME],
        data: {
          value: 100
        }
      },
      bytes: [0x03, 0x05, 0x0b, 0x00, 0x00, 0x00, 0x64]
    },
    '13_LoRa: enable 1-4 channels, and disable serial channel for device': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: CHANNELS_CONFIG,
        name: deviceParameterNames[CHANNELS_CONFIG],
        data: {
          value: 0
        }
      },
      bytes: [0x03, 0x02, 0x0d, 0x00]
    },
    '18_LoRa: set spread factor and frequency for RX2 window': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: RX2_CONFIG,
        name: deviceParameterNames[RX2_CONFIG],
        data: {
          spreadFactor: 5,
          spreadFactorName: 'SF7B125',
          frequency: 20000
        }
      },
      bytes: [0x03, 0x05, 0x12, 0x05, 0x00, 0x00, 0xc8]
    },
    '23_Common_Gas: set absolute data (not multichannel device': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: ABSOLUTE_DATA,
        name: deviceParameterNames[ABSOLUTE_DATA],
        data: {
          meterValue: 204,
          pulseCoefficient: 100,
          value: 2023
        }
      },
      bytes: [0x03, 0x0a, 0x17, 0x00, 0x00, 0x00, 0xcc, 0x83, 0x00, 0x00, 0x07, 0xe7]
    },
    '24_Common_Gas: enable absolute data (not multichannel device': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: ABSOLUTE_DATA_ENABLE,
        name: deviceParameterNames[ABSOLUTE_DATA_ENABLE],
        data: {
          state: 1
        }
      },
      bytes: [0x03, 0x02, 0x18, 0x01]
    },
    '25_LoRa: set device serial number': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: SERIAL_NUMBER,
        name: deviceParameterNames[SERIAL_NUMBER],
        data: {
          value: '1b 0a 3e dc 3e 22'
        }
      },
      bytes: [0x03, 0x07, 0x19, 0x1b, 0x0a, 0x3e, 0xdc, 0x3e, 0x22]
    },
    '26_LoRa: set device geolocation': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: GEOLOCATION,
        name: deviceParameterNames[GEOLOCATION],
        data: {
          latitude: 34.43,
          longitude: 43.43,
          altitude: 23
        }
      },
      bytes: [0x03, 0x0b, 0x1a, 0x42, 0x09, 0xb8, 0x52, 0x42, 0x2d, 0xb8, 0x52, 0x00, 0x17]
    },
    '28_LoRa: set interval to send EXTRA FRAME': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: EXTRA_FRAME_INTERVAL,
        name: deviceParameterNames[EXTRA_FRAME_INTERVAL],
        data: {
          value: 3600
        }
      },
      bytes: [0x03, 0x03, 0x1c, 0x0e, 0x10]
    },
    '29_Common_4PU: set absolute data for multichannel device (1 channel': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: ABSOLUTE_DATA_MULTI_CHANNEL,
        name: deviceParameterNames[ABSOLUTE_DATA_MULTI_CHANNEL],
        data: {
          channel: 1,
          meterValue: 402,
          pulseCoefficient: 1000,
          value: 2032
        }
      },
      bytes: [0x03, 0x0b, 0x1d, 0x00, 0x00, 0x00, 0x01, 0x92, 0x84, 0x00, 0x00, 0x07, 0xf0]
    },
    '30_Common_4PU: enable absolute data for multichannel device (2 channel': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL,
        name: deviceParameterNames[ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL],
        data: {
          channel: 2,
          state: 1
        }
      },
      bytes: [0x03, 0x03, 0x1e, 0x01, 0x01]
    },
    '31_LoRa_4PU: set pulse channels config': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: PULSE_CHANNELS_SCAN_CONFIG,
        name: deviceParameterNames[PULSE_CHANNELS_SCAN_CONFIG],
        data: {
          channelList: [1, 4],
          pullUpTime: 18,
          scanTime: 23
        }
      },
      bytes: [0x03, 0x04, 0x1f, 0x09, 0x12, 0x17]
    },
    '32_LoRa_4PU: enable channels: 1, 2, disable channels: 3, 4, for pulse device': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: PULSE_CHANNELS_SET_CONFIG,
        name: deviceParameterNames[PULSE_CHANNELS_SET_CONFIG],
        data: {
          channel1: true,
          channel2: true,
          channel3: false,
          channel4: false
        }
      },
      bytes: [0x03, 0x02, 0x20, 0x03]
    },
    '33_LoRa: set depassivation config for device': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: BATTERY_DEPASSIVATION_CONFIG,
        name: deviceParameterNames[BATTERY_DEPASSIVATION_CONFIG],
        data: {
          resistanceStartThreshold: 36000,
          resistanceStopThreshold: 26000
        }
      },
      bytes: [0x03, 0x05, 0x21, 0x8c, 0xa0, 0x65, 0x90]
    },
    '34_NB-IoT: set configuration for session': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: MQTT_SESSION_CONFIG,
        name: deviceParameterNames[MQTT_SESSION_CONFIG],
        data: {
          clientId: 'id',
          username: 'login',
          password: 'pass',
          cleanSession: 1
        }
      },
      bytes: [0x03, 0x10, 0x22, 0x02, 0x69, 0x64, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x04, 0x70, 0x61, 0x73, 0x73, 0x01]
    },
    '35_NB-IoT: set broker address': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: MQTT_BROKER_ADDRESS,
        name: deviceParameterNames[MQTT_BROKER_ADDRESS],
        data: {
          hostName: '127.0.0.1',
          port: 1883
        }
      },
      bytes: [0x03, 0x0d, 0x23, 0x09, 0x31, 0x32, 0x37, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x07, 0x5b]
    },
    '36_NB-IoT: disable ssl': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: MQTT_SSL_ENABLE,
        name: deviceParameterNames[MQTT_SSL_ENABLE],
        data: {
          enable: 0
        }
      },
      bytes: [0x03, 0x02, 0x24, 0x00]
    },
    '37_NB-IoT: set topic prefix': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: MQTT_TOPIC_PREFIX,
        name: deviceParameterNames[MQTT_TOPIC_PREFIX],
        data: {
          topicPrefix: 'mqtt'
        }
      },
      bytes: [0x03, 0x06, 0x25, 0x04, 0x6d, 0x71, 0x74, 0x74]
    },
    '38_NB-IoT: set configuration for data receive': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: MQTT_DATA_RECEIVE_CONFIG,
        name: deviceParameterNames[MQTT_DATA_RECEIVE_CONFIG],
        data: {
          qos: 1,
          count: 255,
          timeout: 20
        }
      },
      bytes: [0x03, 0x04, 0x26, 0x01, 0xff, 0x14]
    },
    '39_NB-IoT: set configuration for data send': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: MQTT_DATA_SEND_CONFIG,
        name: deviceParameterNames[MQTT_DATA_SEND_CONFIG],
        data: {
          qos: 1,
          retain: 0,
          newestSendFirst: 1
        }
      },
      bytes: [0x03, 0x04, 0x27, 0x01, 0x00, 0x01]
    },
    '40_NB-IoT: set configuration for ssl': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: NBIOT_SSL_CONFIG,
        name: deviceParameterNames[NBIOT_SSL_CONFIG],
        data: {
          securityLevel: 0,
          version: 3
        }
      },
      bytes: [0x03, 0x03, 0x28, 0x00, 0x03]
    },
    '47_NB-IoT: update software': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: NBIOT_DEVICE_SOFTWARE_UPDATE,
        name: deviceParameterNames[NBIOT_DEVICE_SOFTWARE_UPDATE],
        data: {
          softwareImageUrl: 'http://url.com/image.bin'
        }
      },
      bytes: [0x03, 0x1a, 0x2f, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x75, 0x72, 0x6c, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x62, 0x69, 0x6e]
    },
    '48_NB-IoT: update NB-IoT module firmware': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: NBIOT_MODULE_FIRMWARE_UPDATE,
        name: deviceParameterNames[NBIOT_MODULE_FIRMWARE_UPDATE],
        data: {
          moduleFirmwareImageUrl: 'http://url.com/nbiot.bin'
        }
      },
      bytes: [0x03, 0x1a, 0x30, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x75, 0x72, 0x6c, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6e, 0x62, 0x69, 0x6f, 0x74, 0x2e, 0x62, 0x69, 0x6e]
    },
    '49_NB-IoT: set configuration for reporting data': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: REPORTING_DATA_CONFIG,
        name: deviceParameterNames[REPORTING_DATA_CONFIG],
        data: {
          dataType: 0,
          hour: 4,
          minutes: 0,
          countToSend: 24
        }
      },
      bytes: [0x03, 0x05, 0x31, 0x00, 0x04, 0x00, 0x18]
    },
    '50_NB-IoT: set configuration for events': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: EVENTS_CONFIG,
        name: deviceParameterNames[EVENTS_CONFIG],
        data: {
          eventId: 3,
          sendEvent: 1,
          saveEvent: 1
        }
      },
      bytes: [0x03, 0x04, 0x32, 0x03, 0x01, 0x01]
    },
    '52_NB-IoT: set nbiot bands': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: NBIOT_BANDS,
        name: deviceParameterNames[NBIOT_BANDS],
        data: {
          bands: [3, 8, 20]
        }
      },
      bytes: [0x03, 0x05, 0x34, 0x03, 0x03, 0x08, 0x14]
    },
    '53_NB-IoT: set nbiot apn': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: NBIOT_APN,
        name: deviceParameterNames[NBIOT_APN],
        data: {
          apn: 'nbiot'
        }
      },
      bytes: [0x03, 0x07, 0x35, 0x05, 0x6e, 0x62, 0x69, 0x6f, 0x74]
    },
    '54_NB-IoT: set nbiot led indication': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: NBIOT_LED_INDICATION,
        name: deviceParameterNames[NBIOT_LED_INDICATION],
        data: {
          enableLed: 1,
          enableNbiotNetworkLed: 1
        }
      },
      bytes: [0x03, 0x03, 0x36, 0x01, 0x01]
    },
    '55_NB-IoT: set nbiot sim pin code': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: NBIOT_SIM,
        name: deviceParameterNames[NBIOT_SIM],
        data: {
          enable: 1,
          pin: 9999
        }
      },
      bytes: [0x03, 0x04, 0x37, 0x01, 0x27, 0x0f]
    },
    '56_4PU: set channel type. Channel index: 1, type: power channel': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: CHANNEL_TYPE,
        name: deviceParameterNames[CHANNEL_TYPE],
        data: {
          channel: 1,
          type: POWER_CHANNEL,
          parameters: {}
        }
      },
      bytes: [0x03, 0x03, 0x38, 0x00, 0x02]
    },
    '56_4PU: set channel type. Channel index: 2, type: binary sensor configurable': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: CHANNEL_TYPE,
        name: deviceParameterNames[CHANNEL_TYPE],
        data: {
          channel: 2,
          type: BINARY_SENSOR_CONFIGURABLE,
          parameters: {
            type: 0,
            activeStateTimeMs: 5000,
            halState: 0
          }
        }
      },
      bytes: [0x03, 0x07, 0x38, 0x01, 0x05, 0x00, 0x13, 0x88, 0x00]
    },
    '56_4PU: set channel type. Channel index: 3, type: temperature sensor': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: CHANNEL_TYPE,
        name: deviceParameterNames[CHANNEL_TYPE],
        data: {
          channel: 3,
          type: TEMPERATURE_SENSOR,
          parameters: {
            measurementPeriod: 3600,
            hysteresisSec: 2,
            highTemperatureThreshold: 40,
            lowTemperatureThreshold: 5
          }
        }
      },
      bytes: [0x03, 0x08, 0x38, 0x02, 0x04, 0x0e, 0x10, 0x02, 0x28, 0x05]
    },
    '56_4PU: set channel type. Channel index: 4, type: idle': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: CHANNEL_TYPE,
        name: deviceParameterNames[CHANNEL_TYPE],
        data: {
          channel: 4,
          type: IDLE,
          parameters: {}
        }
      },
      bytes: [0x03, 0x03, 0x38, 0x03, 0x00]
    },
    '57_NB-IoT: enable extra payload with signal quality on every uplink command': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: EXTRA_PAYLOAD_ENABLE,
        name: deviceParameterNames[EXTRA_PAYLOAD_ENABLE],
        data: {
          enable: 1
        }
      },
      bytes: [0x03, 0x02, 0x39, 0x01]
    },
    '58_Common: time synchronization period in seconds via MAC commands': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: TIME_SYNCHRONIZATION_PERIOD_VIA_MAC,
        name: deviceParameterNames[TIME_SYNCHRONIZATION_PERIOD_VIA_MAC],
        data: {
          period: 1440
        }
      },
      bytes: [0x03, 0x05, 0x3a, 0x00, 0x00, 0x05, 0xa0]
    },
    '59_LoRa: keep its lora connection even after being removed': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: KEEP_LORA_CONNECTION_ON_REMOVAL,
        name: deviceParameterNames[KEEP_LORA_CONNECTION_ON_REMOVAL],
        data: {
          value: true
        }
      },
      bytes: [0x03, 0x02, 0x3b, 0x01]
    },
    '60_NB-IoT: set nbiot ntp server': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: NBIOT_NTP_SERVER,
        name: deviceParameterNames[NBIOT_NTP_SERVER],
        data: {
          server: '162.159.200.1',
          port: 123
        }
      },
      bytes: [0x03, 0x11, 0x3c, 0x0d, 0x31, 0x36, 0x32, 0x2e, 0x31, 0x35, 0x39, 0x2e, 0x32, 0x30, 0x30, 0x2e, 0x31, 0x00, 0x7b]
    },
    '61_LoRa_4PU: activate module': {
      id: id$6,
      name: name$6,
      headerSize: headerSize$6,
      parameters: {
        id: ACTIVATE_MODULE,
        name: deviceParameterNames[ACTIVATE_MODULE],
        data: {
          enable: 1
        }
      },
      bytes: [0x03, 0x02, 0x3d, 0x01]
    }
  };
  var fromBytes$6 = function fromBytes(bytes) {
    var buffer = new BinaryBuffer(bytes, false);
    return getParameter$1(buffer);
  };
  var toBytes$6 = function toBytes(parameters) {
    var buffer = new BinaryBuffer(getParameterSize(parameters), false);
    setParameter$1(buffer, parameters);
    return toBytes$s(id$6, buffer.data);
  };

  var setParameter = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$6,
    fromBytes: fromBytes$6,
    headerSize: headerSize$6,
    id: id$6,
    name: name$6,
    toBytes: toBytes$6
  });

  var id$5 = setTime2000$1;
  var name$5 = commandNames[setTime2000$1];
  var headerSize$5 = 2;
  var COMMAND_BODY_SIZE$3 = 5;
  var examples$5 = {
    'set time to 2023.04.03 14:01:17 GMT': {
      id: id$5,
      headerSize: headerSize$5,
      parameters: {
        sequenceNumber: 78,
        seconds: 733845677
      },
      bytes: [0x02, 0x05, 0x4e, 0x2b, 0xbd, 0x98, 0xad]
    }
  };
  var fromBytes$5 = function fromBytes(bytes) {
    validateCommandPayload(name$5, bytes, COMMAND_BODY_SIZE$3);
    var buffer = new BinaryBuffer(bytes, false);
    var parameters = {
      sequenceNumber: buffer.getUint8(),
      seconds: buffer.getInt32()
    };
    if (!buffer.isEmpty) {
      throw new Error('BinaryBuffer is not empty.');
    }
    return parameters;
  };
  var toBytes$5 = function toBytes(parameters) {
    var sequenceNumber = parameters.sequenceNumber,
      seconds = parameters.seconds;
    var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$3, false);
    buffer.setUint8(sequenceNumber);
    buffer.setInt32(seconds);
    return toBytes$s(id$5, buffer.data);
  };

  var setTime2000 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$5,
    fromBytes: fromBytes$5,
    headerSize: headerSize$5,
    id: id$5,
    name: name$5,
    toBytes: toBytes$5
  });

  var id$4 = softRestart$1;
  var name$4 = commandNames[softRestart$1];
  var headerSize$4 = 2;
  var COMMAND_BODY_SIZE$2 = 0;
  var examples$4 = {
    'simple request': {
      id: id$4,
      name: name$4,
      headerSize: headerSize$4,
      parameters: {},
      bytes: [0x19, 0x00]
    }
  };
  var fromBytes$4 = function fromBytes(bytes) {
    validateCommandPayload(name$4, bytes, COMMAND_BODY_SIZE$2);
    return {};
  };
  var toBytes$4 = function toBytes() {
    return toBytes$s(id$4);
  };

  var softRestart = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$4,
    fromBytes: fromBytes$4,
    headerSize: headerSize$4,
    id: id$4,
    name: name$4,
    toBytes: toBytes$4
  });

  var id$3 = updateRun$1;
  var name$3 = commandNames[updateRun$1];
  var headerSize$3 = 3;
  var COMMAND_BODY_SIZE$1 = 0;
  var examples$3 = {
    'simple request': {
      id: id$3,
      name: name$3,
      headerSize: headerSize$3,
      parameters: {},
      bytes: [0x1f, 0x2c, 0x00]
    }
  };
  var fromBytes$3 = function fromBytes(bytes) {
    validateCommandPayload(name$3, bytes, COMMAND_BODY_SIZE$1);
    return {};
  };
  var toBytes$3 = function toBytes() {
    return toBytes$s(id$3);
  };

  var updateRun = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$3,
    fromBytes: fromBytes$3,
    headerSize: headerSize$3,
    id: id$3,
    name: name$3,
    toBytes: toBytes$3
  });

  var id$2 = usWaterMeterCommand$1;
  var name$2 = commandNames[usWaterMeterCommand$1];
  var headerSize$2 = 3;
  var examples$2 = {
    'request for current values': {
      id: id$2,
      headerSize: headerSize$2,
      parameters: {
        length: 3,
        data: [0x21, 0x02]
      },
      bytes: [0x1f, 0x07, 0x03, 0x03, 0x21, 0x02]
    }
  };
  var fromBytes$2 = function fromBytes(bytes) {
    var buffer = new BinaryBuffer(bytes, false);
    var length = buffer.getUint8();
    return {
      length: length,
      data: bytes.slice(1)
    };
  };
  var toBytes$2 = function toBytes(parameters) {
    var data = parameters.data,
      length = parameters.length;
    var buffer = new BinaryBuffer(length, false);
    buffer.setUint8(length);
    buffer.setBytes(data);
    return toBytes$s(id$2, buffer.data);
  };
  var toJson$1 = function toJson(parameters, options) {
    return JSON.stringify(_objectSpread2(_objectSpread2({}, parameters), {}, {
      data: getStringFromBytes(parameters.data, options)
    }));
  };

  var usWaterMeterCommand = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$2,
    fromBytes: fromBytes$2,
    headerSize: headerSize$2,
    id: id$2,
    name: name$2,
    toBytes: toBytes$2,
    toJson: toJson$1
  });

  var id$1 = verifyImage$1;
  var name$1 = commandNames[verifyImage$1];
  var headerSize$1 = 3;
  var COMMAND_BODY_SIZE = 0;
  var examples$1 = {
    'simple request': {
      id: id$1,
      name: name$1,
      headerSize: headerSize$1,
      parameters: {},
      bytes: [0x1f, 0x2b, 0x00]
    }
  };
  var fromBytes$1 = function fromBytes(bytes) {
    validateCommandPayload(name$1, bytes, COMMAND_BODY_SIZE);
    return {};
  };
  var toBytes$1 = function toBytes() {
    return toBytes$s(id$1);
  };

  var verifyImage = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples$1,
    fromBytes: fromBytes$1,
    headerSize: headerSize$1,
    id: id$1,
    name: name$1,
    toBytes: toBytes$1
  });

  var id = writeImage$1;
  var name = commandNames[writeImage$1];
  var headerSize = 3;
  var COMMAND_BODY_MIN_SIZE = 4;
  var examples = {
    'write image': {
      id: id,
      name: name,
      headerSize: headerSize,
      parameters: {
        offset: 64,
        data: [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
      },
      bytes: [0x1f, 0x2a, 0x14, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
    }
  };
  var fromBytes = function fromBytes(bytes) {
    if (bytes.length < COMMAND_BODY_MIN_SIZE) {
      throw new Error("Wrong buffer size: ".concat(bytes.length, "."));
    }
    var buffer = new BinaryBuffer(bytes, false);
    var offset = buffer.getUint32();
    return {
      offset: offset,
      data: bytes.slice(COMMAND_BODY_MIN_SIZE)
    };
  };
  var toBytes = function toBytes(parameters) {
    var buffer = new BinaryBuffer(COMMAND_BODY_MIN_SIZE, false);
    buffer.setUint32(parameters.offset);
    buffer.setBytes(parameters.data);
    return toBytes$s(id, buffer.data);
  };
  var toJson = function toJson(parameters, options) {
    return JSON.stringify(_objectSpread2(_objectSpread2({}, parameters), {}, {
      data: getStringFromBytes(parameters.data, options)
    }));
  };

  var writeImage = /*#__PURE__*/Object.freeze({
    __proto__: null,
    examples: examples,
    fromBytes: fromBytes,
    headerSize: headerSize,
    id: id,
    name: name,
    toBytes: toBytes,
    toJson: toJson
  });

  var commands = /*#__PURE__*/Object.freeze({
    __proto__: null,
    correctTime2000: correctTime2000,
    dataSegment: dataSegment,
    getArchiveDays: getArchiveDays,
    getArchiveDaysMc: getArchiveDaysMc,
    getArchiveEvents: getArchiveEvents,
    getArchiveHours: getArchiveHours,
    getArchiveHoursMc: getArchiveHoursMc,
    getArchiveHoursMcEx: getArchiveHoursMcEx,
    getBatteryStatus: getBatteryStatus,
    getChannelsStatus: getChannelsStatus,
    getChannelsTypes: getChannelsTypes,
    getCurrent: getCurrent,
    getCurrentMc: getCurrentMc,
    getExAbsArchiveDaysMc: getExAbsArchiveDaysMc,
    getExAbsArchiveHoursMc: getExAbsArchiveHoursMc,
    getExAbsCurrentMc: getExAbsCurrentMc,
    getLmicInfo: getLmicInfo,
    getParameter: getParameter,
    getSignalQuality: getSignalQuality,
    getStatus: getStatus,
    getTime2000: getTime2000,
    setParameter: setParameter,
    setTime2000: setTime2000,
    softRestart: softRestart,
    updateRun: updateRun,
    usWaterMeterCommand: usWaterMeterCommand,
    verifyImage: verifyImage,
    writeImage: writeImage
  });

  var equal = function equal(actual, expected) {
    if (actual !== expected) {
      return 'Assertion error!' + ' actual: ' + actual + ' expected: ' + expected;
    }
    return '';
  };
  var deepEqual = function deepEqual(actual, expected) {
    return equal(JSON.stringify(actual), JSON.stringify(expected));
  };
  var testCommands = function testCommands(commands) {
    var output = '';
    for (var commandName in commands) {
      var command = commands[commandName];
      var examples = command === null || command === void 0 ? void 0 : command.examples;
      if (command) {
        output += commandName + ' ';
        for (var exampleName in examples) {
          var exampleData = examples[exampleName];
          output += deepEqual(command.toBytes(exampleData.parameters, exampleData.config), exampleData.bytes);
          output += deepEqual(command.fromBytes(exampleData.bytes.slice(command.headerSize), exampleData.config), exampleData.parameters);
        }
      }
    }
    return output;
  };

  logs += testCommands(commands);

})();
//#endregion


var result = {
    contentType: 'BINARY',
    data: '',
    logs: logs
};

return result;
