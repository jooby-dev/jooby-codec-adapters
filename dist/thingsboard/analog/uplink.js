// these options can be edited
// available hardware types can be found here:
// https://github.com/jooby-dev/jooby-docs/blob/main/docs/analog/basics.md#hardware-types
var config = {
    hardwareType: 0
};


//#region [autogenerated jooby-codec bundle]
var fromBytes;

'use strict';

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var hexFormatOptions = {
  separator: ' ',
  prefix: ''
};

var INT8_SIZE = 1;
var INT16_SIZE = 2;
var INT32_SIZE = 4;
var log = Math.log,
  pow = Math.pow,
  LN2 = Math.LN2;
var readFloat = function (buffer, offset, isLittleEndian, mLen, bytes) {
  var e,
    m,
    eLen = bytes * 8 - mLen - 1,
    eMax = (1 << eLen) - 1,
    eBias = eMax >> 1,
    nBits = -7,
    i = isLittleEndian ? bytes - 1 : 0,
    d = isLittleEndian ? -1 : 1,
    s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 0x100 + buffer[offset + i], i += d, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 0x100 + buffer[offset + i], i += d, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * pow(2, e - mLen);
};
var writeFloat = function (buffer, offset, value, isLittleEndian, mLen, bytes) {
  var e,
    m,
    c,
    eLen = bytes * 8 - mLen - 1,
    eMax = (1 << eLen) - 1,
    eBias = eMax >> 1,
    rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0,
    i = isLittleEndian ? 0 : bytes - 1,
    d = isLittleEndian ? 1 : -1,
    s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value < 0 && (value = -value);
  if (value !== value || value === Infinity) {
    m = value !== value ? 1 : 0;
    e = eMax;
  } else {
    e = log(value) / LN2 | 0;
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 0x100, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 0x100, eLen -= 8);
  buffer[offset + i - d] |= s * 0x80;
};
var be2 = [1, 0];
var be4 = [3, 2, 1, 0];
var le2 = [0, 1];
var le4 = [0, 1, 2, 3];
var readUint8 = function (buffer, offset) {
  return buffer[offset];
};
var readUint16 = function (buffer, offset, isLittleEndian) {
  var order = isLittleEndian ? le2 : be2;
  var b0 = buffer[offset + order[0]];
  var b1 = buffer[offset + order[1]] << 8;
  return b0 | b1;
};
var readUint32 = function (buffer, offset, isLittleEndian) {
  var order = isLittleEndian ? le4 : be4;
  var b0 = buffer[offset + order[3]] * 0x1000000;
  var b1 = buffer[offset + order[2]] * 0x10000;
  var b2 = buffer[offset + order[1]] * 0x100;
  var b3 = buffer[offset + order[0]];
  return b0 + b1 + b2 + b3;
};
var writeUint8 = function (buffer, offset, value) {
  buffer[offset] = value & 0xff;
};
var writeUint16 = function (buffer, offset, value, isLittleEndian) {
  var order = isLittleEndian ? le2 : be2;
  buffer[offset + order[0]] = value & 0xff;
  buffer[offset + order[1]] = value >>> 8 & 0xff;
};
var writeUint32 = function (buffer, offset, value, isLittleEndian) {
  var order = isLittleEndian ? le4 : be4;
  buffer[offset + order[0]] = value & 0xff;
  buffer[offset + order[1]] = value >>> 8 & 0xff;
  buffer[offset + order[2]] = value >>> 16 & 0xff;
  buffer[offset + order[3]] = value >>> 24 & 0xff;
};
function BinaryBuffer(dataOrLength) {
  var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (typeof dataOrLength === 'number') {
    var bytes = new Array(dataOrLength).fill(0);
    this.data = bytes;
  } else {
    this.data = dataOrLength;
  }
  this.offset = 0;
  this.isLittleEndian = isLittleEndian;
}
BinaryBuffer.prototype = {
  toUint8Array: function () {
    return this.data;
  },
  seek: function (position) {
    if (position < 0 || position >= this.data.length) {
      throw new Error('Invalid position.');
    }
    this.offset = position;
  },
  setInt8: function (value) {
    writeUint8(this.data, this.offset, value < 0 ? value | 0x100 : value);
    this.offset += INT8_SIZE;
  },
  getInt8: function () {
    var result = readUint8(this.data, this.offset);
    this.offset += INT8_SIZE;
    return result & 0x80 ? result ^ -0x100 : result;
  },
  setUint8: function (value) {
    writeUint8(this.data, this.offset, value);
    this.offset += INT8_SIZE;
  },
  getUint8: function () {
    var result = readUint8(this.data, this.offset);
    this.offset += INT8_SIZE;
    return result;
  },
  setInt16: function (value) {
    var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
    writeUint16(this.data, this.offset, value < 0 ? value | 0x10000 : value, isLittleEndian);
    this.offset += INT16_SIZE;
  },
  getInt16: function () {
    var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
    var result = readUint16(this.data, this.offset, isLittleEndian);
    this.offset += INT16_SIZE;
    return result & 0x8000 ? result ^ -0x10000 : result;
  },
  setUint16: function (value) {
    var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
    writeUint16(this.data, this.offset, value, isLittleEndian);
    this.offset += INT16_SIZE;
  },
  getUint16: function () {
    var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
    var result = readUint16(this.data, this.offset, isLittleEndian);
    this.offset += INT16_SIZE;
    return result;
  },
  setInt32: function (value) {
    var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
    writeUint32(this.data, this.offset, value < 0 ? value | 0x100000000 : value, isLittleEndian);
    this.offset += INT32_SIZE;
  },
  getInt32: function () {
    var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
    var result = readUint32(this.data, this.offset, isLittleEndian);
    this.offset += INT32_SIZE;
    return result & 0x80000000 ? result ^ -0x100000000 : result;
  },
  setUint32: function (value) {
    var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
    writeUint32(this.data, this.offset, value, isLittleEndian);
    this.offset += INT32_SIZE;
  },
  getUint32: function () {
    var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
    var result = readUint32(this.data, this.offset, isLittleEndian);
    this.offset += INT32_SIZE;
    return result;
  },
  setFloat32: function (value) {
    var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
    writeFloat(this.data, this.offset, value, isLittleEndian, 23, 4);
    this.offset += INT32_SIZE;
  },
  getFloat32: function () {
    var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
    var result = readFloat(this.data, this.offset, isLittleEndian, 23, 4);
    this.offset += INT32_SIZE;
    return result;
  },
  setString: function (value) {
    this.setUint8(value.length);
    for (var index = 0; index < value.length; ++index) {
      this.setUint8(value.charCodeAt(index));
    }
  },
  getString: function () {
    var size = this.getUint8();
    var endIndex = this.offset + size;
    var chars = [];
    while (this.offset < endIndex) {
      chars.push(String.fromCharCode(this.getUint8()));
    }
    return chars.join('');
  },
  getBytesToOffset: function () {
    var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.offset;
    return this.data.slice(0, offset);
  },
  getBytesLeft: function () {
    return this.getBytes(this.bytesLeft);
  },
  getBytes: function (length) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;
    this.offset = offset + length;
    return this.data.slice(offset, this.offset);
  },
  setBytes: function (data) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;
    var bytes = this.data;
    bytes.splice.apply(bytes, [offset, data.length].concat(_toConsumableArray(data)));
    this.data = bytes;
    this.offset = offset + data.length;
  }
};
Object.defineProperties(BinaryBuffer.prototype, {
  size: {
    get: function () {
      return this.data.length;
    }
  },
  isEmpty: {
    get: function () {
      return this.data.length - this.offset === 0;
    }
  },
  bytesLeft: {
    get: function () {
      return this.data.length - this.offset;
    }
  },
  position: {
    get: function () {
      return this.offset;
    }
  }
});

var shortCommandMask = 0xe0;
var extraCommandMask = 0x1f;
var fromBytes$g = function (data) {
  if (data.length === 0) {
    throw new Error('Invalid buffer size');
  }
  var header = {
    shortCode: data[0] & shortCommandMask,
    extraCode: data[0] & extraCommandMask
  };
  if (header.shortCode !== 0) {
    return {
      headerSize: 1,
      commandId: data[0] & ~header.extraCode,
      commandSize: header.extraCode
    };
  }
  if (header.extraCode === extraCommandMask) {
    if (data.length < 3) {
      throw new Error('Invalid buffer size');
    }
    return {
      headerSize: 3,
      commandId: data[1] << 8 | extraCommandMask,
      commandSize: data[2]
    };
  }
  if (data.length < 2) {
    throw new Error('Invalid buffer size');
  }
  return {
    headerSize: 2,
    commandId: header.extraCode,
    commandSize: data[1]
  };
};

var id$d = 0x0c;
var name$d = 'correctTime2000';
var COMMAND_BODY_SIZE$3 = 1;
var fromBytes$f = function (data) {
  if (data.length !== COMMAND_BODY_SIZE$3) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new BinaryBuffer(data, false);
  var parameters = {
    status: buffer.getUint8()
  };
  if (!buffer.isEmpty) {
    throw new Error('BinaryBuffer is not empty.');
  }
  return parameters;
};

var fromObject = function () {
  var bitMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var booleanObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var result = 0;
  for (var name in booleanObject) {
    if (name in bitMask && booleanObject[name]) {
      result |= bitMask[name];
    }
  }
  return result;
};
var toObject = function () {
  var bitMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var result = {};
  for (var name in bitMask) {
    result[name] = (value & bitMask[name]) !== 0;
  }
  return result;
};

var INITIAL_YEAR_TIMESTAMP = 946684800000;
var MILLISECONDS_IN_SECONDS = 1000;
var getDateFromTime2000 = function (time2000) {
  return new Date(INITIAL_YEAR_TIMESTAMP + time2000 * MILLISECONDS_IN_SECONDS);
};
var getTime2000FromDate = function (date) {
  return (date.getTime() - INITIAL_YEAR_TIMESTAMP) / MILLISECONDS_IN_SECONDS;
};

var GASI1 = 1;
var GASI2 = 2;
var GASI3 = 3;
var NOVATOR = 4;
var IMP2EU = 5;
var IMP4EU = 6;
var MTXLORA = 7;
var IMP2AS = 8;
var IMP2IN = 9;
var IMP4IN = 10;
var ELIMP = 11;
var GASIC = 12;

var invertObject = (function (source) {
  var target = {};
  for (var property in source) {
    var value = source[property];
    target[value] = property;
  }
  return target;
});

var INITIAL_YEAR = 2000;
var MONTH_BIT_SIZE = 4;
var DATE_BIT_SIZE = 5;
var YEAR_START_INDEX = 1;
var UNKNOWN_BATTERY_VOLTAGE = 4095;
var EXTEND_BIT_MASK = 0x80;
var LAST_BIT_INDEX = 7;
var GAS_HARDWARE_TYPES = [GASI2, GASI3, GASI1, GASIC];
var TWO_CHANNELS_HARDWARE_TYPES = [IMP2AS, IMP2EU, IMP2IN, NOVATOR];
var ELIMP_HARDWARE_TYPES = [ELIMP];
var FOUR_CHANNELS_HARDWARE_TYPES = [IMP4EU, IMP4IN];
var MTX_HARDWARE_TYPES = [MTXLORA];
var gasBitMask = {
  isBatteryLow: Math.pow(2, 0),
  isMagneticInfluence: Math.pow(2, 1),
  isButtonReleased: Math.pow(2, 2),
  isConnectionLost: Math.pow(2, 3)
};
var twoChannelBitMask = {
  isBatteryLow: Math.pow(2, 0),
  isConnectionLost: Math.pow(2, 3),
  isFirstChannelInactive: Math.pow(2, 4),
  isSecondChannelInactive: Math.pow(2, 5)
};
var elimpBitMask = {
  isConnectionLost: Math.pow(2, 3)
};
var fourChannelBitMask = {
  isBatteryLow: Math.pow(2, 0),
  isConnectionLost: Math.pow(2, 3),
  isFirstChannelInactive: Math.pow(2, 4),
  isSecondChannelInactive: Math.pow(2, 5),
  isThirdChannelInactive: Math.pow(2, 6),
  isForthChannelInactive: Math.pow(2, 7)
};
var mtxBitMask = {
  isMeterCaseOpen: Math.pow(2, 0),
  isMagneticInfluence: Math.pow(2, 1),
  isParametersSetRemotely: Math.pow(2, 2),
  isParametersSetLocally: Math.pow(2, 3),
  isMeterProgramRestarted: Math.pow(2, 4),
  isLockedOut: Math.pow(2, 5),
  isTimeSet: Math.pow(2, 6),
  isTimeCorrected: Math.pow(2, 7),
  isMeterFailure: Math.pow(2, 8),
  isMeterTerminalBoxOpen: Math.pow(2, 9),
  isModuleCompartmentOpen: Math.pow(2, 10),
  isTariffPlanChanged: Math.pow(2, 11),
  isNewTariffPlanReceived: Math.pow(2, 12)
};
var byteToPulseCoefficientMap = {
  128: 1,
  129: 5,
  130: 10,
  131: 100,
  132: 1000,
  133: 10000,
  134: 100000
};
var pulseCoefficientToByteMap = invertObject(byteToPulseCoefficientMap);
var isMSBSet = function (value) {
  return !!(value & 0x80);
};
function CommandBinaryBuffer(dataOrLength) {
  var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  BinaryBuffer.call(this, dataOrLength, isLittleEndian);
}
CommandBinaryBuffer.prototype = Object.create(BinaryBuffer.prototype);
CommandBinaryBuffer.prototype.constructor = CommandBinaryBuffer;
CommandBinaryBuffer.prototype.getExtendedValue = function () {
  var value = 0;
  var isByteExtended = true;
  var position = 0;
  while (isByteExtended && this.offset <= this.data.length) {
    var byte = this.getUint8();
    isByteExtended = !!(byte & EXTEND_BIT_MASK);
    value += (byte & 0x7f) << 7 * position;
    ++position;
  }
  if (value < 0) {
    value = 0;
  }
  return value;
};
CommandBinaryBuffer.prototype.setExtendedValue = function (value) {
  var _this = this;
  if (value === 0) {
    this.setUint8(0);
    return;
  }
  var data = [];
  var encodedValue = value;
  while (encodedValue) {
    data.push(EXTEND_BIT_MASK | encodedValue & 0x7f);
    encodedValue >>= 7;
  }
  var lastByte = data.pop();
  if (lastByte) {
    data.push(lastByte & 0x7f);
  }
  data.forEach(function (extendedValue) {
    return _this.setUint8(extendedValue);
  });
};
CommandBinaryBuffer.prototype.getExtendedValueSize = function (bits) {
  var extBits = Math.ceil(bits / 7);
  var totalBits = bits + extBits;
  var extBytes = Math.ceil(totalBits / 8);
  return extBytes;
};
CommandBinaryBuffer.prototype.getTime = function () {
  return this.getUint32(false);
};
CommandBinaryBuffer.prototype.setTime = function (value) {
  this.setUint32(value, false);
};
CommandBinaryBuffer.prototype.getBatteryVoltage = function () {
  var lowVoltageByte = this.getUint8();
  var lowAndHightVoltageByte = this.getUint8();
  var highVoltageByte = this.getUint8();
  var underLowLoad = lowVoltageByte << 4;
  underLowLoad |= (lowAndHightVoltageByte & 0xf0) >> 4;
  var underHighLoad = (lowAndHightVoltageByte & 0x0f) << 8 | highVoltageByte;
  if (underHighLoad === UNKNOWN_BATTERY_VOLTAGE) {
    underHighLoad = undefined;
  }
  if (underLowLoad === UNKNOWN_BATTERY_VOLTAGE) {
    underLowLoad = undefined;
  }
  return {
    underLowLoad: underLowLoad,
    underHighLoad: underHighLoad
  };
};
CommandBinaryBuffer.prototype.setBatteryVoltage = function (batteryVoltage) {
  var _this2 = this;
  var underLowLoad = batteryVoltage.underLowLoad,
    underHighLoad = batteryVoltage.underHighLoad;
  if (underLowLoad === undefined) {
    underLowLoad = UNKNOWN_BATTERY_VOLTAGE;
  }
  if (underHighLoad === undefined) {
    underHighLoad = UNKNOWN_BATTERY_VOLTAGE;
  }
  var lowVoltageByte = underLowLoad >> 4 & 0xff;
  var lowAndHighVoltageByte = (underLowLoad & 0x0f) << 4 | underHighLoad >> 8 & 0x0f;
  var highVoltageByte = underHighLoad & 0xff;
  [lowVoltageByte, lowAndHighVoltageByte, highVoltageByte].forEach(function (byte) {
    return _this2.setUint8(byte);
  });
};
CommandBinaryBuffer.prototype.getChannels = function () {
  var channelList = [];
  var extended = true;
  var channelIndex = 1;
  while (extended) {
    var byte = this.getUint8();
    var bits = byte.toString(2).padStart(LAST_BIT_INDEX + 1, '0').split('').reverse();
    bits.forEach(function (bit, index) {
      var value = Number(bit);
      if (index === LAST_BIT_INDEX) {
        extended = !!value;
      } else {
        if (value) {
          channelList.push(channelIndex);
        }
        ++channelIndex;
      }
    });
  }
  return channelList;
};
CommandBinaryBuffer.prototype.setChannels = function (channelList) {
  var _this3 = this;
  if (channelList.length === 0) {
    this.setUint8(0);
    return;
  }
  channelList.sort(function (a, b) {
    return a.index - b.index;
  });
  var maxChannel = Math.max.apply(Math, _toConsumableArray(channelList.map(function (_ref) {
    var index = _ref.index;
    return index;
  })));
  var size = (maxChannel - maxChannel % 8) / 8;
  var data = new Array(size + 1).fill(0);
  var byte = 0;
  data.forEach(function (_, byteIndex) {
    var channelIndex = byteIndex * LAST_BIT_INDEX + 1;
    var maxChannelIndex = channelIndex + LAST_BIT_INDEX;
    while (channelIndex < maxChannelIndex) {
      var channel = channelList.find(function (item) {
        return item.index === channelIndex;
      });
      if (channel !== undefined) {
        byte |= 1 << (channel.index - 1) % LAST_BIT_INDEX;
      }
      ++channelIndex;
    }
    if (data[byteIndex + 1] !== undefined) {
      byte |= 1 << LAST_BIT_INDEX;
    }
    data[byteIndex] = byte;
    byte = 0;
  });
  data.forEach(function (value) {
    return _this3.setUint8(value);
  });
};
CommandBinaryBuffer.prototype.getChannelsValuesWithHourDiff = function () {
  var _this4 = this;
  var date = this.getDate();
  var _this$getHours = this.getHours(),
    hour = _this$getHours.hour,
    hours = _this$getHours.hours;
  var channels = this.getChannels();
  var channelList = [];
  date.setUTCHours(hour);
  channels.forEach(function (channelIndex) {
    var diff = [];
    var value = _this4.getExtendedValue();
    for (var diffHour = 1; diffHour < hours; ++diffHour) {
      diff.push(_this4.getExtendedValue());
    }
    channelList.push({
      value: value,
      diff: diff,
      index: channelIndex
    });
  });
  return {
    startTime2000: getTime2000FromDate(date),
    hours: hours,
    channelList: channelList
  };
};
CommandBinaryBuffer.prototype.setChannelsValuesWithHourDiff = function (hours, startTime2000, channelList) {
  var _this5 = this;
  var date = getDateFromTime2000(startTime2000);
  var hour = date.getUTCHours();
  this.setDate(date);
  this.setHours(hour, hours);
  this.setChannels(channelList);
  channelList.forEach(function (_ref2) {
    var value = _ref2.value,
      diff = _ref2.diff;
    _this5.setExtendedValue(value);
    diff.forEach(function (diffValue) {
      return _this5.setExtendedValue(diffValue);
    });
  });
};
CommandBinaryBuffer.prototype.getHours = function () {
  var byte = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getUint8();
  if (byte === 0) {
    return {
      hours: 0,
      hour: 0
    };
  }
  var hours = ((byte & 0xe0) >> 5) + 1;
  var hour = byte & 0x1f;
  return {
    hours: hours,
    hour: hour
  };
};
CommandBinaryBuffer.prototype.setHours = function (hour, hours) {
  if (hour === 0 && hours === 0) {
    this.setUint8(0);
    return;
  }
  this.setUint8((hours - 1 & 0x07) << 5 | hour & 0x1f);
};
CommandBinaryBuffer.prototype.getDate = function () {
  var yearMonthByte = this.getUint8();
  var monthDateByte = this.getUint8();
  var year = yearMonthByte >> YEAR_START_INDEX;
  var month = (yearMonthByte & 0x01) << MONTH_BIT_SIZE - YEAR_START_INDEX | monthDateByte >> DATE_BIT_SIZE;
  var monthDay = monthDateByte & 0x1f;
  return new Date(Date.UTC(year + INITIAL_YEAR, month - 1, monthDay, 0, 0, 0, 0));
};
CommandBinaryBuffer.prototype.setDate = function (dateOrTime) {
  var _this6 = this;
  var date;
  if (dateOrTime instanceof Date) {
    date = dateOrTime;
  } else {
    date = getDateFromTime2000(dateOrTime);
  }
  var year = date.getUTCFullYear() - INITIAL_YEAR;
  var month = date.getUTCMonth() + 1;
  var day = date.getUTCDate();
  var yearMonthByte = year << YEAR_START_INDEX | month >> MONTH_BIT_SIZE - YEAR_START_INDEX;
  var monthDateByte = (month & 0x07) << DATE_BIT_SIZE | day;
  [yearMonthByte, monthDateByte].forEach(function (byte) {
    return _this6.setUint8(byte);
  });
};
CommandBinaryBuffer.prototype.getPulseCoefficient = function () {
  var pulseCoefficient = this.getUint8();
  if (isMSBSet(pulseCoefficient)) {
    var value = byteToPulseCoefficientMap[pulseCoefficient];
    if (value) {
      return value;
    }
    throw new Error('pulseCoefficient MSB is set, but value unknown');
  }
  return pulseCoefficient;
};
CommandBinaryBuffer.prototype.setPulseCoefficient = function (value) {
  if (value in pulseCoefficientToByteMap) {
    var byte = pulseCoefficientToByteMap[value];
    if (byte) {
      this.setUint8(byte);
    } else {
      throw new Error('pulseCoefficient MSB is set, but value unknown');
    }
  } else {
    this.setUint8(value);
  }
};
CommandBinaryBuffer.prototype.getChannelsWithAbsoluteValues = function () {
  var _this7 = this;
  var channels = this.getChannels();
  var channelList = [];
  channels.forEach(function (channelIndex) {
    channelList.push({
      pulseCoefficient: _this7.getPulseCoefficient(),
      value: _this7.getExtendedValue(),
      index: channelIndex
    });
  });
  return channelList;
};
CommandBinaryBuffer.prototype.setChannelsWithAbsoluteValues = function (channelList) {
  var _this8 = this;
  this.setChannels(channelList);
  channelList.forEach(function (_ref3) {
    var value = _ref3.value,
      pulseCoefficient = _ref3.pulseCoefficient;
    _this8.setPulseCoefficient(pulseCoefficient);
    _this8.setExtendedValue(value);
  });
};
CommandBinaryBuffer.prototype.getChannelsAbsoluteValuesWithHourDiff = function (hours) {
  var _this9 = this;
  var channels = this.getChannels();
  var channelList = [];
  channels.forEach(function (channelIndex) {
    var pulseCoefficient = _this9.getPulseCoefficient();
    var value = _this9.getExtendedValue();
    var diff = [];
    for (var hourIndex = 1; hourIndex < hours; ++hourIndex) {
      diff.push(_this9.getExtendedValue());
    }
    channelList.push({
      diff: diff,
      value: value,
      pulseCoefficient: pulseCoefficient,
      index: channelIndex
    });
  });
  return channelList;
};
CommandBinaryBuffer.prototype.setChannelsAbsoluteValuesWithHourDiff = function (channelList) {
  var _this10 = this;
  this.setChannels(channelList);
  channelList.forEach(function (_ref4) {
    var value = _ref4.value,
      diff = _ref4.diff,
      pulseCoefficient = _ref4.pulseCoefficient;
    _this10.setPulseCoefficient(pulseCoefficient);
    _this10.setExtendedValue(value);
    diff.forEach(function (diffValue) {
      return _this10.setExtendedValue(diffValue);
    });
  });
};
CommandBinaryBuffer.prototype.getEventStatus = function (hardwareType) {
  var status;
  if (GAS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    status = toObject(gasBitMask, this.getUint8());
  } else if (TWO_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    status = toObject(twoChannelBitMask, this.getUint8());
  } else if (ELIMP_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    status = toObject(elimpBitMask, this.getUint8());
  } else if (FOUR_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    status = toObject(fourChannelBitMask, this.getExtendedValue());
  } else if (MTX_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    status = toObject(mtxBitMask, this.getUint16());
  } else {
    throw new Error('wrong hardwareType');
  }
  return status;
};
CommandBinaryBuffer.prototype.setEventStatus = function (hardwareType, status) {
  if (GAS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    this.setUint8(fromObject(gasBitMask, status));
  } else if (TWO_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    this.setUint8(fromObject(twoChannelBitMask, status));
  } else if (ELIMP_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    this.setUint8(fromObject(elimpBitMask, status));
  } else if (FOUR_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    this.setExtendedValue(fromObject(fourChannelBitMask, status));
  } else if (MTX_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
    this.setUint16(fromObject(mtxBitMask, status));
  } else {
    throw new Error('wrong hardwareType');
  }
};

var id$c = 0x18;
var name$c = 'currentMC';
var COMMAND_BODY_MAX_SIZE$6 = 37;
var fromBytes$e = function (data) {
  if (data.length > COMMAND_BODY_MAX_SIZE$6) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var parameters = {
    channelList: []
  };
  var buffer = new CommandBinaryBuffer(data);
  var channelList = buffer.getChannels();
  parameters.channelList = channelList.map(function (channelIndex) {
    return {
      value: buffer.getExtendedValue(),
      index: channelIndex
    };
  });
  return parameters;
};

var id$b = 0x16;
var name$b = 'dayMC';
var COMMAND_BODY_MAX_SIZE$5 = 32;
var fromBytes$d = function (data) {
  if (data.length > COMMAND_BODY_MAX_SIZE$5) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new CommandBinaryBuffer(data);
  var date = buffer.getDate();
  var channels = buffer.getChannels();
  var channelList = channels.map(function (channelIndex) {
    return {
      value: buffer.getExtendedValue(),
      index: channelIndex
    };
  });
  return {
    startTime2000: getTime2000FromDate(date),
    channelList: channelList
  };
};

var id$a = 0x0b1f;
var name$a = 'exAbsDayMC';
var COMMAND_BODY_MAX_SIZE$4 = 89;
var fromBytes$c = function (data) {
  if (data.length > COMMAND_BODY_MAX_SIZE$4) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new CommandBinaryBuffer(data);
  var date = buffer.getDate();
  var channelList = buffer.getChannelsWithAbsoluteValues();
  return {
    startTime2000: getTime2000FromDate(date),
    channelList: channelList
  };
};

var id$9 = 0x0a1f;
var name$9 = 'exAbsHourMC';
var COMMAND_BODY_MAX_SIZE$3 = 168;
var fromBytes$b = function (data) {
  if (data.length > COMMAND_BODY_MAX_SIZE$3) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new CommandBinaryBuffer(data);
  var date = buffer.getDate();
  var _buffer$getHours = buffer.getHours(),
    hour = _buffer$getHours.hour,
    hours = _buffer$getHours.hours;
  var channelList = buffer.getChannelsAbsoluteValuesWithHourDiff(hours);
  date.setUTCHours(hour);
  return {
    startTime2000: getTime2000FromDate(date),
    hours: hours,
    channelList: channelList
  };
};

var id$8 = 0x1b;
var name$8 = 'getArchiveDaysMCResponse';
var fromBytes$a = function (data) {
  var buffer = new CommandBinaryBuffer(data);
  var date = buffer.getDate();
  var channels = buffer.getChannels();
  var days = buffer.getUint8();
  var channelList = [];
  channels.forEach(function (channelIndex) {
    var dayList = [];
    channelList.push({
      dayList: dayList,
      index: channelIndex
    });
    for (var day = 0; day < days; ++day) {
      dayList.push(buffer.getExtendedValue());
    }
  });
  return {
    startTime2000: getTime2000FromDate(date),
    days: days,
    channelList: channelList
  };
};

var id$7 = 0x0b;
var name$7 = 'getArchiveEvents';
var getEvent = function (buffer) {
  return {
    time2000: buffer.getTime(),
    id: buffer.getUint8(),
    sequenceNumber: buffer.getUint8()
  };
};
var fromBytes$9 = function (data) {
  var buffer = new CommandBinaryBuffer(data, false);
  var eventList = [];
  while (buffer.bytesLeft > 0) {
    eventList.push(getEvent(buffer));
  }
  return {
    eventList: eventList
  };
};

var id$6 = 0x1a;
var name$6 = 'getArchiveHoursMCResponse';
var COMMAND_BODY_MAX_SIZE$2 = 164;
var fromBytes$8 = function (data) {
  if (data.length > COMMAND_BODY_MAX_SIZE$2) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new CommandBinaryBuffer(data);
  return buffer.getChannelsValuesWithHourDiff();
};

var id$5 = 0x021f;
var name$5 = 'getLmicInfo';
var COMMAND_BODY_SIZE$2 = 2;
var lmicCapabilitiesBitMask = {
  isMulticastSupported: 1 << 0,
  isFragmentedDataSupported: 1 << 1
};
var fromBytes$7 = function (data) {
  if (data.length !== COMMAND_BODY_SIZE$2) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new BinaryBuffer(data);
  var capabilities = toObject(lmicCapabilitiesBitMask, buffer.getUint8());
  var version = buffer.getUint8();
  if (!buffer.isEmpty) {
    throw new Error('BinaryBuffer is not empty.');
  }
  return {
    capabilities: capabilities,
    version: version
  };
};

var id$4 = 0x17;
var name$4 = 'hourMC';
var COMMAND_BODY_MAX_SIZE$1 = 164;
var fromBytes$6 = function (data) {
  if (data.length > COMMAND_BODY_MAX_SIZE$1) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new CommandBinaryBuffer(data);
  return buffer.getChannelsValuesWithHourDiff();
};

var MAGNET_ON = 1;
var MAGNET_OFF = 2;
var ACTIVATE = 3;
var DEACTIVATE = 4;
var BATTERY_ALARM = 5;
var CAN_OFF = 6;
var INSERT = 7;
var REMOVE = 8;
var COUNTER_OVER = 9;
var ACTIVATE_MTX = 11;
var CONNECT = 12;
var DISCONNECT = 13;
var OPTOLOW = 15;
var OPTOFLASH = 16;
var MTX = 17;
var JOIN_ACCEPT = 18;

var getHexFromBytes = (function (bytes) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _Object$assign = Object.assign({}, hexFormatOptions, options),
    separator = _Object$assign.separator,
    prefix = _Object$assign.prefix;
  return bytes.map(function (byte) {
    return "".concat(prefix).concat(byte.toString(16).padStart(2, '0'));
  }).join(separator);
});

var id$3 = 0x15;
var name$3 = 'newEvent';
var COMMAND_BODY_MAX_SIZE = 14;
var MTX_ADDRESS_SIZE = 8;
var getVoltage = function (buffer) {
  return buffer.getUint16(false);
};
var getDeviceId = function (buffer) {
  return getHexFromBytes(buffer.getBytes(MTX_ADDRESS_SIZE));
};
var fromBytes$5 = function (data) {
  if (data.length > COMMAND_BODY_MAX_SIZE) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new CommandBinaryBuffer(data);
  var eventId = buffer.getUint8();
  var sequenceNumber = buffer.getUint8();
  var eventData;
  switch (eventId) {
    case MAGNET_ON:
    case MAGNET_OFF:
    case ACTIVATE:
    case DEACTIVATE:
    case CAN_OFF:
    case INSERT:
    case REMOVE:
    case COUNTER_OVER:
    case OPTOLOW:
    case OPTOFLASH:
    case JOIN_ACCEPT:
      eventData = {
        time2000: buffer.getTime()
      };
      break;
    case BATTERY_ALARM:
      eventData = {
        voltage: getVoltage(buffer)
      };
      break;
    case ACTIVATE_MTX:
      eventData = {
        time2000: buffer.getTime(),
        deviceId: getDeviceId(buffer)
      };
      break;
    case CONNECT:
    case DISCONNECT:
      eventData = {
        channel: buffer.getUint8() + 1,
        value: buffer.getExtendedValue()
      };
      break;
    case MTX:
      eventData = {
        status: buffer.getEventStatus(MTXLORA)
      };
      break;
    default:
      throw new Error("Event ".concat(id$3, " is not supported"));
  }
  return {
    id: eventId,
    sequenceNumber: sequenceNumber,
    data: eventData
  };
};

var id$2 = 0x02;
var name$2 = 'setTime2000';
var COMMAND_BODY_SIZE$1 = 1;
var fromBytes$4 = function (data) {
  if (data.length !== COMMAND_BODY_SIZE$1) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new BinaryBuffer(data, false);
  var parameters = {
    status: buffer.getUint8()
  };
  if (!buffer.isEmpty) {
    throw new Error('BinaryBuffer is not empty.');
  }
  return parameters;
};

var roundNumber = (function (value) {
  var decimalPlaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
  var places = Math.pow(10, decimalPlaces);
  return Math.round(value * places * (1 + Number.EPSILON)) / places;
});

var id$1 = 0x14;
var name$1 = 'status';
var UNKNOWN_BATTERY_RESISTANCE = 65535;
var UNKNOWN_BATTERY_CAPACITY = 255;
var fromBytes$3 = function (bytes) {
  var buffer = new CommandBinaryBuffer(bytes);
  var software = {
    type: buffer.getUint8(),
    version: buffer.getUint8()
  };
  var hardware = {
    type: buffer.getUint8(),
    version: buffer.getUint8()
  };
  var data;
  switch (hardware.type) {
    case GASI1:
    case GASI2:
    case GASI3:
    case NOVATOR:
    case IMP2EU:
    case IMP4EU:
    case IMP2AS:
    case IMP2IN:
    case IMP4IN:
    case GASIC:
      {
        var statusData = {
          batteryVoltage: buffer.getBatteryVoltage(),
          batteryInternalResistance: buffer.getUint16(false),
          temperature: buffer.getUint8(),
          remainingBatteryCapacity: buffer.getUint8(),
          lastEventSequenceNumber: buffer.getUint8()
        };
        if (statusData.batteryInternalResistance === UNKNOWN_BATTERY_RESISTANCE) {
          statusData.batteryInternalResistance = undefined;
        }
        if (statusData.remainingBatteryCapacity === UNKNOWN_BATTERY_CAPACITY) {
          statusData.remainingBatteryCapacity = undefined;
        } else if (statusData.remainingBatteryCapacity !== undefined) {
          statusData.remainingBatteryCapacity = roundNumber(statusData.remainingBatteryCapacity * 100 / (UNKNOWN_BATTERY_CAPACITY - 1), 0);
        }
        data = statusData;
      }
      break;
    case MTXLORA:
      data = {
        time2000: buffer.getUint32(),
        resetReason: buffer.getUint8(),
        rssiLastDownlinkFrame: buffer.getUint8(),
        snrLastDownlinkFrame: buffer.getUint8(),
        downlinkRequestsNumber: buffer.getUint8(),
        downlinkFragmentsNumber: buffer.getUint8(),
        uplinkResponsesNumber: buffer.getUint8(),
        uplinkFragmentsNumber: buffer.getUint8(),
        signalMarginToGateway: buffer.getUint8(),
        signalMarginFromGateway: buffer.getUint8(),
        detectedGatewaysNumber: buffer.getUint8(),
        gatewayDownlinkErrorRate: buffer.getUint8(),
        lastEventSequenceNumber: buffer.getUint8()
      };
      break;
    case ELIMP:
    default:
      throw new Error("".concat(id$1, ": hardware type ").concat(hardware.type, " is not supported"));
  }
  return {
    software: software,
    hardware: hardware,
    data: data
  };
};

var id = 0x09;
var name = 'time2000';
var COMMAND_BODY_SIZE = 5;
var fromBytes$2 = function (data) {
  if (data.length !== COMMAND_BODY_SIZE) {
    throw new Error("Wrong buffer size: ".concat(data.length, "."));
  }
  var buffer = new CommandBinaryBuffer(data);
  var parameters = {
    sequenceNumber: buffer.getUint8(),
    time2000: buffer.getTime()
  };
  if (!buffer.isEmpty) {
    throw new Error('BinaryBuffer is not empty.');
  }
  return parameters;
};

var calculateLrc = (function (data) {
  var initialLrc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0x55;
  var lrc = initialLrc;
  data.forEach(function (item) {
    lrc ^= item;
  });
  return lrc;
});

var HEADER_MAX_SIZE = 3;
var getFromBytes = function (fromBytesMap, nameMap) {
  return function () {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var config = arguments.length > 1 ? arguments[1] : undefined;
    var commands = [];
    var message = {
      commands: commands,
      bytes: data,
      lrc: {
        expected: undefined,
        actual: 0
      }
    };
    var processedBytes = 0;
    var expectedLrc;
    var actualLrc;
    do {
      var headerInfo = fromBytes$g(data.slice(processedBytes, processedBytes + HEADER_MAX_SIZE));
      var headerData = data.slice(processedBytes, processedBytes + headerInfo.headerSize);
      var bodyData = data.slice(processedBytes + headerInfo.headerSize, processedBytes + headerInfo.headerSize + headerInfo.commandSize);
      var command = {
        id: headerInfo.commandId,
        name: nameMap[headerInfo.commandId],
        headerSize: headerInfo.headerSize,
        bytes: [].concat(_toConsumableArray(headerData), _toConsumableArray(bodyData))
      };
      processedBytes = processedBytes + headerInfo.headerSize + headerInfo.commandSize;
      if (config) {
        command.config = config;
      }
      try {
        command.parameters = fromBytesMap[headerInfo.commandId](bodyData, config);
        commands.push(command);
      } catch (error) {
        commands.push({
          command: command,
          error: error.message
        });
      }
    } while (processedBytes < data.length - 1);
    if (data.length - processedBytes === 1) {
      expectedLrc = data[data.length - 1];
      actualLrc = calculateLrc(data.slice(0, -1));
    } else {
      actualLrc = calculateLrc(data);
    }
    message.lrc.actual = actualLrc;
    message.lrc.expected = expectedLrc;
    if (expectedLrc === actualLrc) {
      return message;
    }
    return {
      message: message,
      error: 'mismatch LRC'
    };
  };
};

var fromBytesMap = {};
var nameMap = {};
var fromBytes$1 = getFromBytes(fromBytesMap, nameMap);
fromBytesMap[id$d] = fromBytes$f;
fromBytesMap[id$c] = fromBytes$e;
fromBytesMap[id$b] = fromBytes$d;
fromBytesMap[id$a] = fromBytes$c;
fromBytesMap[id$9] = fromBytes$b;
fromBytesMap[id$8] = fromBytes$a;
fromBytesMap[id$7] = fromBytes$9;
fromBytesMap[id$6] = fromBytes$8;
fromBytesMap[id$5] = fromBytes$7;
fromBytesMap[id$4] = fromBytes$6;
fromBytesMap[id$3] = fromBytes$5;
fromBytesMap[id$2] = fromBytes$4;
fromBytesMap[id$1] = fromBytes$3;
fromBytesMap[id] = fromBytes$2;
nameMap[id$d] = name$d;
nameMap[id$c] = name$c;
nameMap[id$b] = name$b;
nameMap[id$a] = name$a;
nameMap[id$9] = name$9;
nameMap[id$8] = name$8;
nameMap[id$7] = name$7;
nameMap[id$6] = name$6;
nameMap[id$5] = name$5;
nameMap[id$4] = name$4;
nameMap[id$3] = name$3;
nameMap[id$2] = name$2;
nameMap[id$1] = name$1;
nameMap[id] = name;

// export
fromBytes = fromBytes$1;
//#endregion


/*
  Incoming arguments:
    * payload - array of bytes
    * metadata - key/value object
*/

var result = {
    deviceName: 'Some Device Name',
    deviceType: 'Water Meter',
    attributes: {
        model: 'Device Model',
        serialNumber: 'SN111',
        manufacturer: 'Device Manufacturer'
    },
    messages: fromBytes(payload, config),
    metadata: metadata
};

return result;
