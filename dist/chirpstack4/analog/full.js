// these options can be edited
// available hardware types can be found here:
// https://github.com/jooby-dev/jooby-docs/blob/main/docs/analog/basics.md#hardware-types
var config = {
    hardwareType: 0
};


/*
  Get message form bytes.

  Input is an object with the following fields:
    * bytes - byte array containing the uplink payload, e.g. [255, 230, 255, 0]
    * fPort - uplink fPort
    * variables - object containing the configured device variables

  Output must be an object with the following fields:
    * data - object representing the decoded payload
*/
function decodeUplink ( input ) {
    const message = fromBytes(input.bytes, config);

    // there may be a message.error (e.g. mismatched LRC)
    // in that case message.message will contain everything parsed successfully
    // it should be used with caution

    return {data: message.message || message};
};


/*
  Get payload bytes from commands.

  Input is an object with the following fields:
    * data - object representing the payload that must be encoded
    * variables - object containing the configured device variables

  Output must be an object with the following fields:
    * bytes - byte array containing the downlink payload
*/
function encodeDownlink ( input ) {
    return {
        bytes: toBytes(input.data.commands, config)
    };
};


//#region [autogenerated jooby-codec bundle]
var fromBytes, toBytes;

(function () {
    'use strict';

    const hexFormatOptions = {
        separator: ' ',
        prefix: ''
    };

    const INT8_SIZE = 1;
    const INT16_SIZE = 2;
    const INT32_SIZE = 4;
    const { log, pow, LN2 } = Math;
    const readFloat = (buffer, offset, isLittleEndian, mLen, bytes) => {
        var e, m, eLen = bytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLittleEndian ? bytes - 1 : 0, d = isLittleEndian ? -1 : 1, s = buffer[offset + i];
        i += d;
        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 0x100 + buffer[offset + i], i += d, nBits -= 8)
            ;
        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 0x100 + buffer[offset + i], i += d, nBits -= 8)
            ;
        if (e === 0) {
            e = 1 - eBias;
        }
        else if (e === eMax) {
            return m ? NaN : s ? -Infinity : Infinity;
        }
        else {
            m = m + pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * pow(2, e - mLen);
    };
    const writeFloat = (buffer, offset, value, isLittleEndian, mLen, bytes) => {
        var e, m, c, eLen = bytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = (mLen === 23 ? pow(2, -24) - pow(2, -77) : 0), i = isLittleEndian ? 0 : bytes - 1, d = isLittleEndian ? 1 : -1, s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
        value < 0 && (value = -value);
        if (value !== value || value === Infinity) {
            m = value !== value ? 1 : 0;
            e = eMax;
        }
        else {
            e = (log(value) / LN2) | 0;
            if (value * (c = pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            }
            else {
                value += rt * pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }
            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            }
            else if (e + eBias >= 1) {
                m = (value * c - 1) * pow(2, mLen);
                e = e + eBias;
            }
            else {
                m = value * pow(2, eBias - 1) * pow(2, mLen);
                e = 0;
            }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 0x100, mLen -= 8)
            ;
        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 0x100, eLen -= 8)
            ;
        buffer[offset + i - d] |= s * 0x80;
    };
    const be2 = [1, 0];
    const be4 = [3, 2, 1, 0];
    const le2 = [0, 1];
    const le4 = [0, 1, 2, 3];
    const readUint8 = (buffer, offset) => buffer[offset];
    const readUint16 = (buffer, offset, isLittleEndian) => {
        const order = isLittleEndian ? le2 : be2;
        const b0 = buffer[offset + order[0]];
        const b1 = buffer[offset + order[1]] << 8;
        return b0 | b1;
    };
    const readUint32 = (buffer, offset, isLittleEndian) => {
        const order = isLittleEndian ? le4 : be4;
        const b0 = buffer[offset + order[3]] * 0x1000000;
        const b1 = buffer[offset + order[2]] * 0x10000;
        const b2 = buffer[offset + order[1]] * 0x100;
        const b3 = buffer[offset + order[0]];
        return b0 + b1 + b2 + b3;
    };
    const writeUint8 = (buffer, offset, value) => {
        buffer[offset] = value & 0xff;
    };
    const writeUint16 = (buffer, offset, value, isLittleEndian) => {
        const order = isLittleEndian ? le2 : be2;
        buffer[offset + order[0]] = value & 0xff;
        buffer[offset + order[1]] = value >>> 8 & 0xff;
    };
    const writeUint32 = (buffer, offset, value, isLittleEndian) => {
        const order = isLittleEndian ? le4 : be4;
        buffer[offset + order[0]] = value & 0xff;
        buffer[offset + order[1]] = value >>> 8 & 0xff;
        buffer[offset + order[2]] = value >>> 16 & 0xff;
        buffer[offset + order[3]] = value >>> 24 & 0xff;
    };
    function BinaryBuffer(dataOrLength, isLittleEndian = true) {
        if (typeof dataOrLength === 'number') {
            const bytes = new Array(dataOrLength).fill(0);
            this.data = bytes;
        }
        else {
            this.data = dataOrLength;
        }
        this.offset = 0;
        this.isLittleEndian = isLittleEndian;
    }
    BinaryBuffer.prototype = {
        toUint8Array() {
            return this.data;
        },
        seek(position) {
            if (position < 0 || position >= this.data.length) {
                throw new Error('Invalid position.');
            }
            this.offset = position;
        },
        setInt8(value) {
            writeUint8(this.data, this.offset, value < 0 ? value | 0x100 : value);
            this.offset += INT8_SIZE;
        },
        getInt8() {
            const result = readUint8(this.data, this.offset);
            this.offset += INT8_SIZE;
            return result & 0x80 ? result ^ -0x100 : result;
        },
        setUint8(value) {
            writeUint8(this.data, this.offset, value);
            this.offset += INT8_SIZE;
        },
        getUint8() {
            const result = readUint8(this.data, this.offset);
            this.offset += INT8_SIZE;
            return result;
        },
        setInt16(value, isLittleEndian = this.isLittleEndian) {
            writeUint16(this.data, this.offset, value < 0 ? value | 0x10000 : value, isLittleEndian);
            this.offset += INT16_SIZE;
        },
        getInt16(isLittleEndian = this.isLittleEndian) {
            const result = readUint16(this.data, this.offset, isLittleEndian);
            this.offset += INT16_SIZE;
            return result & 0x8000 ? result ^ -0x10000 : result;
        },
        setUint16(value, isLittleEndian = this.isLittleEndian) {
            writeUint16(this.data, this.offset, value, isLittleEndian);
            this.offset += INT16_SIZE;
        },
        getUint16(isLittleEndian = this.isLittleEndian) {
            const result = readUint16(this.data, this.offset, isLittleEndian);
            this.offset += INT16_SIZE;
            return result;
        },
        setInt32(value, isLittleEndian = this.isLittleEndian) {
            writeUint32(this.data, this.offset, value < 0 ? value | 0x100000000 : value, isLittleEndian);
            this.offset += INT32_SIZE;
        },
        getInt32(isLittleEndian = this.isLittleEndian) {
            const result = readUint32(this.data, this.offset, isLittleEndian);
            this.offset += INT32_SIZE;
            return result & 0x80000000 ? result ^ -0x100000000 : result;
        },
        setUint32(value, isLittleEndian = this.isLittleEndian) {
            writeUint32(this.data, this.offset, value, isLittleEndian);
            this.offset += INT32_SIZE;
        },
        getUint32(isLittleEndian = this.isLittleEndian) {
            const result = readUint32(this.data, this.offset, isLittleEndian);
            this.offset += INT32_SIZE;
            return result;
        },
        setFloat32(value, isLittleEndian = this.isLittleEndian) {
            writeFloat(this.data, this.offset, value, isLittleEndian, 23, 4);
            this.offset += INT32_SIZE;
        },
        getFloat32(isLittleEndian = this.isLittleEndian) {
            const result = readFloat(this.data, this.offset, isLittleEndian, 23, 4);
            this.offset += INT32_SIZE;
            return result;
        },
        setString(value) {
            this.setUint8(value.length);
            for (let index = 0; index < value.length; ++index) {
                this.setUint8(value.charCodeAt(index));
            }
        },
        getString() {
            const size = this.getUint8();
            const endIndex = this.offset + size;
            const chars = [];
            while (this.offset < endIndex) {
                chars.push(String.fromCharCode(this.getUint8()));
            }
            return chars.join('');
        },
        getBytesToOffset(offset = this.offset) {
            return this.data.slice(0, offset);
        },
        getBytesLeft() {
            return this.getBytes(this.bytesLeft);
        },
        getBytes(length, offset = this.offset) {
            this.offset = offset + length;
            return this.data.slice(offset, this.offset);
        },
        setBytes(data, offset = this.offset) {
            const bytes = this.data;
            bytes.splice(offset, data.length, ...data);
            this.data = bytes;
            this.offset = offset + data.length;
        }
    };
    Object.defineProperties(BinaryBuffer.prototype, {
        size: {
            get() {
                return this.data.length;
            }
        },
        isEmpty: {
            get() {
                return this.data.length - this.offset === 0;
            }
        },
        bytesLeft: {
            get() {
                return this.data.length - this.offset;
            }
        },
        position: {
            get() {
                return this.offset;
            }
        }
    });

    const shortCommandMask = 0xe0;
    const extraCommandMask = 0x1f;
    const fromBytes$v = (data) => {
        if (data.length === 0) {
            throw new Error('Invalid buffer size');
        }
        const header = {
            shortCode: data[0] & shortCommandMask,
            extraCode: data[0] & extraCommandMask
        };
        if (header.shortCode !== 0) {
            return {
                headerSize: 1,
                commandId: data[0] & (~header.extraCode),
                commandSize: header.extraCode
            };
        }
        if (header.extraCode === extraCommandMask) {
            if (data.length < 3) {
                throw new Error('Invalid buffer size');
            }
            return {
                headerSize: 3,
                commandId: (data[1] << 8) | extraCommandMask,
                commandSize: data[2]
            };
        }
        if (data.length < 2) {
            throw new Error('Invalid buffer size');
        }
        return {
            headerSize: 2,
            commandId: header.extraCode,
            commandSize: data[1]
        };
    };
    const toBytes$w = (commandId, commandSize) => {
        if ((commandId & extraCommandMask) === 0) {
            if (commandSize > extraCommandMask) {
                throw new Error(`Wrong command id/size. Id: ${commandId}, size: ${commandSize}.`);
            }
            return [commandId | commandSize];
        }
        if (commandId > extraCommandMask) {
            return [
                extraCommandMask,
                (commandId >> 8),
                commandSize
            ];
        }
        return [
            commandId,
            commandSize
        ];
    };

    const toBytes$v = (commandId, commandData = []) => {
        const headerData = toBytes$w(commandId, commandData.length);
        return [...headerData, ...commandData];
    };

    const id$s = 0x0c;
    const name$s = 'correctTime2000';
    const COMMAND_BODY_SIZE$f = 2;
    const fromBytes$u = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$f) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new BinaryBuffer(data, false);
        const parameters = {
            sequenceNumber: buffer.getUint8(),
            seconds: buffer.getInt8()
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };
    const toBytes$u = (parameters) => {
        const { sequenceNumber, seconds } = parameters;
        const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$f, false);
        buffer.setUint8(sequenceNumber);
        buffer.setInt8(seconds);
        return toBytes$v(id$s, buffer.data);
    };

    const INITIAL_YEAR_TIMESTAMP = 946684800000;
    const MILLISECONDS_IN_SECONDS = 1000;
    const getDateFromTime2000 = (time2000) => new Date(INITIAL_YEAR_TIMESTAMP + (time2000 * MILLISECONDS_IN_SECONDS));
    const getTime2000FromDate = (date) => (date.getTime() - INITIAL_YEAR_TIMESTAMP) / MILLISECONDS_IN_SECONDS;

    const fromObject = (bitMask = {}, booleanObject = {}) => {
        let result = 0;
        for (const name in booleanObject) {
            if (name in bitMask && booleanObject[name]) {
                result |= bitMask[name];
            }
        }
        return result;
    };
    const toObject = (bitMask = {}, value = 0) => {
        const result = {};
        for (const name in bitMask) {
            result[name] = (value & bitMask[name]) !== 0;
        }
        return result;
    };

    const GASI1 = 1;
    const GASI2 = 2;
    const GASI3 = 3;
    const NOVATOR = 4;
    const IMP2EU = 5;
    const IMP4EU = 6;
    const MTXLORA = 7;
    const IMP2AS = 8;
    const IMP2IN = 9;
    const IMP4IN = 10;
    const ELIMP = 11;
    const GASIC = 12;

    var invertObject = (source) => {
        const target = {};
        for (const property in source) {
            const value = source[property];
            target[value] = property;
        }
        return target;
    };

    const INITIAL_YEAR = 2000;
    const MONTH_BIT_SIZE = 4;
    const DATE_BIT_SIZE = 5;
    const YEAR_START_INDEX = 1;
    const UNKNOWN_BATTERY_VOLTAGE = 4095;
    const EXTEND_BIT_MASK = 0x80;
    const LAST_BIT_INDEX = 7;
    const GAS_HARDWARE_TYPES = [
        GASI2,
        GASI3,
        GASI1,
        GASIC
    ];
    const TWO_CHANNELS_HARDWARE_TYPES = [
        IMP2AS,
        IMP2EU,
        IMP2IN,
        NOVATOR
    ];
    const ELIMP_HARDWARE_TYPES = [
        ELIMP
    ];
    const FOUR_CHANNELS_HARDWARE_TYPES = [
        IMP4EU,
        IMP4IN
    ];
    const MTX_HARDWARE_TYPES = [
        MTXLORA
    ];
    const TWO_BYTES_HARDWARE_TYPES = [...FOUR_CHANNELS_HARDWARE_TYPES, ...MTX_HARDWARE_TYPES];
    const gasBitMask = {
        isBatteryLow: Math.pow(2, 0),
        isMagneticInfluence: Math.pow(2, 1),
        isButtonReleased: Math.pow(2, 2),
        isConnectionLost: Math.pow(2, 3)
    };
    const twoChannelBitMask = {
        isBatteryLow: Math.pow(2, 0),
        isConnectionLost: Math.pow(2, 3),
        isFirstChannelInactive: Math.pow(2, 4),
        isSecondChannelInactive: Math.pow(2, 5)
    };
    const elimpBitMask = {
        isConnectionLost: Math.pow(2, 3)
    };
    const fourChannelBitMask = {
        isBatteryLow: Math.pow(2, 0),
        isConnectionLost: Math.pow(2, 3),
        isFirstChannelInactive: Math.pow(2, 4),
        isSecondChannelInactive: Math.pow(2, 5),
        isThirdChannelInactive: Math.pow(2, 6),
        isForthChannelInactive: Math.pow(2, 7)
    };
    const mtxBitMask = {
        isMeterCaseOpen: Math.pow(2, 0),
        isMagneticInfluence: Math.pow(2, 1),
        isParametersSetRemotely: Math.pow(2, 2),
        isParametersSetLocally: Math.pow(2, 3),
        isMeterProgramRestarted: Math.pow(2, 4),
        isLockedOut: Math.pow(2, 5),
        isTimeSet: Math.pow(2, 6),
        isTimeCorrected: Math.pow(2, 7),
        isMeterFailure: Math.pow(2, 8),
        isMeterTerminalBoxOpen: Math.pow(2, 9),
        isModuleCompartmentOpen: Math.pow(2, 10),
        isTariffPlanChanged: Math.pow(2, 11),
        isNewTariffPlanReceived: Math.pow(2, 12)
    };
    const byteToPulseCoefficientMap = {
        128: 1,
        129: 5,
        130: 10,
        131: 100,
        132: 1000,
        133: 10000,
        134: 100000
    };
    const pulseCoefficientToByteMap = invertObject(byteToPulseCoefficientMap);
    const isMSBSet = (value) => !!(value & 0x80);
    const getEventStatusSize = (hardwareType) => (TWO_BYTES_HARDWARE_TYPES.indexOf(hardwareType) !== -1 ? 2 : 1);
    function CommandBinaryBuffer(dataOrLength, isLittleEndian = true) {
        BinaryBuffer.call(this, dataOrLength, isLittleEndian);
    }
    CommandBinaryBuffer.prototype = Object.create(BinaryBuffer.prototype);
    CommandBinaryBuffer.prototype.constructor = CommandBinaryBuffer;
    CommandBinaryBuffer.prototype.getExtendedValue = function () {
        let value = 0;
        let isByteExtended = true;
        let position = 0;
        while (isByteExtended && this.offset <= this.data.length) {
            const byte = this.getUint8();
            isByteExtended = !!(byte & EXTEND_BIT_MASK);
            value += (byte & 0x7f) << (7 * position);
            ++position;
        }
        if (value < 0) {
            value = 0;
        }
        return value;
    };
    CommandBinaryBuffer.prototype.setExtendedValue = function (value) {
        if (value === 0) {
            this.setUint8(0);
            return;
        }
        const data = [];
        let encodedValue = value;
        while (encodedValue) {
            data.push(EXTEND_BIT_MASK | (encodedValue & 0x7f));
            encodedValue >>= 7;
        }
        const lastByte = data.pop();
        if (lastByte) {
            data.push(lastByte & 0x7f);
        }
        data.forEach(extendedValue => this.setUint8(extendedValue));
    };
    CommandBinaryBuffer.prototype.getExtendedValueSize = function (bits) {
        const extBits = Math.ceil(bits / 7);
        const totalBits = bits + extBits;
        const extBytes = Math.ceil(totalBits / 8);
        return extBytes;
    };
    CommandBinaryBuffer.prototype.getTime = function () {
        return this.getUint32(false);
    };
    CommandBinaryBuffer.prototype.setTime = function (value) {
        this.setUint32(value, false);
    };
    CommandBinaryBuffer.prototype.getBatteryVoltage = function () {
        const lowVoltageByte = this.getUint8();
        const lowAndHightVoltageByte = this.getUint8();
        const highVoltageByte = this.getUint8();
        let underLowLoad = lowVoltageByte << 4;
        underLowLoad |= (lowAndHightVoltageByte & 0xf0) >> 4;
        let underHighLoad = ((lowAndHightVoltageByte & 0x0f) << 8) | highVoltageByte;
        if (underHighLoad === UNKNOWN_BATTERY_VOLTAGE) {
            underHighLoad = undefined;
        }
        if (underLowLoad === UNKNOWN_BATTERY_VOLTAGE) {
            underLowLoad = undefined;
        }
        return { underLowLoad, underHighLoad };
    };
    CommandBinaryBuffer.prototype.setBatteryVoltage = function (batteryVoltage) {
        let { underLowLoad, underHighLoad } = batteryVoltage;
        if (underLowLoad === undefined) {
            underLowLoad = UNKNOWN_BATTERY_VOLTAGE;
        }
        if (underHighLoad === undefined) {
            underHighLoad = UNKNOWN_BATTERY_VOLTAGE;
        }
        const lowVoltageByte = (underLowLoad >> 4) & 0xff;
        const lowAndHighVoltageByte = ((underLowLoad & 0x0f) << 4) | ((underHighLoad >> 8) & 0x0f);
        const highVoltageByte = underHighLoad & 0xff;
        [lowVoltageByte, lowAndHighVoltageByte, highVoltageByte].forEach(byte => this.setUint8(byte));
    };
    CommandBinaryBuffer.prototype.getChannels = function () {
        const channelList = [];
        let extended = true;
        let channelIndex = 1;
        while (extended) {
            const byte = this.getUint8();
            const bits = byte.toString(2).padStart(LAST_BIT_INDEX + 1, '0').split('').reverse();
            bits.forEach((bit, index) => {
                const value = Number(bit);
                if (index === LAST_BIT_INDEX) {
                    extended = !!value;
                }
                else {
                    if (value) {
                        channelList.push(channelIndex);
                    }
                    ++channelIndex;
                }
            });
        }
        return channelList;
    };
    CommandBinaryBuffer.prototype.setChannels = function (channelList) {
        if (channelList.length === 0) {
            this.setUint8(0);
            return;
        }
        channelList.sort((a, b) => a.index - b.index);
        const maxChannel = Math.max(...channelList.map(({ index }) => index));
        const size = (maxChannel - (maxChannel % 8)) / 8;
        const data = new Array(size + 1).fill(0);
        let byte = 0;
        data.forEach((_, byteIndex) => {
            let channelIndex = (byteIndex * LAST_BIT_INDEX) + 1;
            const maxChannelIndex = channelIndex + LAST_BIT_INDEX;
            while (channelIndex < maxChannelIndex) {
                const channel = channelList.find((item => item.index === channelIndex));
                if (channel !== undefined) {
                    byte |= 1 << ((channel.index - 1) % LAST_BIT_INDEX);
                }
                ++channelIndex;
            }
            if (data[byteIndex + 1] !== undefined) {
                byte |= 1 << LAST_BIT_INDEX;
            }
            data[byteIndex] = byte;
            byte = 0;
        });
        data.forEach((value) => this.setUint8(value));
    };
    CommandBinaryBuffer.prototype.getChannelsValuesWithHourDiff = function () {
        const date = this.getDate();
        const { hour, hours } = this.getHours();
        const channels = this.getChannels();
        const channelList = [];
        date.setUTCHours(hour);
        channels.forEach(channelIndex => {
            const diff = [];
            const value = this.getExtendedValue();
            for (let diffHour = 1; diffHour < hours; ++diffHour) {
                diff.push(this.getExtendedValue());
            }
            channelList.push({
                value,
                diff,
                index: channelIndex
            });
        });
        return { startTime2000: getTime2000FromDate(date), hours, channelList };
    };
    CommandBinaryBuffer.prototype.setChannelsValuesWithHourDiff = function (hours, startTime2000, channelList) {
        const date = getDateFromTime2000(startTime2000);
        const hour = date.getUTCHours();
        this.setDate(date);
        this.setHours(hour, hours);
        this.setChannels(channelList);
        channelList.forEach(({ value, diff }) => {
            this.setExtendedValue(value);
            diff.forEach(diffValue => this.setExtendedValue(diffValue));
        });
    };
    CommandBinaryBuffer.prototype.getHours = function (byte = this.getUint8()) {
        if (byte === 0) {
            return { hours: 0, hour: 0 };
        }
        const hours = ((byte & 0xe0) >> 5) + 1;
        const hour = byte & 0x1f;
        return { hours, hour };
    };
    CommandBinaryBuffer.prototype.setHours = function (hour, hours) {
        if (hour === 0 && hours === 0) {
            this.setUint8(0);
            return;
        }
        this.setUint8((((hours - 1) & 0x07) << 5) | (hour & 0x1f));
    };
    CommandBinaryBuffer.prototype.getDate = function () {
        const yearMonthByte = this.getUint8();
        const monthDateByte = this.getUint8();
        const year = yearMonthByte >> YEAR_START_INDEX;
        const month = ((yearMonthByte & 0x01) << MONTH_BIT_SIZE - YEAR_START_INDEX) | (monthDateByte >> DATE_BIT_SIZE);
        const monthDay = monthDateByte & 0x1f;
        return new Date(Date.UTC(year + INITIAL_YEAR, month - 1, monthDay, 0, 0, 0, 0));
    };
    CommandBinaryBuffer.prototype.setDate = function (dateOrTime) {
        let date;
        if (dateOrTime instanceof Date) {
            date = dateOrTime;
        }
        else {
            date = getDateFromTime2000(dateOrTime);
        }
        const year = date.getUTCFullYear() - INITIAL_YEAR;
        const month = date.getUTCMonth() + 1;
        const day = date.getUTCDate();
        const yearMonthByte = (year << YEAR_START_INDEX) | (month >> MONTH_BIT_SIZE - YEAR_START_INDEX);
        const monthDateByte = ((month & 0x07) << DATE_BIT_SIZE) | day;
        [yearMonthByte, monthDateByte].forEach(byte => this.setUint8(byte));
    };
    CommandBinaryBuffer.prototype.getPulseCoefficient = function () {
        const pulseCoefficient = this.getUint8();
        if (isMSBSet(pulseCoefficient)) {
            const value = byteToPulseCoefficientMap[pulseCoefficient];
            if (value) {
                return value;
            }
            throw new Error('pulseCoefficient MSB is set, but value unknown');
        }
        return pulseCoefficient;
    };
    CommandBinaryBuffer.prototype.setPulseCoefficient = function (value) {
        if (value in pulseCoefficientToByteMap) {
            const byte = pulseCoefficientToByteMap[value];
            if (byte) {
                this.setUint8(byte);
            }
            else {
                throw new Error('pulseCoefficient MSB is set, but value unknown');
            }
        }
        else {
            this.setUint8(value);
        }
    };
    CommandBinaryBuffer.prototype.getChannelsWithAbsoluteValues = function () {
        const channels = this.getChannels();
        const channelList = [];
        channels.forEach(channelIndex => {
            channelList.push({
                pulseCoefficient: this.getPulseCoefficient(),
                value: this.getExtendedValue(),
                index: channelIndex
            });
        });
        return channelList;
    };
    CommandBinaryBuffer.prototype.setChannelsWithAbsoluteValues = function (channelList) {
        this.setChannels(channelList);
        channelList.forEach(({ value, pulseCoefficient }) => {
            this.setPulseCoefficient(pulseCoefficient);
            this.setExtendedValue(value);
        });
    };
    CommandBinaryBuffer.prototype.getChannelsAbsoluteValuesWithHourDiff = function (hours) {
        const channels = this.getChannels();
        const channelList = [];
        channels.forEach(channelIndex => {
            const pulseCoefficient = this.getPulseCoefficient();
            const value = this.getExtendedValue();
            const diff = [];
            for (let hourIndex = 1; hourIndex < hours; ++hourIndex) {
                diff.push(this.getExtendedValue());
            }
            channelList.push({
                diff,
                value,
                pulseCoefficient,
                index: channelIndex
            });
        });
        return channelList;
    };
    CommandBinaryBuffer.prototype.setChannelsAbsoluteValuesWithHourDiff = function (channelList) {
        this.setChannels(channelList);
        channelList.forEach(({ value, diff, pulseCoefficient }) => {
            this.setPulseCoefficient(pulseCoefficient);
            this.setExtendedValue(value);
            diff.forEach(diffValue => this.setExtendedValue(diffValue));
        });
    };
    CommandBinaryBuffer.prototype.getEventStatus = function (hardwareType) {
        let status;
        if (GAS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(gasBitMask, this.getUint8());
        }
        else if (TWO_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(twoChannelBitMask, this.getUint8());
        }
        else if (ELIMP_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(elimpBitMask, this.getUint8());
        }
        else if (FOUR_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(fourChannelBitMask, this.getExtendedValue());
        }
        else if (MTX_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            status = toObject(mtxBitMask, this.getUint16());
        }
        else {
            throw new Error('wrong hardwareType');
        }
        return status;
    };
    CommandBinaryBuffer.prototype.setEventStatus = function (hardwareType, status) {
        if (GAS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            this.setUint8(fromObject(gasBitMask, status));
        }
        else if (TWO_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            this.setUint8(fromObject(twoChannelBitMask, status));
        }
        else if (ELIMP_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            this.setUint8(fromObject(elimpBitMask, status));
        }
        else if (FOUR_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            this.setExtendedValue(fromObject(fourChannelBitMask, status));
        }
        else if (MTX_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
            this.setUint16(fromObject(mtxBitMask, status));
        }
        else {
            throw new Error('wrong hardwareType');
        }
    };

    const id$r = 0x1b;
    const name$r = 'getArchiveDaysMc';
    const COMMAND_BODY_SIZE$e = 4;
    const fromBytes$t = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$e) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        const date = buffer.getDate();
        const channelList = buffer.getChannels();
        const days = buffer.getUint8();
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return { startTime2000: getTime2000FromDate(date), days, channelList };
    };
    const toBytes$t = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_SIZE$e);
        const { startTime2000, days, channelList } = parameters;
        const date = getDateFromTime2000(startTime2000);
        buffer.setDate(date);
        buffer.setChannels(channelList.map(index => ({ index })));
        buffer.setUint8(days);
        return toBytes$v(id$r, buffer.data);
    };

    const id$q = 0x0b;
    const name$q = 'getArchiveEvents';
    const COMMAND_BODY_SIZE$d = 5;
    const fromBytes$s = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$d) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        const startTime2000 = buffer.getTime();
        const events = buffer.getUint8();
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return { startTime2000, events };
    };
    const toBytes$s = (parameters) => {
        const { startTime2000, events } = parameters;
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_SIZE$d);
        buffer.setTime(startTime2000);
        buffer.setUint8(events);
        return toBytes$v(id$q, buffer.data);
    };

    const id$p = 0x1a;
    const name$p = 'getArchiveHoursMc';
    const COMMAND_BODY_SIZE$c = 4;
    const fromBytes$r = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$c) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        const date = buffer.getDate();
        const { hour, hours } = buffer.getHours();
        const channelList = buffer.getChannels();
        date.setUTCHours(hour);
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return { startTime2000: getTime2000FromDate(date), hours, channelList };
    };
    const toBytes$r = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_SIZE$c);
        const { hours, startTime2000, channelList } = parameters;
        const date = getDateFromTime2000(startTime2000);
        const hour = date.getUTCHours();
        buffer.setDate(date);
        buffer.setHours(hour, hours);
        buffer.setChannels(channelList.map(index => ({ index })));
        return toBytes$v(id$p, buffer.data);
    };

    const id$o = 0x07;
    const name$o = 'getCurrent';
    const COMMAND_BODY_SIZE$b = 0;
    const fromBytes$q = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$b) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        return {};
    };
    const toBytes$q = () => toBytes$v(id$o);

    const id$n = 0x18;
    const name$n = 'getCurrentMc';
    const COMMAND_BODY_SIZE$a = 0;
    const fromBytes$p = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$a) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        return {};
    };
    const toBytes$p = () => toBytes$v(id$n);

    const id$m = 0x0d1f;
    const name$m = 'getExAbsArchiveDaysMc';
    const COMMAND_BODY_SIZE$9 = 4;
    const fromBytes$o = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$9) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        const date = buffer.getDate();
        const channelList = buffer.getChannels();
        const days = buffer.getUint8();
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return { startTime2000: getTime2000FromDate(date), days, channelList };
    };
    const toBytes$o = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_SIZE$9);
        const { startTime2000, days, channelList } = parameters;
        buffer.setDate(startTime2000);
        buffer.setChannels(channelList.map(index => ({ index })));
        buffer.setUint8(days);
        return toBytes$v(id$m, buffer.data);
    };

    const id$l = 0x0c1f;
    const name$l = 'getExAbsArchiveHoursMc';
    const COMMAND_BODY_SIZE$8 = 4;
    const fromBytes$n = (data) => {
        const buffer = new CommandBinaryBuffer(data);
        const date = buffer.getDate();
        const { hour, hours } = buffer.getHours();
        const channelList = buffer.getChannels();
        date.setUTCHours(hour);
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return { channelList, hours, startTime2000: getTime2000FromDate(date) };
    };
    const toBytes$n = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_SIZE$8);
        const { startTime2000, hours, channelList } = parameters;
        const date = getDateFromTime2000(startTime2000);
        const hour = date.getUTCHours();
        buffer.setDate(date);
        buffer.setHours(hour, hours);
        buffer.setChannels(channelList.map(index => ({ index })));
        return toBytes$v(id$l, buffer.data);
    };

    const id$k = 0x021f;
    const name$k = 'getLmicInfo';
    const COMMAND_BODY_SIZE$7 = 0;
    const fromBytes$m = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$7) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        return {};
    };
    const toBytes$m = () => toBytes$v(id$k);

    const id$j = 0x14;
    const name$j = 'getStatus';
    const COMMAND_BODY_SIZE$6 = 0;
    const fromBytes$l = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$6) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        return {};
    };
    const toBytes$l = () => toBytes$v(id$j);

    const id$i = 0x09;
    const name$i = 'getTime2000';
    const COMMAND_BODY_SIZE$5 = 0;
    const fromBytes$k = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$5) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        return {};
    };
    const toBytes$k = () => toBytes$v(id$i, []);

    const id$h = 0x02;
    const name$h = 'setTime2000';
    const COMMAND_BODY_SIZE$4 = 5;
    const fromBytes$j = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$4) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new BinaryBuffer(data, false);
        const parameters = {
            sequenceNumber: buffer.getUint8(),
            seconds: buffer.getInt32()
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };
    const toBytes$j = (parameters) => {
        const { sequenceNumber, seconds } = parameters;
        const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$4, false);
        buffer.setUint8(sequenceNumber);
        buffer.setInt32(seconds);
        return toBytes$v(id$h, buffer.data);
    };

    var calculateLrc = (data, initialLrc = 0x55) => {
        let lrc = initialLrc;
        data.forEach(item => {
            lrc ^= item;
        });
        return lrc;
    };

    const HEADER_MAX_SIZE = 3;
    const getFromBytes = (fromBytesMap, nameMap) => (data = [], config) => {
        const commands = [];
        const message = {
            commands,
            bytes: data,
            lrc: { expected: undefined, actual: 0 }
        };
        let processedBytes = 0;
        let expectedLrc;
        let actualLrc;
        if (!data.length) {
            return message;
        }
        do {
            const headerInfo = fromBytes$v(data.slice(processedBytes, processedBytes + HEADER_MAX_SIZE));
            const headerData = data.slice(processedBytes, processedBytes + headerInfo.headerSize);
            const bodyData = data.slice(processedBytes + headerInfo.headerSize, processedBytes + headerInfo.headerSize + headerInfo.commandSize);
            const command = {
                id: headerInfo.commandId,
                name: nameMap[headerInfo.commandId],
                headerSize: headerInfo.headerSize,
                bytes: [...headerData, ...bodyData]
            };
            processedBytes = processedBytes + headerInfo.headerSize + headerInfo.commandSize;
            if (config) {
                command.config = config;
            }
            try {
                command.parameters = fromBytesMap[headerInfo.commandId](bodyData, config);
                commands.push(command);
            }
            catch (error) {
                commands.push({
                    command,
                    error: error.message
                });
            }
        } while (processedBytes < data.length - 1);
        if (data.length - processedBytes === 1) {
            expectedLrc = data[data.length - 1];
            actualLrc = calculateLrc(data.slice(0, -1));
        }
        else {
            actualLrc = calculateLrc(data);
        }
        message.lrc.actual = actualLrc;
        message.lrc.expected = expectedLrc;
        if (expectedLrc === actualLrc) {
            return message;
        }
        return {
            message,
            error: 'mismatch LRC'
        };
    };
    const getToBytes = toBytesMap => (commands) => {
        const commandBytes = commands.map(command => {
            if ('parameters' in command) {
                return toBytesMap[command.id](command.parameters, command.config);
            }
            if ('command' in command) {
                return command.command.bytes;
            }
            throw new Error('wrong command format');
        });
        const body = [].concat(...commandBytes);
        return [...body, calculateLrc(body)];
    };

    const toBytesMap$1 = {};
    const fromBytesMap$1 = {};
    const nameMap$1 = {};
    const toBytes$i = getToBytes(toBytesMap$1);
    toBytesMap$1[id$s] = toBytes$u;
    toBytesMap$1[id$r] = toBytes$t;
    toBytesMap$1[id$q] = toBytes$s;
    toBytesMap$1[id$p] = toBytes$r;
    toBytesMap$1[id$o] = toBytes$q;
    toBytesMap$1[id$n] = toBytes$p;
    toBytesMap$1[id$m] = toBytes$o;
    toBytesMap$1[id$l] = toBytes$n;
    toBytesMap$1[id$k] = toBytes$m;
    toBytesMap$1[id$j] = toBytes$l;
    toBytesMap$1[id$i] = toBytes$k;
    toBytesMap$1[id$h] = toBytes$j;
    fromBytesMap$1[id$s] = fromBytes$u;
    fromBytesMap$1[id$r] = fromBytes$t;
    fromBytesMap$1[id$q] = fromBytes$s;
    fromBytesMap$1[id$p] = fromBytes$r;
    fromBytesMap$1[id$o] = fromBytes$q;
    fromBytesMap$1[id$n] = fromBytes$p;
    fromBytesMap$1[id$m] = fromBytes$o;
    fromBytesMap$1[id$l] = fromBytes$n;
    fromBytesMap$1[id$k] = fromBytes$m;
    fromBytesMap$1[id$j] = fromBytes$l;
    fromBytesMap$1[id$i] = fromBytes$k;
    fromBytesMap$1[id$h] = fromBytes$j;
    nameMap$1[id$s] = name$s;
    nameMap$1[id$r] = name$r;
    nameMap$1[id$q] = name$q;
    nameMap$1[id$p] = name$p;
    nameMap$1[id$o] = name$o;
    nameMap$1[id$n] = name$n;
    nameMap$1[id$m] = name$m;
    nameMap$1[id$l] = name$l;
    nameMap$1[id$k] = name$k;
    nameMap$1[id$j] = name$j;
    nameMap$1[id$i] = name$i;
    nameMap$1[id$h] = name$h;

    const id$g = 0x0c;
    const name$g = 'correctTime2000';
    const COMMAND_BODY_SIZE$3 = 1;
    const fromBytes$i = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$3) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new BinaryBuffer(data, false);
        const parameters = {
            status: buffer.getUint8()
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };
    const toBytes$h = (parameters) => {
        const { status } = parameters;
        const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$3, false);
        buffer.setUint8(status);
        return toBytes$v(id$g, buffer.data);
    };

    const id$f = 0x18;
    const name$f = 'currentMc';
    const COMMAND_BODY_MAX_SIZE$a = 37;
    const fromBytes$h = (data) => {
        if (data.length > COMMAND_BODY_MAX_SIZE$a) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const parameters = { channelList: [] };
        const buffer = new CommandBinaryBuffer(data);
        const channelList = buffer.getChannels();
        parameters.channelList = channelList.map(channelIndex => ({
            value: buffer.getExtendedValue(),
            index: channelIndex
        }));
        return parameters;
    };
    const toBytes$g = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$a);
        const { channelList } = parameters;
        buffer.setChannels(channelList);
        channelList.forEach(({ value }) => {
            buffer.setExtendedValue(value);
        });
        return toBytes$v(id$f, buffer.getBytesToOffset());
    };

    const id$e = 0x16;
    const name$e = 'dayMc';
    const COMMAND_BODY_MAX_SIZE$9 = 32;
    const fromBytes$g = (data) => {
        if (data.length > COMMAND_BODY_MAX_SIZE$9) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        const date = buffer.getDate();
        const channels = buffer.getChannels();
        const channelList = channels.map(channelIndex => ({
            value: buffer.getExtendedValue(),
            index: channelIndex
        }));
        return { startTime2000: getTime2000FromDate(date), channelList };
    };
    const toBytes$f = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$9);
        const { channelList, startTime2000 } = parameters;
        buffer.setDate(startTime2000);
        buffer.setChannels(channelList);
        channelList.forEach(({ value }) => {
            buffer.setExtendedValue(value);
        });
        return toBytes$v(id$e, buffer.getBytesToOffset());
    };

    const id$d = 0x0b1f;
    const name$d = 'exAbsDayMc';
    const COMMAND_BODY_MAX_SIZE$8 = 89;
    const fromBytes$f = (data) => {
        if (data.length > COMMAND_BODY_MAX_SIZE$8) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        const date = buffer.getDate();
        const channelList = buffer.getChannelsWithAbsoluteValues();
        return { startTime2000: getTime2000FromDate(date), channelList };
    };
    const toBytes$e = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$8);
        const { startTime2000, channelList } = parameters;
        buffer.setDate(startTime2000);
        buffer.setChannelsWithAbsoluteValues(channelList);
        return toBytes$v(id$d, buffer.getBytesToOffset());
    };

    const id$c = 0x0a1f;
    const name$c = 'exAbsHourMc';
    const COMMAND_BODY_MAX_SIZE$7 = 168;
    const fromBytes$e = (data) => {
        if (data.length > COMMAND_BODY_MAX_SIZE$7) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        const date = buffer.getDate();
        const { hour, hours } = buffer.getHours();
        const channelList = buffer.getChannelsAbsoluteValuesWithHourDiff(hours);
        date.setUTCHours(hour);
        return { startTime2000: getTime2000FromDate(date), hours, channelList };
    };
    const toBytes$d = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$7);
        const { startTime2000, hours, channelList } = parameters;
        const date = getDateFromTime2000(startTime2000);
        const hour = date.getUTCHours();
        buffer.setDate(startTime2000);
        buffer.setHours(hour, hours);
        buffer.setChannelsAbsoluteValuesWithHourDiff(channelList);
        return toBytes$v(id$c, buffer.getBytesToOffset());
    };

    const id$b = 0x1b;
    const name$b = 'getArchiveDaysMc';
    const COMMAND_BODY_MAX_SIZE$6 = 5104;
    const fromBytes$d = (data) => {
        const buffer = new CommandBinaryBuffer(data);
        const date = buffer.getDate();
        const channels = buffer.getChannels();
        const days = buffer.getUint8();
        const channelList = [];
        channels.forEach(channelIndex => {
            const dayList = [];
            channelList.push({ dayList, index: channelIndex });
            for (let day = 0; day < days; ++day) {
                dayList.push(buffer.getExtendedValue());
            }
        });
        return { startTime2000: getTime2000FromDate(date), days, channelList };
    };
    const toBytes$c = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$6);
        const { startTime2000, days, channelList } = parameters;
        buffer.setDate(startTime2000);
        buffer.setChannels(channelList);
        buffer.setUint8(days);
        channelList.forEach(({ dayList }) => {
            dayList.forEach(value => {
                buffer.setExtendedValue(value);
            });
        });
        return toBytes$v(id$b, buffer.getBytesToOffset());
    };

    const id$a = 0x0b;
    const name$a = 'getArchiveEvents';
    const COMMAND_BODY_MIN_SIZE = 4 + 1 + 1;
    const getEvent = (buffer) => ({
        time2000: buffer.getTime(),
        id: buffer.getUint8(),
        sequenceNumber: buffer.getUint8()
    });
    const setEvent = (buffer, event) => {
        buffer.setTime(event.time2000);
        buffer.setUint8(event.id);
        buffer.setUint8(event.sequenceNumber);
    };
    const fromBytes$c = (data) => {
        const buffer = new CommandBinaryBuffer(data, false);
        const eventList = [];
        while (buffer.bytesLeft > 0) {
            eventList.push(getEvent(buffer));
        }
        return { eventList };
    };
    function toBytes$b(parameters) {
        const { eventList } = parameters;
        const buffer = new CommandBinaryBuffer(eventList.length * COMMAND_BODY_MIN_SIZE, false);
        eventList.forEach(event => setEvent(buffer, event));
        return toBytes$v(id$a, buffer.data);
    }

    const id$9 = 0x1a;
    const name$9 = 'getArchiveHoursMc';
    const COMMAND_BODY_MAX_SIZE$5 = 164;
    const fromBytes$b = (data) => {
        if (data.length > COMMAND_BODY_MAX_SIZE$5) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        return buffer.getChannelsValuesWithHourDiff();
    };
    const toBytes$a = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$5);
        const { hours, startTime2000, channelList } = parameters;
        buffer.setChannelsValuesWithHourDiff(hours, startTime2000, channelList);
        return toBytes$v(id$9, buffer.getBytesToOffset());
    };

    const id$8 = 0x0d1f;
    const name$8 = 'getExAbsArchiveDaysMc';
    const COMMAND_BODY_MAX_SIZE$4 = 6124;
    const fromBytes$a = (data) => {
        const buffer = new CommandBinaryBuffer(data);
        const date = buffer.getDate();
        const channels = buffer.getChannels();
        const days = buffer.getUint8();
        const channelList = [];
        channels.forEach(channelIndex => {
            const dayList = [];
            const pulseCoefficient = buffer.getPulseCoefficient();
            channelList.push({
                pulseCoefficient,
                dayList,
                index: channelIndex
            });
            for (let day = 0; day < days; ++day) {
                dayList.push(buffer.getExtendedValue());
            }
        });
        return { channelList, days, startTime2000: getTime2000FromDate(date) };
    };
    const toBytes$9 = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$4);
        const { channelList, startTime2000, days } = parameters;
        buffer.setDate(startTime2000);
        buffer.setChannels(channelList);
        buffer.setUint8(days);
        channelList.forEach(({ pulseCoefficient, dayList }) => {
            buffer.setPulseCoefficient(pulseCoefficient);
            dayList.forEach(value => {
                buffer.setExtendedValue(value);
            });
        });
        return toBytes$v(id$8, buffer.getBytesToOffset());
    };

    const id$7 = 0x1a;
    const name$7 = 'getArchiveHoursMc';
    const COMMAND_BODY_MAX_SIZE$3 = 164;
    const fromBytes$9 = (data) => {
        const buffer = new CommandBinaryBuffer(data);
        return buffer.getChannelsValuesWithHourDiff();
    };
    const toBytes$8 = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$3);
        buffer.setChannelsValuesWithHourDiff(parameters.hours, parameters.startTime2000, parameters.channelList);
        return toBytes$v(id$7, buffer.getBytesToOffset());
    };

    const id$6 = 0x021f;
    const name$6 = 'getLmicInfo';
    const COMMAND_BODY_SIZE$2 = 2;
    const lmicCapabilitiesBitMask = {
        isMulticastSupported: 1 << 0,
        isFragmentedDataSupported: 1 << 1
    };
    const fromBytes$8 = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$2) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new BinaryBuffer(data);
        const capabilities = toObject(lmicCapabilitiesBitMask, buffer.getUint8());
        const version = buffer.getUint8();
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return { capabilities, version };
    };
    const toBytes$7 = (parameters) => {
        const { capabilities, version } = parameters;
        const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$2);
        buffer.setUint8(fromObject(lmicCapabilitiesBitMask, capabilities));
        buffer.setUint8(version);
        return toBytes$v(id$6, buffer.data);
    };

    const id$5 = 0x17;
    const name$5 = 'hourMc';
    const COMMAND_BODY_MAX_SIZE$2 = 164;
    const fromBytes$7 = (data) => {
        if (data.length > COMMAND_BODY_MAX_SIZE$2) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        return buffer.getChannelsValuesWithHourDiff();
    };
    const toBytes$6 = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$2);
        const { startTime2000, hours, channelList } = parameters;
        buffer.setChannelsValuesWithHourDiff(hours, startTime2000, channelList);
        return toBytes$v(id$5, buffer.getBytesToOffset());
    };

    const id$4 = 0x60;
    const name$4 = 'lastEvent';
    const fromBytes$6 = (data, config) => {
        if (!config.hardwareType) {
            throw new Error('hardwareType in config is mandatory');
        }
        const buffer = new CommandBinaryBuffer(data);
        const sequenceNumber = buffer.getUint8();
        const status = buffer.getEventStatus(config.hardwareType);
        return { sequenceNumber, status };
    };
    const toBytes$5 = (parameters, config) => {
        if (!config.hardwareType) {
            throw new Error('hardwareType in config is mandatory');
        }
        const buffer = new CommandBinaryBuffer(1 + getEventStatusSize(config.hardwareType));
        const { sequenceNumber, status } = parameters;
        buffer.setUint8(sequenceNumber);
        buffer.setEventStatus(config.hardwareType, status);
        return toBytes$v(id$4, buffer.data);
    };

    const MAGNET_ON = 1;
    const MAGNET_OFF = 2;
    const ACTIVATE = 3;
    const DEACTIVATE = 4;
    const BATTERY_ALARM = 5;
    const CAN_OFF = 6;
    const INSERT = 7;
    const REMOVE = 8;
    const COUNTER_OVER = 9;
    const ACTIVATE_MTX = 11;
    const CONNECT = 12;
    const DISCONNECT = 13;
    const OPTOLOW = 15;
    const OPTOFLASH = 16;
    const MTX = 17;
    const JOIN_ACCEPT = 18;

    var getHexFromBytes = (bytes, options = {}) => {
        const { separator, prefix } = Object.assign({}, hexFormatOptions, options);
        return bytes
            .map((byte) => `${prefix}${byte.toString(16).padStart(2, '0')}`)
            .join(separator);
    };

    var getBytesFromHex = (hex) => {
        let cleanHex = hex.replace(/\s+|0x/g, '');
        if (cleanHex.length % 2 !== 0) {
            cleanHex = `0${cleanHex}`;
        }
        const resultLength = cleanHex.length / 2;
        const bytes = new Array(resultLength);
        for (let index = 0; index < resultLength; index++) {
            bytes[index] = parseInt(cleanHex.substring(index * 2, index * 2 + 2), 16);
        }
        return bytes;
    };

    const id$3 = 0x15;
    const name$3 = 'newEvent';
    const COMMAND_BODY_MAX_SIZE$1 = 14;
    const MTX_ADDRESS_SIZE = 8;
    const getVoltage = (buffer) => buffer.getUint16(false);
    const setVoltage = (buffer, value) => buffer.setUint16(value, false);
    const getDeviceId = (buffer) => (getHexFromBytes(buffer.getBytes(MTX_ADDRESS_SIZE)));
    const setDeviceId = (buffer, value) => {
        getBytesFromHex(value).forEach(byte => buffer.setUint8(byte));
    };
    const fromBytes$5 = (data) => {
        if (data.length > COMMAND_BODY_MAX_SIZE$1) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        const eventId = buffer.getUint8();
        const sequenceNumber = buffer.getUint8();
        let eventData;
        switch (eventId) {
            case MAGNET_ON:
            case MAGNET_OFF:
            case ACTIVATE:
            case DEACTIVATE:
            case CAN_OFF:
            case INSERT:
            case REMOVE:
            case COUNTER_OVER:
            case OPTOLOW:
            case OPTOFLASH:
            case JOIN_ACCEPT:
                eventData = { time2000: buffer.getTime() };
                break;
            case BATTERY_ALARM:
                eventData = { voltage: getVoltage(buffer) };
                break;
            case ACTIVATE_MTX:
                eventData = { time2000: buffer.getTime(), deviceId: getDeviceId(buffer) };
                break;
            case CONNECT:
            case DISCONNECT:
                eventData = { channel: buffer.getUint8() + 1, value: buffer.getExtendedValue() };
                break;
            case MTX:
                eventData = { status: buffer.getEventStatus(MTXLORA) };
                break;
            default:
                throw new Error(`Event ${id$3} is not supported`);
        }
        return { id: eventId, sequenceNumber, data: eventData };
    };
    const toBytes$4 = (parameters) => {
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$1);
        const { id: eventId, sequenceNumber, data } = parameters;
        buffer.setUint8(eventId);
        buffer.setUint8(sequenceNumber);
        switch (eventId) {
            case MAGNET_ON:
            case MAGNET_OFF:
            case ACTIVATE:
            case DEACTIVATE:
            case CAN_OFF:
            case INSERT:
            case REMOVE:
            case COUNTER_OVER:
            case OPTOLOW:
            case OPTOFLASH:
            case JOIN_ACCEPT:
                buffer.setTime(data.time2000);
                break;
            case BATTERY_ALARM:
                setVoltage(buffer, data.voltage);
                break;
            case ACTIVATE_MTX:
                buffer.setTime(data.time2000);
                setDeviceId(buffer, data.deviceId);
                break;
            case CONNECT:
            case DISCONNECT:
                buffer.setUint8(data.channel - 1);
                buffer.setExtendedValue(data.value);
                break;
            case MTX:
                buffer.setEventStatus(MTXLORA, data.status);
                break;
            default:
                throw new Error(`Event ${id$3} is not supported`);
        }
        return toBytes$v(id$3, buffer.getBytesToOffset());
    };

    const id$2 = 0x02;
    const name$2 = 'setTime2000';
    const COMMAND_BODY_SIZE$1 = 1;
    const fromBytes$4 = (data) => {
        if (data.length !== COMMAND_BODY_SIZE$1) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new BinaryBuffer(data, false);
        const parameters = {
            status: buffer.getUint8()
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };
    const toBytes$3 = (parameters) => {
        const { status } = parameters;
        const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$1, false);
        buffer.setUint8(status);
        return toBytes$v(id$2, buffer.data);
    };

    var roundNumber = (value, decimalPlaces = 4) => {
        const places = Math.pow(10, decimalPlaces);
        return Math.round((value * places) * (1 + Number.EPSILON)) / places;
    };

    const id$1 = 0x14;
    const name$1 = 'status';
    const COMMAND_BODY_MAX_SIZE = 20;
    const UNKNOWN_BATTERY_RESISTANCE = 65535;
    const UNKNOWN_BATTERY_CAPACITY = 255;
    const fromBytes$3 = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        const software = { type: buffer.getUint8(), version: buffer.getUint8() };
        const hardware = { type: buffer.getUint8(), version: buffer.getUint8() };
        let data;
        switch (hardware.type) {
            case GASI1:
            case GASI2:
            case GASI3:
            case NOVATOR:
            case IMP2EU:
            case IMP4EU:
            case IMP2AS:
            case IMP2IN:
            case IMP4IN:
            case GASIC:
                {
                    const statusData = {
                        batteryVoltage: buffer.getBatteryVoltage(),
                        batteryInternalResistance: buffer.getUint16(false),
                        temperature: buffer.getUint8(),
                        remainingBatteryCapacity: buffer.getUint8(),
                        lastEventSequenceNumber: buffer.getUint8()
                    };
                    if (statusData.batteryInternalResistance === UNKNOWN_BATTERY_RESISTANCE) {
                        statusData.batteryInternalResistance = undefined;
                    }
                    if (statusData.remainingBatteryCapacity === UNKNOWN_BATTERY_CAPACITY) {
                        statusData.remainingBatteryCapacity = undefined;
                    }
                    else if (statusData.remainingBatteryCapacity !== undefined) {
                        statusData.remainingBatteryCapacity = roundNumber((statusData.remainingBatteryCapacity * 100) / (UNKNOWN_BATTERY_CAPACITY - 1), 0);
                    }
                    data = statusData;
                }
                break;
            case MTXLORA:
                data = {
                    time2000: buffer.getUint32(),
                    resetReason: buffer.getUint8(),
                    rssiLastDownlinkFrame: buffer.getUint8(),
                    snrLastDownlinkFrame: buffer.getUint8(),
                    downlinkRequestsNumber: buffer.getUint8(),
                    downlinkFragmentsNumber: buffer.getUint8(),
                    uplinkResponsesNumber: buffer.getUint8(),
                    uplinkFragmentsNumber: buffer.getUint8(),
                    signalMarginToGateway: buffer.getUint8(),
                    signalMarginFromGateway: buffer.getUint8(),
                    detectedGatewaysNumber: buffer.getUint8(),
                    gatewayDownlinkErrorRate: buffer.getUint8(),
                    lastEventSequenceNumber: buffer.getUint8()
                };
                break;
            case ELIMP:
            default:
                throw new Error(`${id$1}: hardware type ${hardware.type} is not supported`);
        }
        return { software, hardware, data };
    };
    const toBytes$2 = (parameters) => {
        const { software, hardware, data } = parameters;
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE);
        buffer.setUint8(software.type);
        buffer.setUint8(software.version);
        buffer.setUint8(hardware.type);
        buffer.setUint8(hardware.version);
        switch (hardware.type) {
            case GASI1:
            case GASI2:
            case GASI3:
            case NOVATOR:
            case IMP2EU:
            case IMP4EU:
            case IMP2AS:
            case IMP2IN:
            case IMP4IN:
            case GASIC:
                {
                    const statusData = data;
                    buffer.setBatteryVoltage(statusData.batteryVoltage);
                    if (statusData.batteryInternalResistance === undefined) {
                        buffer.setUint16(UNKNOWN_BATTERY_RESISTANCE, false);
                    }
                    else {
                        buffer.setUint16(statusData.batteryInternalResistance, false);
                    }
                    buffer.setUint8(statusData.temperature);
                    if (statusData.remainingBatteryCapacity === undefined) {
                        buffer.setUint8(UNKNOWN_BATTERY_CAPACITY);
                    }
                    else {
                        buffer.setUint8((UNKNOWN_BATTERY_CAPACITY - 1) * (statusData.remainingBatteryCapacity / 100));
                    }
                    buffer.setUint8(statusData.lastEventSequenceNumber);
                }
                break;
            case MTXLORA:
                {
                    const statusData = data;
                    buffer.setUint32(statusData.time2000);
                    buffer.setUint8(statusData.resetReason);
                    buffer.setUint8(statusData.rssiLastDownlinkFrame);
                    buffer.setUint8(statusData.snrLastDownlinkFrame);
                    buffer.setUint8(statusData.downlinkRequestsNumber);
                    buffer.setUint8(statusData.downlinkFragmentsNumber);
                    buffer.setUint8(statusData.uplinkResponsesNumber);
                    buffer.setUint8(statusData.uplinkFragmentsNumber);
                    buffer.setUint8(statusData.signalMarginToGateway);
                    buffer.setUint8(statusData.signalMarginFromGateway);
                    buffer.setUint8(statusData.detectedGatewaysNumber);
                    buffer.setUint8(statusData.gatewayDownlinkErrorRate);
                    buffer.setUint8(statusData.lastEventSequenceNumber);
                }
                break;
            case ELIMP:
            default:
                throw new Error(`${id$1}: hardware type ${hardware.type} is not supported`);
        }
        return toBytes$v(id$1, buffer.getBytesToOffset());
    };

    const id = 0x09;
    const name = 'time2000';
    const COMMAND_BODY_SIZE = 5;
    const fromBytes$2 = (data) => {
        if (data.length !== COMMAND_BODY_SIZE) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        const buffer = new CommandBinaryBuffer(data);
        const parameters = {
            sequenceNumber: buffer.getUint8(),
            time2000: buffer.getTime()
        };
        if (!buffer.isEmpty) {
            throw new Error('BinaryBuffer is not empty.');
        }
        return parameters;
    };
    function toBytes$1(parameters) {
        const { sequenceNumber, time2000 } = parameters;
        const buffer = new CommandBinaryBuffer(COMMAND_BODY_SIZE);
        buffer.setUint8(sequenceNumber);
        buffer.setTime(time2000);
        return toBytes$v(id, buffer.data);
    }

    const toBytesMap = {};
    const fromBytesMap = {};
    const nameMap = {};
    const fromBytes$1 = getFromBytes(fromBytesMap, nameMap);
    toBytesMap[id$g] = toBytes$h;
    toBytesMap[id$f] = toBytes$g;
    toBytesMap[id$e] = toBytes$f;
    toBytesMap[id$d] = toBytes$e;
    toBytesMap[id$c] = toBytes$d;
    toBytesMap[id$b] = toBytes$c;
    toBytesMap[id$a] = toBytes$b;
    toBytesMap[id$9] = toBytes$a;
    toBytesMap[id$8] = toBytes$9;
    toBytesMap[id$7] = toBytes$8;
    toBytesMap[id$6] = toBytes$7;
    toBytesMap[id$5] = toBytes$6;
    toBytesMap[id$4] = toBytes$5;
    toBytesMap[id$3] = toBytes$4;
    toBytesMap[id$2] = toBytes$3;
    toBytesMap[id$1] = toBytes$2;
    toBytesMap[id] = toBytes$1;
    fromBytesMap[id$g] = fromBytes$i;
    fromBytesMap[id$f] = fromBytes$h;
    fromBytesMap[id$e] = fromBytes$g;
    fromBytesMap[id$d] = fromBytes$f;
    fromBytesMap[id$c] = fromBytes$e;
    fromBytesMap[id$b] = fromBytes$d;
    fromBytesMap[id$a] = fromBytes$c;
    fromBytesMap[id$9] = fromBytes$b;
    fromBytesMap[id$8] = fromBytes$a;
    fromBytesMap[id$7] = fromBytes$9;
    fromBytesMap[id$6] = fromBytes$8;
    fromBytesMap[id$5] = fromBytes$7;
    fromBytesMap[id$4] = fromBytes$6;
    fromBytesMap[id$3] = fromBytes$5;
    fromBytesMap[id$2] = fromBytes$4;
    fromBytesMap[id$1] = fromBytes$3;
    fromBytesMap[id] = fromBytes$2;
    nameMap[id$g] = name$g;
    nameMap[id$f] = name$f;
    nameMap[id$e] = name$e;
    nameMap[id$d] = name$d;
    nameMap[id$c] = name$c;
    nameMap[id$b] = name$b;
    nameMap[id$a] = name$a;
    nameMap[id$9] = name$9;
    nameMap[id$8] = name$8;
    nameMap[id$7] = name$7;
    nameMap[id$6] = name$6;
    nameMap[id$5] = name$5;
    nameMap[id$4] = name$4;
    nameMap[id$3] = name$3;
    nameMap[id$2] = name$2;
    nameMap[id$1] = name$1;
    nameMap[id] = name;

    // export
    fromBytes = fromBytes$1;
    toBytes = toBytes$i;

})();
//#endregion
