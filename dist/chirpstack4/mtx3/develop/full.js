// encoded message should be less than this size
// to be able to send to a device
const MAX_DATA_SEGMENT_SIZE = 50;


/*
  Get message form bytes.

  Input is an object with the following fields:
    * bytes - byte array containing the uplink payload, e.g. [255, 230, 255, 0]
    * fPort - uplink fPort
    * variables - object containing the configured device variables

  Output must be an object with the following fields:
    * data - object representing the decoded payload
*/
function decodeUplink ( input ) {
    const segment = getDataSegment(input.bytes)

    // just a single data segment
    if ( segment ) {
        const message = fromBytes(segment);

        // there may be a message.error (e.g. mismatched LRC)
        // in that case message.message will contain everything parsed successfully
        // it should be used with caution

        return {data: message.message || message};
    }

    return {data: null};
};


/*
  Get payload bytes from commands.

  Input is an object with the following fields:
    * data - object representing the payload that must be encoded
    * variables - object containing the configured device variables

  Output must be an object with the following fields:
    * bytes - byte array containing the downlink payload
*/
function encodeDownlink ( input ) {
    const bytes = toBytes(input.data.commands);

    // send nothing if not fit in a single data segment
    if ( bytes.length > MAX_DATA_SEGMENT_SIZE ) {
        return {bytes: []};
    }

    return {
        bytes: setDataSegment(bytes)
    };
};


//#region [autogenerated jooby-codec bundle from index.js]
var fromBytes, toBytes, getDataSegment, setDataSegment;

(function () {
    'use strict';

    const hexFormatOptions = {
        separator: ' ',
        prefix: ''
    };

    const INT8_SIZE = 1;
    const INT16_SIZE = 2;
    const INT24_SIZE = 3;
    const INT32_SIZE = 4;
    const { log, pow, LN2 } = Math;
    const readFloat = (buffer, offset, isLittleEndian, mLen, bytes) => {
        var e, m, eLen = bytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLittleEndian ? bytes - 1 : 0, d = isLittleEndian ? -1 : 1, s = buffer[offset + i];
        i += d;
        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 0x100 + buffer[offset + i], i += d, nBits -= 8)
            ;
        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 0x100 + buffer[offset + i], i += d, nBits -= 8)
            ;
        if (e === 0) {
            e = 1 - eBias;
        }
        else if (e === eMax) {
            return m ? NaN : s ? -Infinity : Infinity;
        }
        else {
            m = m + pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * pow(2, e - mLen);
    };
    const writeFloat = (buffer, offset, value, isLittleEndian, mLen, bytes) => {
        var e, m, c, eLen = bytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = (mLen === 23 ? pow(2, -24) - pow(2, -77) : 0), i = isLittleEndian ? 0 : bytes - 1, d = isLittleEndian ? 1 : -1, s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
        value < 0 && (value = -value);
        if (value !== value || value === Infinity) {
            m = value !== value ? 1 : 0;
            e = eMax;
        }
        else {
            e = (log(value) / LN2) | 0;
            if (value * (c = pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            }
            else {
                value += rt * pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }
            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            }
            else if (e + eBias >= 1) {
                m = (value * c - 1) * pow(2, mLen);
                e = e + eBias;
            }
            else {
                m = value * pow(2, eBias - 1) * pow(2, mLen);
                e = 0;
            }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 0x100, mLen -= 8)
            ;
        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 0x100, eLen -= 8)
            ;
        buffer[offset + i - d] |= s * 0x80;
    };
    const be2 = [1, 0];
    const be3 = [2, 1, 0];
    const be4 = [3, 2, 1, 0];
    const le2 = [0, 1];
    const le3 = [0, 1, 2];
    const le4 = [0, 1, 2, 3];
    const readUint8 = (buffer, offset) => buffer[offset];
    const readUint16 = (buffer, offset, isLittleEndian) => {
        const order = isLittleEndian ? le2 : be2;
        const b0 = buffer[offset + order[0]];
        const b1 = buffer[offset + order[1]] << 8;
        return b0 | b1;
    };
    const readUint24 = (buffer, offset, isLittleEndian) => {
        const order = isLittleEndian ? le3 : be3;
        const b0 = buffer[offset + order[0]];
        const b1 = buffer[offset + order[1]] << 8;
        const b2 = buffer[offset + order[2]] << 16;
        return b0 | b1 | b2;
    };
    const readUint32 = (buffer, offset, isLittleEndian) => {
        const order = isLittleEndian ? le4 : be4;
        const b0 = buffer[offset + order[3]] * 0x1000000;
        const b1 = buffer[offset + order[2]] * 0x10000;
        const b2 = buffer[offset + order[1]] * 0x100;
        const b3 = buffer[offset + order[0]];
        return b0 + b1 + b2 + b3;
    };
    const writeUint8 = (buffer, offset, value) => {
        buffer[offset] = value & 0xff;
    };
    const writeUint16 = (buffer, offset, value, isLittleEndian) => {
        const order = isLittleEndian ? le2 : be2;
        buffer[offset + order[0]] = value & 0xff;
        buffer[offset + order[1]] = value >>> 8 & 0xff;
    };
    const writeUint24 = (buffer, offset, value, isLittleEndian) => {
        const order = isLittleEndian ? le3 : be3;
        buffer[offset + order[0]] = value & 0xff;
        buffer[offset + order[1]] = value >>> 8 & 0xff;
        buffer[offset + order[2]] = value >>> 16 & 0xff;
    };
    const writeUint32 = (buffer, offset, value, isLittleEndian) => {
        const order = isLittleEndian ? le4 : be4;
        buffer[offset + order[0]] = value & 0xff;
        buffer[offset + order[1]] = value >>> 8 & 0xff;
        buffer[offset + order[2]] = value >>> 16 & 0xff;
        buffer[offset + order[3]] = value >>> 24 & 0xff;
    };
    function BinaryBuffer(dataOrLength, isLittleEndian = true) {
        if (typeof dataOrLength === 'number') {
            const bytes = new Array(dataOrLength).fill(0);
            this.data = bytes;
        }
        else {
            this.data = dataOrLength;
        }
        this.offset = 0;
        this.isLittleEndian = isLittleEndian;
    }
    BinaryBuffer.prototype = {
        toUint8Array() {
            return this.data;
        },
        seek(position) {
            if (position < 0 || position >= this.data.length) {
                throw new Error('Invalid position.');
            }
            this.offset = position;
        },
        setInt8(value) {
            writeUint8(this.data, this.offset, value < 0 ? value | 0x100 : value);
            this.offset += INT8_SIZE;
        },
        getInt8() {
            const result = readUint8(this.data, this.offset);
            this.offset += INT8_SIZE;
            return result & 0x80 ? result ^ -256 : result;
        },
        setUint8(value) {
            writeUint8(this.data, this.offset, value);
            this.offset += INT8_SIZE;
        },
        getUint8() {
            const result = readUint8(this.data, this.offset);
            this.offset += INT8_SIZE;
            return result;
        },
        setInt16(value, isLittleEndian = this.isLittleEndian) {
            writeUint16(this.data, this.offset, value < 0 ? value | 0x10000 : value, isLittleEndian);
            this.offset += INT16_SIZE;
        },
        getInt16(isLittleEndian = this.isLittleEndian) {
            const result = readUint16(this.data, this.offset, isLittleEndian);
            this.offset += INT16_SIZE;
            return result & 0x8000 ? result ^ -65536 : result;
        },
        setUint16(value, isLittleEndian = this.isLittleEndian) {
            writeUint16(this.data, this.offset, value, isLittleEndian);
            this.offset += INT16_SIZE;
        },
        getUint16(isLittleEndian = this.isLittleEndian) {
            const result = readUint16(this.data, this.offset, isLittleEndian);
            this.offset += INT16_SIZE;
            return result;
        },
        setInt24(value, isLittleEndian = this.isLittleEndian) {
            writeUint24(this.data, this.offset, value < 0 ? value | 0x1000000 : value, isLittleEndian);
            this.offset += INT24_SIZE;
        },
        getInt24(isLittleEndian = this.isLittleEndian) {
            const result = readUint24(this.data, this.offset, isLittleEndian);
            this.offset += INT24_SIZE;
            return result & 0x800000 ? result ^ -16777216 : result;
        },
        setUint24(value, isLittleEndian = this.isLittleEndian) {
            writeUint24(this.data, this.offset, value, isLittleEndian);
            this.offset += INT24_SIZE;
        },
        getUint24(isLittleEndian = this.isLittleEndian) {
            const result = readUint24(this.data, this.offset, isLittleEndian);
            this.offset += INT24_SIZE;
            return result;
        },
        setInt32(value, isLittleEndian = this.isLittleEndian) {
            writeUint32(this.data, this.offset, value < 0 ? value | 0x100000000 : value, isLittleEndian);
            this.offset += INT32_SIZE;
        },
        getInt32(isLittleEndian = this.isLittleEndian) {
            const result = readUint32(this.data, this.offset, isLittleEndian);
            this.offset += INT32_SIZE;
            return result & 0x80000000 ? result ^ -4294967296 : result;
        },
        setUint32(value, isLittleEndian = this.isLittleEndian) {
            writeUint32(this.data, this.offset, value, isLittleEndian);
            this.offset += INT32_SIZE;
        },
        getUint32(isLittleEndian = this.isLittleEndian) {
            const result = readUint32(this.data, this.offset, isLittleEndian);
            this.offset += INT32_SIZE;
            return result;
        },
        setFloat32(value, isLittleEndian = this.isLittleEndian) {
            writeFloat(this.data, this.offset, value, isLittleEndian, 23, 4);
            this.offset += INT32_SIZE;
        },
        getFloat32(isLittleEndian = this.isLittleEndian) {
            const result = readFloat(this.data, this.offset, isLittleEndian, 23, 4);
            this.offset += INT32_SIZE;
            return result;
        },
        setString(value) {
            this.setUint8(value.length);
            for (let index = 0; index < value.length; ++index) {
                this.setUint8(value.charCodeAt(index));
            }
        },
        getString() {
            const size = this.getUint8();
            const endIndex = this.offset + size;
            const chars = [];
            while (this.offset < endIndex) {
                chars.push(String.fromCharCode(this.getUint8()));
            }
            return chars.join('');
        },
        getBytesToOffset(offset = this.offset) {
            return this.data.slice(0, offset);
        },
        getBytesLeft() {
            return this.getBytes(this.bytesLeft);
        },
        getBytes(length, offset = this.offset) {
            this.offset = offset + length;
            return this.data.slice(offset, this.offset);
        },
        setBytes(data, offset = this.offset) {
            const bytes = this.data;
            bytes.splice(offset, data.length, ...data);
            this.data = bytes;
            this.offset = offset + data.length;
        }
    };
    Object.defineProperties(BinaryBuffer.prototype, {
        size: {
            get() {
                return this.data.length;
            }
        },
        isEmpty: {
            get() {
                if (this.offset > this.data.length) {
                    throw new Error(`current offset ${this.offset} is outside the bounds of the buffer`);
                }
                return this.data.length - this.offset === 0;
            }
        },
        bytesLeft: {
            get() {
                return this.data.length - this.offset;
            }
        },
        position: {
            get() {
                return this.offset;
            }
        }
    });

    const fromObject = (bitMask = {}, booleanObject = {}) => {
        let result = 0;
        for (const name in booleanObject) {
            if (name in bitMask && booleanObject[name]) {
                result |= bitMask[name];
            }
        }
        return result;
    };
    const toObject = (bitMask = {}, value = 0) => {
        const result = {};
        for (const name in bitMask) {
            result[name] = (value & bitMask[name]) !== 0;
        }
        return result;
    };
    const extractBits = (value, bitsNumber, startIndex) => (((1 << bitsNumber) - 1) & (value >> (startIndex - 1)));
    const fillBits = (value, bitsNumber, startIndex, valueToSet) => {
        const mask = ((1 << bitsNumber) - 1) << (startIndex - 1);
        let newValueToSet = valueToSet;
        let result = value;
        result &= ~mask;
        newValueToSet <<= (startIndex - 1);
        result |= newValueToSet;
        return result;
    };

    var getBytesFromHex = (hex) => {
        let cleanHex = hex.trim();
        if (!cleanHex) {
            return [];
        }
        cleanHex = cleanHex
            .replace(/0x/g, '')
            .split(/\s+/)
            .map(byte => byte.padStart(2, '0'))
            .join('');
        if (cleanHex.length % 2 !== 0) {
            cleanHex = `0${cleanHex}`;
        }
        const resultLength = cleanHex.length / 2;
        const bytes = new Array(resultLength);
        for (let index = 0; index < resultLength; index++) {
            bytes[index] = parseInt(cleanHex.substring(index * 2, index * 2 + 2), 16);
        }
        return bytes;
    };

    const DEVICE_TYPE_INVALID_CHAR = 'x';
    const nibbles1 = ['.', '1', '3', 'R', 'M'];
    const nibbles2 = ['.', 'A', 'G', 'R', 'T', 'D'];
    const nibbles3 = ['.', '0', '1', '2', '3', '4', '5'];
    const nibbles4 = ['.', 'A', 'B', 'C', 'D', 'E', 'F'];
    const nibbles5 = ['.', 'A', 'B', 'C', 'D', 'E', 'F', 'H', 'K', 'G'];
    const nibbles6 = ['.', '1', '2', '3', '4'];
    const nibbles7 = ['.', 'L', 'M', 'Z', 'K'];
    const nibbles8 = ['.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
    const nibbles9 = ['.', 'D', 'B', 'C', 'E', 'P', 'R', 'O', 'L', 'F', 'S', 'M', 'Y', 'G', 'N', 'U'];
    const nibbles10 = ['.', '0', '1', '2', '3', '4', '5', '6', 'P', 'R', 'L', 'E', 'G', '-', '/'];
    const nibbles11 = ['.', 'H', 'A', 'T', '0', '0', '0', '0', '0', '1', '2', '3', '4', '0', '0', '0'];
    const nibbles12 = ['.', '0', '1', '2', '3', '4', '5', '6', '7', '8', 'I', 'X', 'G', 'W', 'M', '-'];
    const splitByte = (byte) => [
        byte >> 4,
        byte & 0x0F
    ];
    const splitToNibbles = (data) => {
        const result = new Array(data.length * 2).fill(0);
        data.forEach((byte, index) => {
            const [high, low] = splitByte(byte);
            result[index * 2] = high;
            result[index * 2 + 1] = low;
        });
        return result;
    };
    const joinNibbles = (nibbles) => {
        const hex = [];
        nibbles.forEach(nibble => hex.push(nibble.toString(16)));
        if (nibbles.length & 1) {
            hex.push('0');
        }
        return getBytesFromHex(hex.join(''));
    };
    const fromBytesMtx = (nibbles) => {
        if (nibbles.length !== 14 && nibbles.length !== 16) {
            throw new Error('Device type bytes wrong size');
        }
        const type = ['MTX '];
        type.push(nibbles1[nibbles[0]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(nibbles2[nibbles[1]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(nibbles3[nibbles[2]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(nibbles3[nibbles[3]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push('.');
        type.push(nibbles4[nibbles[4]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(nibbles5[nibbles[5]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push('.');
        type.push(nibbles6[nibbles[6]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(nibbles7[nibbles[7]] ?? DEVICE_TYPE_INVALID_CHAR);
        const revision = nibbles[8];
        type.push(nibbles8[nibbles[9]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push('-');
        let deviceProtocolIndex;
        if (nibbles.length < 14 || (nibbles[12] === 0 && nibbles[13] === 0)) {
            type.push(nibbles9[nibbles[10]] ?? DEVICE_TYPE_INVALID_CHAR);
            deviceProtocolIndex = 11;
        }
        else if (nibbles[13] === 0) {
            type.push(nibbles9[nibbles[10]] ?? DEVICE_TYPE_INVALID_CHAR);
            type.push(nibbles9[nibbles[11]] ?? DEVICE_TYPE_INVALID_CHAR);
            deviceProtocolIndex = 12;
        }
        else {
            type.push(nibbles9[nibbles[10]] ?? DEVICE_TYPE_INVALID_CHAR);
            type.push(nibbles9[nibbles[11]] ?? DEVICE_TYPE_INVALID_CHAR);
            type.push(nibbles9[nibbles[12]] ?? DEVICE_TYPE_INVALID_CHAR);
            deviceProtocolIndex = 13;
        }
        const deviceProtocolNibble = nibbles[deviceProtocolIndex];
        if (deviceProtocolNibble && deviceProtocolNibble !== 0) {
            type.push(nibbles11[deviceProtocolNibble] ?? DEVICE_TYPE_INVALID_CHAR);
        }
        return {
            type: type.join(''),
            revision,
            meterType: 0
        };
    };
    const toBytesMtx = (type, prefix, revision) => {
        const nibbles = [];
        if (type.length < 11) {
            throw new Error('Wrong format');
        }
        nibbles.push(nibbles1.indexOf(type[0]));
        nibbles.push(nibbles2.indexOf(type[1]));
        nibbles.push(nibbles3.indexOf(type[2]));
        nibbles.push(nibbles3.indexOf(type[3]));
        if (type[4] !== '.') {
            throw new Error('Wrong format');
        }
        nibbles.push(nibbles4.indexOf(type[5]));
        nibbles.push(nibbles5.indexOf(type[6]));
        if (type[7] !== '.') {
            throw new Error('Wrong format');
        }
        nibbles.push(nibbles6.indexOf(type[8]));
        nibbles.push(nibbles7.indexOf(type[9]));
        nibbles.push(revision ?? 0);
        nibbles.push(nibbles8.indexOf(type[10]));
        if (type[11] !== '-') {
            throw new Error('Wrong format');
        }
        const deviceProtocolIndex = type.length > 13 ? type.length - 1 : type.length;
        for (let index = 12; index < deviceProtocolIndex; index++) {
            nibbles.push(nibbles9.indexOf(type[index]));
        }
        if (deviceProtocolIndex < type.length) {
            nibbles.push(nibbles11.indexOf(type[deviceProtocolIndex]));
        }
        const bytes = joinNibbles(nibbles);
        const result = new Array(9).fill(0);
        result[0] = 0;
        for (let index = 0; index < bytes.length; index++) {
            result[index + (bytes.length < 8 ? 1 : 0)] = bytes[index];
        }
        return result;
    };
    const fromBytesMtx2 = (nibbles) => {
        if (nibbles.length < 14) {
            throw new Error('The buffer is too small');
        }
        const type = ['MTX '];
        const separator = nibbles[1] === 5 ? '-' : ' ';
        type.push(nibbles1[nibbles[0]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(nibbles2[nibbles[1]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(separator);
        for (let index = 2; index < nibbles.length; index++) {
            if (nibbles[index] !== 0) {
                type.push(nibbles10[nibbles[index]] ?? DEVICE_TYPE_INVALID_CHAR);
            }
        }
        return {
            type: type.join(''),
            meterType: 0
        };
    };
    const toBytesMtx2 = (type) => {
        if (type.length < 3) {
            throw new Error('Wrong format');
        }
        const nibbles = [];
        nibbles.push(nibbles1.indexOf(type[0]));
        nibbles.push(nibbles2.indexOf(type[1]));
        for (let index = 3; index < type.length; index++) {
            nibbles.push(nibbles10.indexOf(type[index]));
        }
        const bytes = joinNibbles(nibbles);
        if (bytes.length === 8) {
            return bytes;
        }
        if (bytes.length > 8) {
            throw new Error('Wrong format');
        }
        const result = new Array(8).fill(0);
        for (let index = 0; index < bytes.length; index++) {
            result[index] = bytes[index];
        }
        return result;
    };
    const fromBytesM = (nibbles) => {
        if (nibbles.length < 14) {
            throw new Error('The buffer is too small');
        }
        const type = [];
        type.push(nibbles1[nibbles[0]] ?? DEVICE_TYPE_INVALID_CHAR);
        for (let index = 1; index < nibbles.length; index++) {
            if (nibbles[index] !== 0) {
                type.push(nibbles12[nibbles[index]] ?? DEVICE_TYPE_INVALID_CHAR);
            }
        }
        return {
            type: type.join(''),
            meterType: 0
        };
    };
    const toBytesM = (type) => {
        if (type.length < 1) {
            throw new Error('Wrong format');
        }
        const nibbles = [];
        nibbles.push(nibbles1.indexOf(type[0]));
        for (let index = 1; index < type.length; index++) {
            nibbles.push(nibbles12.indexOf(type[index]));
        }
        const bytes = joinNibbles(nibbles);
        const result = new Array(8).fill(0);
        for (let index = 0; index < bytes.length && index < 8; index++) {
            result[index] = bytes[index];
        }
        return result;
    };
    const fromBytes$2g = (bytes) => {
        if (bytes.length !== 9) {
            throw new Error('The buffer is too small');
        }
        let result;
        const reserve = [0x00, 0x05, 0x06, 0x07, 0x09, 0x7f, 0xef];
        const position = reserve.indexOf(bytes[0]) !== -1 ? 2 : 0;
        const nibbles = splitToNibbles(bytes.slice(0, 8));
        const deviceTypeNibble = nibbles[position];
        const deviceType = nibbles1[deviceTypeNibble];
        if (deviceType === '1' || deviceType === '3') {
            result = fromBytesMtx(nibbles.slice(position));
        }
        else {
            result = deviceType === 'M'
                ? fromBytesM(nibbles)
                : fromBytesMtx2(nibbles);
        }
        result.meterType = bytes[8];
        return result;
    };
    const toBytes$2h = ({ type, revision, meterType }, prefix) => {
        if (!type.startsWith('MTX ')) {
            throw new Error('Wrong format');
        }
        let result;
        const content = type.substring(4);
        const deviceTypeSymbol = type[4];
        if (deviceTypeSymbol === '1' || deviceTypeSymbol === '3') {
            result = toBytesMtx(content, prefix, revision);
        }
        else {
            result = deviceTypeSymbol === 'M'
                ? toBytesM(content)
                : toBytesMtx2(content);
        }
        result[8] = meterType;
        return result;
    };

    var getHexFromBytes = (bytes, options = {}) => {
        const { separator, prefix } = Object.assign({}, hexFormatOptions, options);
        return bytes
            .map((byte) => `${prefix}${byte.toString(16).padStart(2, '0')}`)
            .join(separator);
    };

    const DATA_REQUEST = 0x50;
    const DATA_RESPONSE = 0x51;
    const IDENT_REQUEST = 0x52;
    const IDENT_RESPONSE = 0x53;
    const L2_SET_ADDRESS_REQUEST = 0x54;
    const L2_SET_ADDRESS_RESPONSE = 0x55;
    const L2_CHECK_ADDRESS_REQUEST = 0x56;
    const L2_CHECK_ADDRESS_RESPONSE = 0x57;
    const L2_RM_ADDRESS_REQUEST = 0x58;
    const L2_RM_ADDRESS_RESPONSE = 0x59;
    const FRAGMENT_REQUEST = 0x5A;
    const FRAGMENT_RESPONSE = 0x5B;
    const INVALID = 0xFF;

    var frameTypes = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DATA_REQUEST: DATA_REQUEST,
        DATA_RESPONSE: DATA_RESPONSE,
        FRAGMENT_REQUEST: FRAGMENT_REQUEST,
        FRAGMENT_RESPONSE: FRAGMENT_RESPONSE,
        IDENT_REQUEST: IDENT_REQUEST,
        IDENT_RESPONSE: IDENT_RESPONSE,
        INVALID: INVALID,
        L2_CHECK_ADDRESS_REQUEST: L2_CHECK_ADDRESS_REQUEST,
        L2_CHECK_ADDRESS_RESPONSE: L2_CHECK_ADDRESS_RESPONSE,
        L2_RM_ADDRESS_REQUEST: L2_RM_ADDRESS_REQUEST,
        L2_RM_ADDRESS_RESPONSE: L2_RM_ADDRESS_RESPONSE,
        L2_SET_ADDRESS_REQUEST: L2_SET_ADDRESS_REQUEST,
        L2_SET_ADDRESS_RESPONSE: L2_SET_ADDRESS_RESPONSE
    });

    var invertObject = (source) => {
        const target = {};
        for (const property in source) {
            const value = source[property];
            target[value] = property;
        }
        return target;
    };

    var frameNames = invertObject(frameTypes);

    const ENERGY_REG_FAULT = 0x01;
    const VENDOR_PAR_FAULT = 0x02;
    const OP_PAR_FAULT = 0x03;
    const ACCESS_CLOSED = 0x10;
    const ERR_ACCESS$1 = 0x11;
    const CASE_OPEN$2 = 0x12;
    const CASE_CLOSE$1 = 0x13;
    const MAGNETIC_ON$2 = 0x14;
    const MAGNETIC_OFF$1 = 0x15;
    const CHANGE_ACCESS_KEY0$1 = 0x20;
    const CHANGE_ACCESS_KEY1$1 = 0x21;
    const CHANGE_ACCESS_KEY2$1 = 0x22;
    const CHANGE_ACCESS_KEY3$1 = 0x23;
    const CHANGE_PAR_LOCAL = 0x24;
    const CHANGE_PAR_REMOTE = 0x25;
    const CMD_CHANGE_TIME$1 = 0x26;
    const CMD_RELAY_ON$1 = 0x27;
    const CMD_RELAY_OFF$1 = 0x28;
    const CHANGE_COR_TIME$1 = 0x29;
    const ENERGY_REG_OVERFLOW = 0x31;
    const CHANGE_TARIFF_TBL = 0x32;
    const SET_TARIFF_TBL = 0x33;
    const SUMMER_TIME$1 = 0x34;
    const WINTER_TIME$1 = 0x35;
    const RELAY_ON$1 = 0x36;
    const RELAY_OFF$1 = 0x37;
    const RESTART$2 = 0x38;
    const WD_RESTART$1 = 0x39;
    const V_MAX_OK = 0x40;
    const V_MAX_OVER = 0x41;
    const V_MIN_OK = 0x42;
    const V_MIN_OVER = 0x43;
    const T_MAX_OK$1 = 0x44;
    const T_MAX_OVER$1 = 0x45;
    const T_MIN_OK$1 = 0x46;
    const T_MIN_OVER = 0x47;
    const F_MAX_OK$1 = 0x48;
    const F_MAX_OVER$1 = 0x49;
    const F_MIN_OK$1 = 0x4A;
    const F_MIN_OVER = 0x4B;
    const I_MAX_OK = 0x4C;
    const I_MAX_OVER = 0x4D;
    const P_MAX_OK = 0x4E;
    const P_MAX_OVER = 0x4F;
    const POWERSALDO_OK = 0x50;
    const POWERSALDO_OVER = 0x51;
    const BAT_OK = 0x52;
    const BAT_FAULT = 0x53;
    const CAL_OK = 0x54;
    const CAL_FAULT = 0x55;
    const CLOCK_OK$1 = 0x56;
    const CLOCK_FAULT$1 = 0x57;
    const POWER_A_OFF$1 = 0x58;
    const POWER_A_ON$1 = 0x59;
    const CMD_RELAY_2_ON$1 = 0x60;
    const CMD_RELAY_2_OFF$1 = 0x61;
    const CROSSZERO_ENT0 = 0x62;
    const CROSSZERO_ENT1 = 0x63;
    const CROSSZERO_ENT2 = 0x64;
    const CROSSZERO_ENT3 = 0x65;
    const CALFLAG_SET = 0x66;
    const CALFLAG_RESET = 0x67;
    const BAD_TEST_EEPROM$1 = 0x68;
    const BAD_TEST_FRAM$1 = 0x69;
    const SET_NEW_SALDO$1 = 0x70;
    const SALDO_PARAM_BAD$1 = 0x71;
    const ACCPARAM_BAD = 0x72;
    const ACCPARAM_EXT_BAD = 0x73;
    const CALC_PERIOD_BAD = 0x74;
    const BLOCK_TARIFF_BAD$1 = 0x75;
    const CALIBR_PARAM_BAD = 0x76;
    const WINTER_SUMMER_BAD$1 = 0x77;
    const SALDO_EN_BAD = 0x78;
    const TIME_CORRECT$2 = 0x79;
    const CASE_TERMINAL_OPEN$1 = 0x7A;
    const CASE_TERMINAL_CLOSE = 0x7B;
    const CASE_MODULE_OPEN$2 = 0x7C;
    const CASE_MODULE_CLOSE$1 = 0x7D;
    const RELAY_HARD_BAD_OFF$1 = 0x90;
    const RELAY_HARD_ON$1 = 0x91;
    const RELAY_HARD_BAD_ON$1 = 0x93;
    const RELAY_HARD_OFF$1 = 0x94;
    const SET_SALDO_PARAM$1 = 0x9C;
    const POWER_OVER_RELAY_OFF$1 = 0x9D;
    const CROSSZERO_EXP_ENT0 = 0x9E;
    const CROSSZERO_EXP_ENT1 = 0x9F;
    const CROSSZERO_EXP_ENT2 = 0xA0;
    const CROSSZERO_EXP_ENT3 = 0xA1;
    const TIME_CORRECT_NEW = 0xA2;
    const EM_MAGNETIC_ON$1 = 0xB0;
    const EM_MAGNETIC_OFF$1 = 0xB1;
    const CURRENT_UNEQUIL_FAULT = 0xB2;
    const CURRENT_UNEQUIL_OK = 0xB3;
    const BIPOLAR_POWER_FAULT = 0xB4;
    const BIPOLAR_POWER_OK = 0xB5;
    const RESET_EM_FLAG$1 = 0xB6;
    const RESET_MAGN_FLAG = 0xB7;
    const NVRAM_FAULT = 0xD0;
    const SET_DEMAND_EN_1MIN = 0xE0;
    const SET_DEMAND_EN_3MIN = 0xE1;
    const SET_DEMAND_EN_5MIN = 0xE2;
    const SET_DEMAND_EN_10MIN = 0xE3;
    const SET_DEMAND_EN_15MIN = 0xE4;
    const SET_DEMAND_EN_30MIN = 0xE5;
    const SET_DEMAND_EN_60MIN = 0xE6;

    var events$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACCESS_CLOSED: ACCESS_CLOSED,
        ACCPARAM_BAD: ACCPARAM_BAD,
        ACCPARAM_EXT_BAD: ACCPARAM_EXT_BAD,
        BAD_TEST_EEPROM: BAD_TEST_EEPROM$1,
        BAD_TEST_FRAM: BAD_TEST_FRAM$1,
        BAT_FAULT: BAT_FAULT,
        BAT_OK: BAT_OK,
        BIPOLAR_POWER_FAULT: BIPOLAR_POWER_FAULT,
        BIPOLAR_POWER_OK: BIPOLAR_POWER_OK,
        BLOCK_TARIFF_BAD: BLOCK_TARIFF_BAD$1,
        CALC_PERIOD_BAD: CALC_PERIOD_BAD,
        CALFLAG_RESET: CALFLAG_RESET,
        CALFLAG_SET: CALFLAG_SET,
        CALIBR_PARAM_BAD: CALIBR_PARAM_BAD,
        CAL_FAULT: CAL_FAULT,
        CAL_OK: CAL_OK,
        CASE_CLOSE: CASE_CLOSE$1,
        CASE_MODULE_CLOSE: CASE_MODULE_CLOSE$1,
        CASE_MODULE_OPEN: CASE_MODULE_OPEN$2,
        CASE_OPEN: CASE_OPEN$2,
        CASE_TERMINAL_CLOSE: CASE_TERMINAL_CLOSE,
        CASE_TERMINAL_OPEN: CASE_TERMINAL_OPEN$1,
        CHANGE_ACCESS_KEY0: CHANGE_ACCESS_KEY0$1,
        CHANGE_ACCESS_KEY1: CHANGE_ACCESS_KEY1$1,
        CHANGE_ACCESS_KEY2: CHANGE_ACCESS_KEY2$1,
        CHANGE_ACCESS_KEY3: CHANGE_ACCESS_KEY3$1,
        CHANGE_COR_TIME: CHANGE_COR_TIME$1,
        CHANGE_PAR_LOCAL: CHANGE_PAR_LOCAL,
        CHANGE_PAR_REMOTE: CHANGE_PAR_REMOTE,
        CHANGE_TARIFF_TBL: CHANGE_TARIFF_TBL,
        CLOCK_FAULT: CLOCK_FAULT$1,
        CLOCK_OK: CLOCK_OK$1,
        CMD_CHANGE_TIME: CMD_CHANGE_TIME$1,
        CMD_RELAY_2_OFF: CMD_RELAY_2_OFF$1,
        CMD_RELAY_2_ON: CMD_RELAY_2_ON$1,
        CMD_RELAY_OFF: CMD_RELAY_OFF$1,
        CMD_RELAY_ON: CMD_RELAY_ON$1,
        CROSSZERO_ENT0: CROSSZERO_ENT0,
        CROSSZERO_ENT1: CROSSZERO_ENT1,
        CROSSZERO_ENT2: CROSSZERO_ENT2,
        CROSSZERO_ENT3: CROSSZERO_ENT3,
        CROSSZERO_EXP_ENT0: CROSSZERO_EXP_ENT0,
        CROSSZERO_EXP_ENT1: CROSSZERO_EXP_ENT1,
        CROSSZERO_EXP_ENT2: CROSSZERO_EXP_ENT2,
        CROSSZERO_EXP_ENT3: CROSSZERO_EXP_ENT3,
        CURRENT_UNEQUIL_FAULT: CURRENT_UNEQUIL_FAULT,
        CURRENT_UNEQUIL_OK: CURRENT_UNEQUIL_OK,
        EM_MAGNETIC_OFF: EM_MAGNETIC_OFF$1,
        EM_MAGNETIC_ON: EM_MAGNETIC_ON$1,
        ENERGY_REG_FAULT: ENERGY_REG_FAULT,
        ENERGY_REG_OVERFLOW: ENERGY_REG_OVERFLOW,
        ERR_ACCESS: ERR_ACCESS$1,
        F_MAX_OK: F_MAX_OK$1,
        F_MAX_OVER: F_MAX_OVER$1,
        F_MIN_OK: F_MIN_OK$1,
        F_MIN_OVER: F_MIN_OVER,
        I_MAX_OK: I_MAX_OK,
        I_MAX_OVER: I_MAX_OVER,
        MAGNETIC_OFF: MAGNETIC_OFF$1,
        MAGNETIC_ON: MAGNETIC_ON$2,
        NVRAM_FAULT: NVRAM_FAULT,
        OP_PAR_FAULT: OP_PAR_FAULT,
        POWERSALDO_OK: POWERSALDO_OK,
        POWERSALDO_OVER: POWERSALDO_OVER,
        POWER_A_OFF: POWER_A_OFF$1,
        POWER_A_ON: POWER_A_ON$1,
        POWER_OVER_RELAY_OFF: POWER_OVER_RELAY_OFF$1,
        P_MAX_OK: P_MAX_OK,
        P_MAX_OVER: P_MAX_OVER,
        RELAY_HARD_BAD_OFF: RELAY_HARD_BAD_OFF$1,
        RELAY_HARD_BAD_ON: RELAY_HARD_BAD_ON$1,
        RELAY_HARD_OFF: RELAY_HARD_OFF$1,
        RELAY_HARD_ON: RELAY_HARD_ON$1,
        RELAY_OFF: RELAY_OFF$1,
        RELAY_ON: RELAY_ON$1,
        RESET_EM_FLAG: RESET_EM_FLAG$1,
        RESET_MAGN_FLAG: RESET_MAGN_FLAG,
        RESTART: RESTART$2,
        SALDO_EN_BAD: SALDO_EN_BAD,
        SALDO_PARAM_BAD: SALDO_PARAM_BAD$1,
        SET_DEMAND_EN_10MIN: SET_DEMAND_EN_10MIN,
        SET_DEMAND_EN_15MIN: SET_DEMAND_EN_15MIN,
        SET_DEMAND_EN_1MIN: SET_DEMAND_EN_1MIN,
        SET_DEMAND_EN_30MIN: SET_DEMAND_EN_30MIN,
        SET_DEMAND_EN_3MIN: SET_DEMAND_EN_3MIN,
        SET_DEMAND_EN_5MIN: SET_DEMAND_EN_5MIN,
        SET_DEMAND_EN_60MIN: SET_DEMAND_EN_60MIN,
        SET_NEW_SALDO: SET_NEW_SALDO$1,
        SET_SALDO_PARAM: SET_SALDO_PARAM$1,
        SET_TARIFF_TBL: SET_TARIFF_TBL,
        SUMMER_TIME: SUMMER_TIME$1,
        TIME_CORRECT: TIME_CORRECT$2,
        TIME_CORRECT_NEW: TIME_CORRECT_NEW,
        T_MAX_OK: T_MAX_OK$1,
        T_MAX_OVER: T_MAX_OVER$1,
        T_MIN_OK: T_MIN_OK$1,
        T_MIN_OVER: T_MIN_OVER,
        VENDOR_PAR_FAULT: VENDOR_PAR_FAULT,
        V_MAX_OK: V_MAX_OK,
        V_MAX_OVER: V_MAX_OVER,
        V_MIN_OK: V_MIN_OK,
        V_MIN_OVER: V_MIN_OVER,
        WD_RESTART: WD_RESTART$1,
        WINTER_SUMMER_BAD: WINTER_SUMMER_BAD$1,
        WINTER_TIME: WINTER_TIME$1
    });

    var eventNames$1 = invertObject(events$1);

    const defaultFrameHeader = {
        type: DATA_REQUEST,
        destination: 0xffff,
        source: 0xfffe
    };
    const TARIFF_PLAN_SIZE = 11;
    const SEASON_PROFILE_DAYS_NUMBER = 7;
    const SEASON_PROFILE_SIZE = 2 + SEASON_PROFILE_DAYS_NUMBER;
    const TARIFF_NUMBER$1 = 4;
    const ENERGY_SIZE = 4;
    const DATE_SIZE$1 = 3;
    const MIN_HALF_HOUR_PERIODS = 48;
    const MAX_HALF_HOUR_PERIODS = 50;
    const MIN_HALF_HOUR_COMMAND_SIZE = 3 + (MIN_HALF_HOUR_PERIODS * 2);
    const MAX_HALF_HOUR_COMMAND_SIZE = 4 + (MAX_HALF_HOUR_PERIODS * 2);
    const baseDisplaySetMask = {
        SET_ALL_SEGMENT_DISPLAY: 0x0001,
        SOFTWARE_VERSION: 0x0002,
        TOTAL_ACTIVE_ENERGY: 0x0004,
        ACTIVE_ENERGY_T1: 0x0008,
        ACTIVE_ENERGY_T2: 0x0010,
        ACTIVE_ENERGY_T3: 0x0020,
        ACTIVE_ENERGY_T4: 0x0040,
        ACTIVE_POWER_PER_PHASE: 0x0080,
        ACTIVE_POWER_IN_NEUTRAL: 0x0100,
        CURRENT_IN_PHASE: 0x0200,
        CURRENT_IN_NEUTRAL: 0x0400,
        VOLTAGE: 0x0800,
        HOUR_MINUTE_SECOND: 0x1000,
        DATE_MONTH_YEAR: 0x2000,
        TOTAL_EXPORTED_ACTIVE_ENERGY: 0x4000,
        EXPORTED_ACTIVE_ENERGY_T1: 0x8000,
        EXPORTED_ACTIVE_ENERGY_T2: 0x00010000,
        EXPORTED_ACTIVE_ENERGY_T3: 0x00020000,
        EXPORTED_ACTIVE_ENERGY_T4: 0x00040000,
        POWER_COEFFICIENT_PHASE_A: 0x00080000,
        POWER_COEFFICIENT_PHASE_B: 0x00100000,
        BATTERY_VOLTAGE: 0x00200000,
        POWER_THRESHOLD_T1: 0x00400000,
        POWER_THRESHOLD_T2: 0x00800000,
        POWER_THRESHOLD_T3: 0x01000000,
        POWER_THRESHOLD_T4: 0x02000000,
        CURRENT_BALANCE: 0x20000000
    };
    const displaySetMask = {
        ...baseDisplaySetMask,
        AUTO_SCREEN_SCROLLING: 0x80000000
    };
    const displaySetExtMask = {
        ...baseDisplaySetMask,
        MAGNET_INDUCTION: 0x08000000,
        OPTOPORT_SPEED: 0x40000000,
        SORT_DISPLAY_SCREENS: 0x80000000
    };
    const relaySet1Mask = {
        RELAY_ON_Y: 0x01,
        RELAY_ON_CENTER: 0x02,
        RELAY_ON_PB: 0x04,
        RELAY_ON_TARIFF_0: 0x08,
        RELAY_ON_TARIFF_1: 0x10,
        RELAY_ON_TARIFF_2: 0x20,
        RELAY_ON_TARIFF_3: 0x40,
        RELAY_ON_V_GOOD: 0x80
    };
    const relaySet2Mask = {
        RELAY_OFF_Y: 0x01,
        RELAY_OFF_CENTER: 0x02,
        RELAY_OFF_TARIFF_0: 0x04,
        RELAY_OFF_TARIFF_1: 0x08,
        RELAY_OFF_TARIFF_2: 0x10,
        RELAY_OFF_TARIFF_3: 0x20,
        RELAY_OFF_I_LIMIT: 0x40,
        RELAY_OFF_V_BAD: 0x80
    };
    const relaySet3Mask = {
        RELAY_OFF_LIM_TARIFF_0: 0x02,
        RELAY_OFF_LIM_TARIFF_1: 0x04,
        RELAY_OFF_LIM_TARIFF_2: 0x08,
        RELAY_OFF_LIM_TARIFF_3: 0x10,
        RELAY_OFF_PF_MIN: 0x20
    };
    const relaySet4Mask = {
        RELAY_ON_TIMEOUT: 0x01,
        RELAY_ON_SALDO: 0x02,
        RELAY_OFF_SALDO: 0x04,
        RELAY_OFF_SALDO_SOFT: 0x08,
        RELAY_OFF_MAGNET: 0x10,
        RELAY_ON_MAGNET_TIMEOUT: 0x20,
        RELAY_ON_MAGNET_AUTO: 0x40
    };
    const relaySet5Mask = {
        RELAY_OFF_UNEQUAL_CURRENT: 0x01,
        RELAY_ON_UNEQUAL_CURRENT: 0x02,
        RELAY_OFF_BIPOLAR_POWER: 0x04,
        RELAY_ON_BIPOLAR_POWER: 0x08
    };
    const define1Mask$1 = {
        BLOCK_KEY_OPTOPORT: 0x02,
        MAGNET_SCREEN_CONST: 0x20
    };
    const eventStatusMask = {
        CASE_OPEN: 2 ** 0,
        MAGNETIC_ON: 2 ** 1,
        PARAMETERS_UPDATE_REMOTE: 2 ** 2,
        PARAMETERS_UPDATE_LOCAL: 2 ** 3,
        RESTART: 2 ** 4,
        ERROR_ACCESS: 2 ** 5,
        TIME_SET: 2 ** 6,
        TIME_CORRECT: 2 ** 7,
        DEVICE_FAILURE: 2 ** 8,
        CASE_TERMINAL_OPEN: 2 ** 9,
        CASE_MODULE_OPEN: 2 ** 10,
        TARIFF_TABLE_SET: 2 ** 11,
        TARIFF_TABLE_GET: 2 ** 12,
        PROTECTION_RESET_EM: 2 ** 13,
        PROTECTION_RESET_MAGNETIC: 2 ** 14
    };
    const extendedCurrentValues2RelayStatusMask = {
        RELAY_STATE: 2 ** 0,
        RELAY_UBAD: 2 ** 1,
        RELAY_UNEQ_CURRENT: 2 ** 4,
        RELAY_OFF_CENTER: 2 ** 5,
        RELAY_IMAX: 2 ** 6,
        RELAY_PMAX: 2 ** 7
    };
    const extendedCurrentValues2RelayStatus2Mask = {
        RELAY_COSFI: 2 ** 0,
        RELAY_SALDO_OFF_FLAG: 2 ** 1,
        RELAY_UNEQUIL_CURRENT_OFF: 2 ** 2,
        RELAY_BIPOLAR_POWER_OFF: 2 ** 3,
        RELAY_SALDO_OFF_ON_MAX_POWER: 2 ** 4,
        RELAY_HARD_ST1: 2 ** 5
    };
    const extendedCurrentValues2Status1Mask = {
        MAXVA: 2 ** 0,
        MINVA: 2 ** 1,
        MAXT: 2 ** 2,
        MINT: 2 ** 3,
        MAXF: 2 ** 4,
        MINF: 2 ** 5,
        MAXIA: 2 ** 6,
        MAXP: 2 ** 7
    };
    const extendedCurrentValues2Status2Mask = {
        MAX_POWER_SALDO: 2 ** 0,
        BATTERY_VBAT_BAD: 2 ** 1,
        CLOCK_UNSET: 2 ** 3,
        MIN_COS_FI: 2 ** 5
    };
    const extendedCurrentValues2Status3Mask = {
        UNEQUIL_CURRENT: 2 ** 0,
        BIPOLAR_POWER: 2 ** 1,
        POWER_A_NEGATIVE: 2 ** 6,
        POWER_B_NEGATIVE: 2 ** 7
    };
    const operatorParametersExtended3RelaySetMask = {
        RELAY_OFF_LIMIT_P_MINUS_T1: 0x04,
        RELAY_OFF_LIMIT_P_MINUS_T2: 0x08,
        RELAY_OFF_LIMIT_P_MINUS_T3: 0x10,
        RELAY_OFF_LIMIT_P_MINUS_T4: 0x20
    };
    function getPackedEnergies$1(buffer, energyType, tariffMapByte) {
        const byte = tariffMapByte >> TARIFF_NUMBER$1;
        const energies = new Array(TARIFF_NUMBER$1).fill(0);
        energies.forEach((energy, index) => {
            const isTariffExists = !!extractBits(byte, 1, index + 1);
            if (isTariffExists) {
                energies[index] = buffer.getUint32();
            }
            else {
                energies[index] = null;
            }
        });
        return energies;
    }
    function setPackedEnergyType(buffer, energyType, energies) {
        const indexShift = 1 + TARIFF_NUMBER$1;
        let tariffsByte = energyType;
        energies.forEach((energy, index) => {
            tariffsByte = fillBits(tariffsByte, 1, index + indexShift, Number(!!energy));
        });
        buffer.setUint8(tariffsByte);
    }
    function getEnergyPeriod(period) {
        if (period === 0xffff) {
            return {
                tariff: undefined,
                energy: undefined
            };
        }
        return {
            tariff: ((period >> 14) & 0x03),
            energy: (period & 0x3fff)
        };
    }
    function setEnergyPeriod(buffer, { tariff, energy }) {
        if (tariff !== undefined && energy !== undefined) {
            buffer.setUint16((tariff << 14) | (energy & 0x3fff));
        }
        else {
            buffer.setUint16(0xffff);
        }
    }
    function CommandBinaryBuffer$2(dataOrLength, isLittleEndian = false) {
        BinaryBuffer.call(this, dataOrLength, isLittleEndian);
    }
    CommandBinaryBuffer$2.prototype = Object.create(BinaryBuffer.prototype);
    CommandBinaryBuffer$2.prototype.constructor = CommandBinaryBuffer$2;
    CommandBinaryBuffer$2.getDayProfileFromByte = (value) => ({
        tariff: extractBits(value, 2, 1),
        isFirstHalfHour: !extractBits(value, 1, 3),
        hour: extractBits(value, 5, 4)
    });
    CommandBinaryBuffer$2.getByteFromDayProfile = (dayProfile) => {
        let value = 0;
        value = fillBits(value, 2, 1, dayProfile.tariff);
        value = fillBits(value, 1, 3, +!dayProfile.isFirstHalfHour);
        value = fillBits(value, 5, 4, dayProfile.hour);
        return value;
    };
    CommandBinaryBuffer$2.getDefaultSeasonProfile = () => ({
        month: 1,
        date: 1,
        dayIndexes: [0, 0, 0, 0, 0, 0, 0]
    });
    CommandBinaryBuffer$2.getDefaultOperatorParameters = () => ({
        vpThreshold: 265000,
        vThreshold: 156000,
        ipThreshold: 120000,
        pmaxThreshold0: 31800,
        pmaxThreshold1: 31800,
        pmaxThreshold2: 31800,
        pmaxThreshold3: 31800,
        speedOptoPort: 0,
        tint: 30,
        calcPeriodDate: 1,
        timeoutDisplay: 127,
        timeoutScreen: 7,
        displaySet: toObject(displaySetMask, 0x80003184),
        relaySet4: toObject(relaySet4Mask, 0),
        relaySet3: toObject(relaySet3Mask, 0),
        relaySet2: toObject(relaySet2Mask, 3),
        relaySet1: toObject(relaySet1Mask, 3),
        displayType: 0,
        ten: 0,
        timeoutRefresh: 240,
        deltaCorMin: 15,
        timeoutMagnetOff: 5,
        timeoutMagnetOn: 5,
        define1: toObject(define1Mask$1, 0),
        timeoutRelayOn: 1,
        timeoutRelayKey: 0,
        timeoutRelayAuto: 5,
        timeoutBadVAVB: 5,
        freqMax: 55,
        freqMin: 45,
        phMin: 0,
        year: 0,
        month: 0,
        date: 0,
        energyDecimalPoint: 2,
        typeMeter: 0,
        timeoutIMax: 5,
        timeoutPMax: 5,
        timeoutCos: 5,
        pMaxDef: 1,
        displaySetExt: toObject(displaySetExtMask, 0x8383fff),
        timeoutUneqCurrent: 5,
        timeoutBipolarPower: 5,
        relaySet5: toObject(relaySet5Mask, 0),
        timeCorrectPeriod: 24,
        timeCorrectPassHalfhour: false
    });
    CommandBinaryBuffer$2.prototype.getFrameHeader = function () {
        const type = this.getUint8();
        const typeName = frameNames[type];
        const destination = this.getUint16();
        const source = this.getUint16();
        return {
            type,
            typeName,
            destination,
            source
        };
    };
    CommandBinaryBuffer$2.prototype.setFrameHeader = function ({ type = defaultFrameHeader.type, destination = defaultFrameHeader.destination, source = defaultFrameHeader.source }) {
        this.setUint8(type);
        this.setUint16(destination);
        this.setUint16(source);
    };
    CommandBinaryBuffer$2.prototype.getDeviceId = function () {
        const manufacturer = getHexFromBytes(this.getBytes(3), { separator: '' });
        const type = this.getUint8();
        const year = this.getUint8();
        const serial = getHexFromBytes(this.getBytes(3), { separator: '' });
        return { manufacturer, type, year, serial };
    };
    CommandBinaryBuffer$2.prototype.setDeviceId = function ({ manufacturer, type, year, serial }) {
        this.setBytes(getBytesFromHex(manufacturer));
        this.setUint8(type);
        this.setUint8(year);
        this.setBytes(getBytesFromHex(serial));
    };
    CommandBinaryBuffer$2.prototype.getDateTime = function () {
        return {
            isSummerTime: !!this.getUint8(),
            seconds: this.getUint8(),
            minutes: this.getUint8(),
            hours: this.getUint8(),
            day: this.getUint8(),
            date: this.getUint8(),
            month: this.getUint8(),
            year: this.getUint8()
        };
    };
    CommandBinaryBuffer$2.prototype.setDateTime = function (dateTime) {
        this.setUint8(dateTime.isSummerTime ? 1 : 0);
        this.setUint8(dateTime.seconds);
        this.setUint8(dateTime.minutes);
        this.setUint8(dateTime.hours);
        this.setUint8(dateTime.day || 0);
        this.setUint8(dateTime.date);
        this.setUint8(dateTime.month);
        this.setUint8(dateTime.year);
    };
    CommandBinaryBuffer$2.prototype.getTariffPlan = function () {
        return {
            id: this.getUint32(),
            tariffSet: this.getUint8(),
            activateYear: this.getUint8(),
            activateMonth: this.getUint8(),
            activateDay: this.getUint8(),
            specialProfilesArraySize: this.getUint8(),
            seasonProfilesArraySize: this.getUint8(),
            dayProfilesArraySize: this.getUint8()
        };
    };
    CommandBinaryBuffer$2.prototype.setTariffPlan = function (tariffPlan) {
        this.setUint32(tariffPlan.id);
        this.setUint8(tariffPlan.tariffSet);
        this.setUint8(tariffPlan.activateYear);
        this.setUint8(tariffPlan.activateMonth);
        this.setUint8(tariffPlan.activateDay);
        this.setUint8(tariffPlan.specialProfilesArraySize);
        this.setUint8(tariffPlan.seasonProfilesArraySize);
        this.setUint8(tariffPlan.dayProfilesArraySize);
    };
    CommandBinaryBuffer$2.prototype.getTimeCorrectionParameters = function () {
        return {
            monthTransitionSummer: this.getUint8(),
            dateTransitionSummer: this.getUint8(),
            hoursTransitionSummer: this.getUint8(),
            hoursCorrectSummer: this.getUint8(),
            monthTransitionWinter: this.getUint8(),
            dateTransitionWinter: this.getUint8(),
            hoursTransitionWinter: this.getUint8(),
            hoursCorrectWinter: this.getUint8(),
            isCorrectionNeeded: this.getUint8() === 1
        };
    };
    CommandBinaryBuffer$2.prototype.setTimeCorrectionParameters = function (parameters) {
        this.setUint8(parameters.monthTransitionSummer);
        this.setUint8(parameters.dateTransitionSummer);
        this.setUint8(parameters.hoursTransitionSummer);
        this.setUint8(parameters.hoursCorrectSummer);
        this.setUint8(parameters.monthTransitionWinter);
        this.setUint8(parameters.dateTransitionWinter);
        this.setUint8(parameters.hoursTransitionWinter);
        this.setUint8(parameters.hoursCorrectWinter);
        this.setUint8(+parameters.isCorrectionNeeded);
    };
    CommandBinaryBuffer$2.prototype.getDayProfile = function () {
        return CommandBinaryBuffer$2.getDayProfileFromByte(this.getUint8());
    };
    CommandBinaryBuffer$2.prototype.setDayProfile = function (dayProfile) {
        this.setUint8(CommandBinaryBuffer$2.getByteFromDayProfile(dayProfile));
    };
    CommandBinaryBuffer$2.prototype.getSeasonProfile = function () {
        return {
            month: this.getUint8(),
            date: this.getUint8(),
            dayIndexes: new Array(SEASON_PROFILE_DAYS_NUMBER).fill(0).map(() => this.getUint8())
        };
    };
    CommandBinaryBuffer$2.prototype.setSeasonProfile = function (seasonProfile) {
        this.setUint8(seasonProfile.month);
        this.setUint8(seasonProfile.date);
        seasonProfile.dayIndexes.forEach(value => this.setUint8(value));
    };
    CommandBinaryBuffer$2.prototype.getSpecialDay = function () {
        return {
            month: this.getUint8(),
            date: this.getUint8(),
            dayIndex: this.getUint8(),
            isPeriodic: this.getUint8() === 0
        };
    };
    CommandBinaryBuffer$2.prototype.setSpecialDay = function (specialDay) {
        this.setUint8(specialDay.month);
        this.setUint8(specialDay.date);
        this.setUint8(specialDay.dayIndex);
        this.setUint8(+!specialDay.isPeriodic);
    };
    CommandBinaryBuffer$2.prototype.getDeviceType = function () {
        return fromBytes$2g(this.getBytes(9));
    };
    CommandBinaryBuffer$2.prototype.setDeviceType = function (deviceType) {
        this.setBytes(toBytes$2h(deviceType));
    };
    CommandBinaryBuffer$2.prototype.getOperatorParameters = function () {
        const operatorParameters = {
            vpThreshold: this.getUint32(),
            vThreshold: this.getUint32(),
            ipThreshold: this.getUint32(),
            pmaxThreshold0: this.getUint32(),
            pmaxThreshold1: this.getUint32(),
            pmaxThreshold2: this.getUint32(),
            pmaxThreshold3: this.getUint32(),
            speedOptoPort: this.getUint8(),
            tint: this.getUint8(),
            calcPeriodDate: this.getUint8(),
            timeoutDisplay: this.getUint8(),
            timeoutScreen: this.getUint8(),
            displaySet: toObject(displaySetMask, this.getUint32()),
            relaySet4: toObject(relaySet4Mask, this.getUint8()),
            relaySet3: toObject(relaySet3Mask, this.getUint8()),
            relaySet2: toObject(relaySet2Mask, this.getUint8()),
            relaySet1: toObject(relaySet1Mask, this.getUint8()),
            displayType: this.getUint8(),
            ten: this.getUint8(),
            timeoutRefresh: this.getUint16(),
            deltaCorMin: this.getUint8(),
            timeoutMagnetOff: this.getUint8(),
            timeoutMagnetOn: this.getUint8(),
            define1: toObject(define1Mask$1, this.getUint8()),
            timeoutRelayOn: this.getUint8(),
            timeoutRelayKey: this.getUint8(),
            timeoutRelayAuto: this.getUint8(),
            timeoutBadVAVB: this.getUint8(),
            freqMax: this.getUint8(),
            freqMin: this.getUint8(),
            phMin: this.getUint16(),
            year: this.getUint8(),
            month: this.getUint8(),
            date: this.getUint8(),
            energyDecimalPoint: this.getUint8(),
            typeMeter: this.getUint8(),
            timeoutIMax: this.getUint8(),
            timeoutPMax: this.getUint8(),
            timeoutCos: this.getUint8(),
            pMaxDef: this.getUint8(),
            displaySetExt: toObject(displaySetExtMask, this.getUint32()),
            timeoutUneqCurrent: this.getUint8(),
            timeoutBipolarPower: this.getUint8(),
            relaySet5: toObject(relaySet5Mask, this.getUint8()),
            timeCorrectPeriod: 0,
            timeCorrectPassHalfhour: false
        };
        const timeCorrectPeriod = this.getUint8();
        operatorParameters.timeCorrectPeriod = timeCorrectPeriod & 0x7f;
        operatorParameters.timeCorrectPassHalfhour = !!(timeCorrectPeriod & 0x80);
        return operatorParameters;
    };
    CommandBinaryBuffer$2.prototype.setOperatorParameters = function (operatorParameters) {
        const timeCorrectPeriod = operatorParameters.timeCorrectPeriod
            | (operatorParameters.timeCorrectPassHalfhour ? 0x80 : 0);
        this.setUint32(operatorParameters.vpThreshold);
        this.setUint32(operatorParameters.vThreshold);
        this.setUint32(operatorParameters.ipThreshold);
        this.setUint32(operatorParameters.pmaxThreshold0);
        this.setUint32(operatorParameters.pmaxThreshold1);
        this.setUint32(operatorParameters.pmaxThreshold2);
        this.setUint32(operatorParameters.pmaxThreshold3);
        this.setUint8(operatorParameters.speedOptoPort);
        this.setUint8(operatorParameters.tint);
        this.setUint8(operatorParameters.calcPeriodDate);
        this.setUint8(operatorParameters.timeoutDisplay);
        this.setUint8(operatorParameters.timeoutScreen);
        this.setUint32(fromObject(displaySetMask, operatorParameters.displaySet));
        this.setUint8(fromObject(relaySet4Mask, operatorParameters.relaySet4));
        this.setUint8(fromObject(relaySet3Mask, operatorParameters.relaySet3));
        this.setUint8(fromObject(relaySet2Mask, operatorParameters.relaySet2));
        this.setUint8(fromObject(relaySet1Mask, operatorParameters.relaySet1));
        this.setUint8(operatorParameters.displayType);
        this.setUint8(operatorParameters.ten);
        this.setUint16(operatorParameters.timeoutRefresh);
        this.setUint8(operatorParameters.deltaCorMin);
        this.setUint8(operatorParameters.timeoutMagnetOff);
        this.setUint8(operatorParameters.timeoutMagnetOn);
        this.setUint8(fromObject(define1Mask$1, operatorParameters.define1));
        this.setUint8(operatorParameters.timeoutRelayOn);
        this.setUint8(operatorParameters.timeoutRelayKey);
        this.setUint8(operatorParameters.timeoutRelayAuto);
        this.setUint8(operatorParameters.timeoutBadVAVB);
        this.setUint8(operatorParameters.freqMax);
        this.setUint8(operatorParameters.freqMin);
        this.setUint16(operatorParameters.phMin);
        this.setUint8(operatorParameters.year);
        this.setUint8(operatorParameters.month);
        this.setUint8(operatorParameters.date);
        this.setUint8(operatorParameters.energyDecimalPoint);
        this.setUint8(operatorParameters.typeMeter);
        this.setUint8(operatorParameters.timeoutIMax);
        this.setUint8(operatorParameters.timeoutPMax);
        this.setUint8(operatorParameters.timeoutCos);
        this.setUint8(operatorParameters.pMaxDef);
        this.setUint32(fromObject(displaySetExtMask, operatorParameters.displaySetExt));
        this.setUint8(operatorParameters.timeoutUneqCurrent);
        this.setUint8(operatorParameters.timeoutBipolarPower);
        this.setUint8(fromObject(relaySet5Mask, operatorParameters.relaySet5));
        this.setUint8(timeCorrectPeriod);
    };
    CommandBinaryBuffer$2.prototype.getPackedEnergyWithType = function () {
        const byte = this.getUint8();
        const energyType = extractBits(byte, TARIFF_NUMBER$1, 1);
        const energies = getPackedEnergies$1(this, energyType, byte);
        return {
            energyType,
            energies
        };
    };
    CommandBinaryBuffer$2.prototype.setPackedEnergyWithType = function ({ energyType, energies }) {
        if (energyType) {
            setPackedEnergyType(this, energyType, energies);
        }
        energies.forEach(energy => {
            if (energy !== null) {
                this.setUint32(energy);
            }
        });
    };
    CommandBinaryBuffer$2.prototype.getEnergies = function () {
        return new Array(TARIFF_NUMBER$1).fill(0).map(() => this.getInt32());
    };
    CommandBinaryBuffer$2.prototype.setEnergies = function (energies) {
        energies.forEach(value => this.setUint32(value));
    };
    CommandBinaryBuffer$2.prototype.getDate = function () {
        return {
            year: this.getUint8(),
            month: this.getUint8(),
            date: this.getUint8()
        };
    };
    CommandBinaryBuffer$2.prototype.setDate = function (date) {
        this.setUint8(date.year);
        this.setUint8(date.month);
        this.setUint8(date.date);
    };
    CommandBinaryBuffer$2.prototype.getSaldoParameters = function () {
        return {
            coefficients: new Array(4).fill(0).map(() => this.getUint32()),
            decimalPointTariff: this.getUint8(),
            indicationThreshold: this.getInt32(),
            relayThreshold: this.getInt32(),
            mode: this.getUint8(),
            saldoOffTimeBegin: this.getUint8(),
            saldoOffTimeEnd: this.getUint8(),
            decimalPointIndication: this.getUint8(),
            powerThreshold: this.getUint32(),
            creditThreshold: this.getInt32()
        };
    };
    CommandBinaryBuffer$2.prototype.setSaldoParameters = function (saldoParameters) {
        saldoParameters.coefficients.forEach(value => this.setUint32(value));
        this.setUint8(saldoParameters.decimalPointTariff);
        this.setInt32(saldoParameters.indicationThreshold);
        this.setInt32(saldoParameters.relayThreshold);
        this.setUint8(saldoParameters.mode);
        this.setUint8(saldoParameters.saldoOffTimeBegin);
        this.setUint8(saldoParameters.saldoOffTimeEnd);
        this.setUint8(saldoParameters.decimalPointIndication);
        this.setUint32(saldoParameters.powerThreshold);
        this.setInt32(saldoParameters.creditThreshold);
    };
    CommandBinaryBuffer$2.prototype.getEnergyPeriods = function (periodsNumber) {
        const periods = new Array(periodsNumber).fill(0).map(() => this.getUint16());
        return periods.map(period => getEnergyPeriod(period));
    };
    CommandBinaryBuffer$2.prototype.setEnergyPeriods = function (periods) {
        periods.forEach(period => setEnergyPeriod(this, period));
    };
    CommandBinaryBuffer$2.prototype.getEventStatus = function () {
        const eventStatus = this.getUint16();
        return toObject(eventStatusMask, eventStatus);
    };
    CommandBinaryBuffer$2.prototype.setEventStatus = function (parameters) {
        this.setUint16(fromObject(eventStatusMask, parameters));
    };
    CommandBinaryBuffer$2.prototype.getExtendedCurrentValues2 = function () {
        const uBattery = this.getUint16();
        const relayStatus = toObject(extendedCurrentValues2RelayStatusMask, this.getUint8());
        const relayStatus2 = toObject(extendedCurrentValues2RelayStatus2Mask, this.getUint8());
        const status1 = toObject(extendedCurrentValues2Status1Mask, this.getUint8());
        const status2 = toObject(extendedCurrentValues2Status2Mask, this.getUint8());
        const status3 = toObject(extendedCurrentValues2Status3Mask, this.getUint8());
        return {
            uBattery,
            relayStatus,
            relayStatus2,
            status1,
            status2,
            status3
        };
    };
    CommandBinaryBuffer$2.prototype.setExtendedCurrentValues2 = function (parameters) {
        const { uBattery, relayStatus, relayStatus2, status1, status2, status3 } = parameters;
        this.setUint16(uBattery);
        this.setUint8(fromObject(extendedCurrentValues2RelayStatusMask, relayStatus));
        this.setUint8(fromObject(extendedCurrentValues2RelayStatus2Mask, relayStatus2));
        this.setUint8(fromObject(extendedCurrentValues2Status1Mask, status1));
        this.setUint8(fromObject(extendedCurrentValues2Status2Mask, status2));
        this.setUint8(fromObject(extendedCurrentValues2Status3Mask, status3));
    };
    CommandBinaryBuffer$2.prototype.getEvent = function () {
        const data = {
            hours: this.getUint8(),
            minutes: this.getUint8(),
            seconds: this.getUint8(),
            event: this.getUint8()
        };
        const { event } = data;
        const { bytesLeft } = this;
        data.eventName = eventNames$1[event];
        switch (event) {
            case POWER_OVER_RELAY_OFF$1:
                if (bytesLeft < 4) {
                    return data;
                }
                data.power = [this.getUint8(), this.getUint8(), this.getUint8(), this.getUint8()];
                break;
            case CMD_CHANGE_TIME$1:
            case TIME_CORRECT$2:
                if (bytesLeft < 8) {
                    return data;
                }
                data.newDate = this.getDateTime();
                break;
        }
        return data;
    };
    CommandBinaryBuffer$2.prototype.setEvent = function (event) {
        this.setUint8(event.hours);
        this.setUint8(event.minutes);
        this.setUint8(event.seconds);
        this.setUint8(event.event);
        switch (event.event) {
            case POWER_OVER_RELAY_OFF$1:
                for (const item of event.power) {
                    this.setUint8(item);
                }
                break;
            case CMD_CHANGE_TIME$1:
            case TIME_CORRECT$2:
                this.setDateTime(event.newDate);
                break;
        }
    };
    CommandBinaryBuffer$2.prototype.getDemand = function () {
        const date0 = this.getUint8();
        const date1 = this.getUint8();
        return {
            date: {
                year: date0 >> 1,
                month: ((date0 << 3) & 0x0f) | (date1 >> 5),
                date: date1 & 0x1f
            },
            energyType: this.getUint8(),
            firstIndex: this.getUint16(),
            count: this.getUint8(),
            period: this.getUint8()
        };
    };
    CommandBinaryBuffer$2.prototype.setDemand = function (parameters) {
        const date0 = (parameters.date.year << 1) | ((parameters.date.month >> 3) & 0x01);
        const date1 = ((parameters.date.month << 5) & 0xe0) | (parameters.date.date & 0x1f);
        this.setUint8(date0);
        this.setUint8(date1);
        this.setUint8(parameters.energyType);
        this.setUint16(parameters.firstIndex);
        this.setUint8(parameters.count);
        this.setUint8(parameters.period);
    };
    CommandBinaryBuffer$2.prototype.getDayMaxDemandResponse = function () {
        const date = this.getDate();
        const power = new Array(TARIFF_NUMBER$1).fill(0).map(() => ({
            hours: this.getUint8(),
            minutes: this.getUint8(),
            power: this.getUint32()
        }));
        return { date, power };
    };
    CommandBinaryBuffer$2.prototype.setDayMaxDemandResponse = function (parameters) {
        this.setDate(parameters.date);
        parameters.power.forEach(value => {
            this.setUint8(value.hours);
            this.setUint8(value.minutes);
            this.setUint32(value.power);
        });
    };
    CommandBinaryBuffer$2.prototype.getOperatorParametersExtended3 = function () {
        return {
            pmaxMinusThreshold0: this.getUint32(),
            pmaxMinusThreshold1: this.getUint32(),
            pmaxMinusThreshold2: this.getUint32(),
            pmaxMinusThreshold3: this.getUint32(),
            relaySet: toObject(operatorParametersExtended3RelaySetMask, this.getUint8())
        };
    };
    CommandBinaryBuffer$2.prototype.setOperatorParametersExtended3 = function (parameters) {
        const { pmaxMinusThreshold0, pmaxMinusThreshold1, pmaxMinusThreshold2, pmaxMinusThreshold3, relaySet } = parameters;
        this.setUint32(pmaxMinusThreshold0);
        this.setUint32(pmaxMinusThreshold1);
        this.setUint32(pmaxMinusThreshold2);
        this.setUint32(pmaxMinusThreshold3);
        this.setUint8(fromObject(operatorParametersExtended3RelaySetMask, relaySet));
    };
    CommandBinaryBuffer$2.prototype.getMonthMaxPowerByTariffs = function () {
        return new Array(TARIFF_NUMBER$1).fill(0).map(() => ({
            date: this.getUint8(),
            hours: this.getUint8(),
            minutes: this.getUint8(),
            power: this.getUint32()
        }));
    };
    CommandBinaryBuffer$2.prototype.setMonthMaxPowerByTariffs = function (tariffs) {
        tariffs.forEach(tariff => {
            this.setUint8(tariff.date);
            this.setUint8(tariff.hours);
            this.setUint8(tariff.minutes);
            this.setUint32(tariff.power);
        });
    };

    const toBytes$2g = (commandId, commandBytes = []) => [commandId, commandBytes.length, ...commandBytes];

    const UNENCRYPTED = 0x00;
    const READ_ONLY = 0x03;

    const getEventStatus$1 = 0x01;
    const getEnergyDayPrevious$1 = 0x03;
    const getDeviceType$1 = 0x04;
    const getDeviceId$1 = 0x05;
    const getDateTime$1 = 0x07;
    const setDateTime$1 = 0x08;
    const setAccessKey$1 = 0x09;
    const getCurrentValues$1 = 0x0d;
    const getEnergy$1 = 0x0f;
    const setDayProfile$1 = 0x10;
    const setSeasonProfile$1 = 0x11;
    const setSpecialDay$1 = 0x12;
    const activateRatePlan$1 = 0x13;
    const prepareRatePlan$1 = 0x14;
    const getHalfHourDemand$1 = 0x15;
    const getDayDemand$1 = 0x16;
    const getMonthDemand$1 = 0x17;
    const turnRelayOn$1 = 0x18;
    const turnRelayOff$1 = 0x19;
    const setCorrectTime$1 = 0x1c;
    const getOperatorParameters$1 = 0x1e;
    const setOperatorParameters$1 = 0x1f;
    const getVersion$1 = 0x28;
    const getSaldo$1 = 0x29;
    const setSaldo$1 = 0x2a;
    const getRatePlanInfo$1 = 0x2c;
    const getExtendedCurrentValues2 = 0x2d;
    const getSaldoParameters$1 = 0x2e;
    const setSaldoParameters$1 = 0x2f;
    const getDayMaxDemand$1 = 0x31;
    const getMonthMaxDemand$1 = 0x32;
    const getEvents$1 = 0x33;
    const getEventsCounters$1 = 0x34;
    const resetPowerMaxDay$1 = 0x35;
    const resetPowerMaxMonth$1 = 0x36;
    const getCurrentStatusMeter$1 = 0x39;
    const getExtendedCurrentValues$1 = 0x3a;
    const getDayProfile$1 = 0x3b;
    const getSeasonProfile$1 = 0x3c;
    const getSpecialDay$1 = 0x3d;
    const getCorrectTime$1 = 0x3e;
    const getCriticalEvent$1 = 0x41;
    const runTariffPlan$1 = 0x46;
    const getDayMaxDemandPrevious = 0x4a;
    const getHalfHourDemandPrevious = 0x4b;
    const getDayDemandExport$1 = 0x4f;
    const getEnergyExportDayPrevious$1 = 0x50;
    const getMonthDemandExport$1 = 0x52;
    const getHalfHourDemandExport$1 = 0x53;
    const getDayMaxDemandExport$1 = 0x58;
    const getMonthMaxDemandExport$1 = 0x59;
    const getEnergyExport$1 = 0x5b;
    const setCorrectDateTime$1 = 0x5c;
    const setDisplayParam$1 = 0x5d;
    const getDisplayParam$1 = 0x5e;
    const setSpecialOperation$1 = 0x64;
    const getMagneticFieldThreshold$1 = 0x6d;
    const getHalfhoursEnergies$1 = 0x6f;
    const getBuildVersion$1 = 0x70;
    const getOperatorParametersExtended3$1 = 0x71;
    const setOperatorParametersExtended3$1 = 0x72;
    const getDemand$1 = 0x76;
    const getMeterInfo$1 = 0x7a;

    var downlinkIds$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activateRatePlan: activateRatePlan$1,
        getBuildVersion: getBuildVersion$1,
        getCorrectTime: getCorrectTime$1,
        getCriticalEvent: getCriticalEvent$1,
        getCurrentStatusMeter: getCurrentStatusMeter$1,
        getCurrentValues: getCurrentValues$1,
        getDateTime: getDateTime$1,
        getDayDemand: getDayDemand$1,
        getDayDemandExport: getDayDemandExport$1,
        getDayMaxDemand: getDayMaxDemand$1,
        getDayMaxDemandExport: getDayMaxDemandExport$1,
        getDayMaxDemandPrevious: getDayMaxDemandPrevious,
        getDayProfile: getDayProfile$1,
        getDemand: getDemand$1,
        getDeviceId: getDeviceId$1,
        getDeviceType: getDeviceType$1,
        getDisplayParam: getDisplayParam$1,
        getEnergy: getEnergy$1,
        getEnergyDayPrevious: getEnergyDayPrevious$1,
        getEnergyExport: getEnergyExport$1,
        getEnergyExportDayPrevious: getEnergyExportDayPrevious$1,
        getEventStatus: getEventStatus$1,
        getEvents: getEvents$1,
        getEventsCounters: getEventsCounters$1,
        getExtendedCurrentValues: getExtendedCurrentValues$1,
        getExtendedCurrentValues2: getExtendedCurrentValues2,
        getHalfHourDemand: getHalfHourDemand$1,
        getHalfHourDemandExport: getHalfHourDemandExport$1,
        getHalfHourDemandPrevious: getHalfHourDemandPrevious,
        getHalfhoursEnergies: getHalfhoursEnergies$1,
        getMagneticFieldThreshold: getMagneticFieldThreshold$1,
        getMeterInfo: getMeterInfo$1,
        getMonthDemand: getMonthDemand$1,
        getMonthDemandExport: getMonthDemandExport$1,
        getMonthMaxDemand: getMonthMaxDemand$1,
        getMonthMaxDemandExport: getMonthMaxDemandExport$1,
        getOperatorParameters: getOperatorParameters$1,
        getOperatorParametersExtended3: getOperatorParametersExtended3$1,
        getRatePlanInfo: getRatePlanInfo$1,
        getSaldo: getSaldo$1,
        getSaldoParameters: getSaldoParameters$1,
        getSeasonProfile: getSeasonProfile$1,
        getSpecialDay: getSpecialDay$1,
        getVersion: getVersion$1,
        prepareRatePlan: prepareRatePlan$1,
        resetPowerMaxDay: resetPowerMaxDay$1,
        resetPowerMaxMonth: resetPowerMaxMonth$1,
        runTariffPlan: runTariffPlan$1,
        setAccessKey: setAccessKey$1,
        setCorrectDateTime: setCorrectDateTime$1,
        setCorrectTime: setCorrectTime$1,
        setDateTime: setDateTime$1,
        setDayProfile: setDayProfile$1,
        setDisplayParam: setDisplayParam$1,
        setOperatorParameters: setOperatorParameters$1,
        setOperatorParametersExtended3: setOperatorParametersExtended3$1,
        setSaldo: setSaldo$1,
        setSaldoParameters: setSaldoParameters$1,
        setSeasonProfile: setSeasonProfile$1,
        setSpecialDay: setSpecialDay$1,
        setSpecialOperation: setSpecialOperation$1,
        turnRelayOff: turnRelayOff$1,
        turnRelayOn: turnRelayOn$1
    });

    var commandNames$1 = invertObject(downlinkIds$1);

    const id$2d = activateRatePlan$1;
    commandNames$1[activateRatePlan$1];
    const maxSize$1S = 1 + TARIFF_PLAN_SIZE;
    const fromBytes$2f = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            tariffTable: buffer.getUint8(),
            tariffPlan: buffer.getTariffPlan()
        };
    };
    const toBytes$2f = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1S);
        buffer.setUint8(parameters.tariffTable);
        buffer.setTariffPlan(parameters.tariffPlan);
        return toBytes$2g(id$2d, buffer.data);
    };

    const id$2c = getBuildVersion$1;
    commandNames$1[getBuildVersion$1];
    const maxSize$1R = 0;
    const fromBytes$2e = (bytes) => {
        if (bytes.length !== maxSize$1R) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$2e = () => toBytes$2g(id$2c);

    const id$2b = getCorrectTime$1;
    commandNames$1[getCorrectTime$1];
    const maxSize$1Q = 0;
    const fromBytes$2d = (bytes) => {
        if (bytes.length !== maxSize$1Q) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$2d = () => toBytes$2g(id$2b);

    const CASE_OPEN$1 = 0;
    const MAGNETIC_ON$1 = 1;
    const PARAMETERS_UPDATE_REMOTE = 2;
    const PARAMETERS_UPDATE_LOCAL = 3;
    const RESTART$1 = 4;
    const ERROR_ACCESS = 5;
    const TIME_SET = 6;
    const TIME_CORRECT$1 = 7;
    const DEVICE_FAILURE = 8;
    const CASE_TERMINAL_OPEN = 9;
    const CASE_MODULE_OPEN$1 = 10;
    const TARIFF_TABLE_SET = 11;
    const TARIFF_TABLE_GET = 12;
    const PROTECTION_RESET_EM = 13;
    const PROTECTION_RESET_MAGNETIC = 14;

    var criticalEvents = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CASE_MODULE_OPEN: CASE_MODULE_OPEN$1,
        CASE_OPEN: CASE_OPEN$1,
        CASE_TERMINAL_OPEN: CASE_TERMINAL_OPEN,
        DEVICE_FAILURE: DEVICE_FAILURE,
        ERROR_ACCESS: ERROR_ACCESS,
        MAGNETIC_ON: MAGNETIC_ON$1,
        PARAMETERS_UPDATE_LOCAL: PARAMETERS_UPDATE_LOCAL,
        PARAMETERS_UPDATE_REMOTE: PARAMETERS_UPDATE_REMOTE,
        PROTECTION_RESET_EM: PROTECTION_RESET_EM,
        PROTECTION_RESET_MAGNETIC: PROTECTION_RESET_MAGNETIC,
        RESTART: RESTART$1,
        TARIFF_TABLE_GET: TARIFF_TABLE_GET,
        TARIFF_TABLE_SET: TARIFF_TABLE_SET,
        TIME_CORRECT: TIME_CORRECT$1,
        TIME_SET: TIME_SET
    });

    invertObject(criticalEvents);

    commandNames$1[getCriticalEvent$1];

    const id$2a = getCurrentStatusMeter$1;
    commandNames$1[getCurrentStatusMeter$1];
    const maxSize$1P = 0;
    const fromBytes$2c = (bytes) => {
        if (bytes.length !== maxSize$1P) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$2c = () => toBytes$2g(id$2a);

    const id$29 = getCurrentValues$1;
    commandNames$1[getCurrentValues$1];
    const maxSize$1O = 0;
    const fromBytes$2b = (bytes) => {
        if (bytes.length !== maxSize$1O) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$2b = () => toBytes$2g(id$29);

    const id$28 = getDateTime$1;
    commandNames$1[getDateTime$1];
    const maxSize$1N = 0;
    const fromBytes$2a = (bytes) => {
        if (bytes.length !== maxSize$1N) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$2a = () => toBytes$2g(id$28);

    commandNames$1[getDayDemand$1];

    commandNames$1[getDayDemandExport$1];

    const id$27 = getDayMaxDemand$1;
    commandNames$1[getDayMaxDemand$1];
    const maxSize$1M = 3;
    const fromBytes$29 = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return { date: buffer.getDate() };
    };
    const toBytes$29 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1M);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$27, buffer.data);
    };

    const id$26 = getDayMaxDemandExport$1;
    commandNames$1[getDayMaxDemandExport$1];
    const maxSize$1L = 3;
    const fromBytes$28 = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return { date: buffer.getDate() };
    };
    const toBytes$28 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1L);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$26, buffer.data);
    };

    commandNames$1[getDayMaxDemandPrevious];

    const id$25 = getDayProfile$1;
    commandNames$1[getDayProfile$1];
    const maxSize$1K = 3;
    const fromBytes$27 = ([tariffTable, index, isActive]) => ({ tariffTable, index, isActive: isActive === 0 });
    const toBytes$27 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1K);
        buffer.setUint8(parameters.tariffTable);
        buffer.setUint8(parameters.index);
        buffer.setUint8(parameters.isActive ? 0 : 1);
        return toBytes$2g(id$25, buffer.data);
    };

    commandNames$1[getDemand$1];

    const id$24 = getDeviceId$1;
    commandNames$1[getDeviceId$1];
    const maxSize$1J = 0;
    const fromBytes$26 = (bytes) => {
        if (bytes.length !== maxSize$1J) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$26 = () => toBytes$2g(id$24);

    const id$23 = getDeviceType$1;
    commandNames$1[getDeviceType$1];
    const maxSize$1I = 0;
    const fromBytes$25 = (data) => {
        if (data.length !== maxSize$1I) {
            throw new Error(`Wrong buffer size: ${data.length}.`);
        }
        return {};
    };
    const toBytes$25 = () => toBytes$2g(id$23);

    const OK = 0;
    const UNKNOWN_COMMAND = 0x80;
    const NOT_ALIGNED_DATA = 0x81;
    const DECRYPTION_FAILURE = 0x82;
    const UNKNOWN_PROTOCOL = 0x83;
    const BAD_MESSAGE = 0x84;
    const BAD_DATA_LENGTH = 0x85;
    const BAD_ARRAY_INDEX = 0x86;
    const NOT_PREPARED_RATE_PLAN = 0x87;
    const BAD_RATE_PLAN_ID = 0x88;
    const BAD_RATE_PLAN_SIZE = 0x89;
    const BAD_RESPONSE_LENGTH = 0x90;
    const NO_DATA_FOR_DATE = 0x91;
    const CALIBRATION_DISABLED = 0x92;
    const ACCESS_DENIED = 0x93;
    const BAD_SALDO_WRITE = 0x95;
    const BLOCKED_METER = 0x97;
    const UNENCRYPTED_COMMAND_DISABLED = 0x98;
    const TIME_CORRECTION_FAILURE = 0x99;
    const INVALID_CORRECTION_INTERVAL = 0x9a;
    const TIME_CORRECTION_OUT_HALF_HOUR_DISABLED = 0x9b;
    const BAD_BLOCK_NUMBER = 0x9c;
    const OUT_OFF_RANGE = 0x9f;
    const SET_METER_TYPE_FAILURE = 0xa0;
    const INTERNAL = 0xf0;

    var resultCodes = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACCESS_DENIED: ACCESS_DENIED,
        BAD_ARRAY_INDEX: BAD_ARRAY_INDEX,
        BAD_BLOCK_NUMBER: BAD_BLOCK_NUMBER,
        BAD_DATA_LENGTH: BAD_DATA_LENGTH,
        BAD_MESSAGE: BAD_MESSAGE,
        BAD_RATE_PLAN_ID: BAD_RATE_PLAN_ID,
        BAD_RATE_PLAN_SIZE: BAD_RATE_PLAN_SIZE,
        BAD_RESPONSE_LENGTH: BAD_RESPONSE_LENGTH,
        BAD_SALDO_WRITE: BAD_SALDO_WRITE,
        BLOCKED_METER: BLOCKED_METER,
        CALIBRATION_DISABLED: CALIBRATION_DISABLED,
        DECRYPTION_FAILURE: DECRYPTION_FAILURE,
        INTERNAL: INTERNAL,
        INVALID_CORRECTION_INTERVAL: INVALID_CORRECTION_INTERVAL,
        NOT_ALIGNED_DATA: NOT_ALIGNED_DATA,
        NOT_PREPARED_RATE_PLAN: NOT_PREPARED_RATE_PLAN,
        NO_DATA_FOR_DATE: NO_DATA_FOR_DATE,
        OK: OK,
        OUT_OFF_RANGE: OUT_OFF_RANGE,
        SET_METER_TYPE_FAILURE: SET_METER_TYPE_FAILURE,
        TIME_CORRECTION_FAILURE: TIME_CORRECTION_FAILURE,
        TIME_CORRECTION_OUT_HALF_HOUR_DISABLED: TIME_CORRECTION_OUT_HALF_HOUR_DISABLED,
        UNENCRYPTED_COMMAND_DISABLED: UNENCRYPTED_COMMAND_DISABLED,
        UNKNOWN_COMMAND: UNKNOWN_COMMAND,
        UNKNOWN_PROTOCOL: UNKNOWN_PROTOCOL
    });

    var resultNames = invertObject(resultCodes);

    const SET_ALL_SEGMENT_DISPLAY$1 = 1;
    const SOFTWARE_VERSION$1 = 2;
    const TOTAL_ACTIVE_ENERGY$1 = 3;
    const ACTIVE_ENERGY_T1$1 = 4;
    const ACTIVE_ENERGY_T2$1 = 5;
    const ACTIVE_ENERGY_T3$1 = 6;
    const ACTIVE_ENERGY_T4$1 = 7;
    const ACTIVE_POWER_PER_PHASE = 8;
    const ACTIVE_POWER_IN_NEUTRAL = 9;
    const CURRENT_IN_PHASE = 10;
    const CURRENT_IN_NEUTRAL$1 = 11;
    const VOLTAGE = 12;
    const HOUR_MINUTE_SECOND$1 = 13;
    const DATE_MONTH_YEAR$1 = 14;
    const TOTAL_EXPORTED_ACTIVE_ENERGY$1 = 15;
    const EXPORTED_ACTIVE_ENERGY_T1$1 = 16;
    const EXPORTED_ACTIVE_ENERGY_T2$1 = 17;
    const EXPORTED_ACTIVE_ENERGY_T3$1 = 18;
    const EXPORTED_ACTIVE_ENERGY_T4$1 = 19;
    const POWER_COEFFICIENT_PHASE_A$1 = 20;
    const POWER_COEFFICIENT_PHASE_B$1 = 21;
    const BATTERY_VOLTAGE$1 = 22;
    const POWER_THRESHOLD_T1$1 = 23;
    const POWER_THRESHOLD_T2$1 = 24;
    const POWER_THRESHOLD_T3$1 = 25;
    const POWER_THRESHOLD_T4$1 = 26;
    const MAGNET_INDUCTION$1 = 28;
    const CURRENT_BALANCE$1 = 30;
    const OPTOPORT_SPEED$1 = 31;

    var screenIds$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTIVE_ENERGY_T1: ACTIVE_ENERGY_T1$1,
        ACTIVE_ENERGY_T2: ACTIVE_ENERGY_T2$1,
        ACTIVE_ENERGY_T3: ACTIVE_ENERGY_T3$1,
        ACTIVE_ENERGY_T4: ACTIVE_ENERGY_T4$1,
        ACTIVE_POWER_IN_NEUTRAL: ACTIVE_POWER_IN_NEUTRAL,
        ACTIVE_POWER_PER_PHASE: ACTIVE_POWER_PER_PHASE,
        BATTERY_VOLTAGE: BATTERY_VOLTAGE$1,
        CURRENT_BALANCE: CURRENT_BALANCE$1,
        CURRENT_IN_NEUTRAL: CURRENT_IN_NEUTRAL$1,
        CURRENT_IN_PHASE: CURRENT_IN_PHASE,
        DATE_MONTH_YEAR: DATE_MONTH_YEAR$1,
        EXPORTED_ACTIVE_ENERGY_T1: EXPORTED_ACTIVE_ENERGY_T1$1,
        EXPORTED_ACTIVE_ENERGY_T2: EXPORTED_ACTIVE_ENERGY_T2$1,
        EXPORTED_ACTIVE_ENERGY_T3: EXPORTED_ACTIVE_ENERGY_T3$1,
        EXPORTED_ACTIVE_ENERGY_T4: EXPORTED_ACTIVE_ENERGY_T4$1,
        HOUR_MINUTE_SECOND: HOUR_MINUTE_SECOND$1,
        MAGNET_INDUCTION: MAGNET_INDUCTION$1,
        OPTOPORT_SPEED: OPTOPORT_SPEED$1,
        POWER_COEFFICIENT_PHASE_A: POWER_COEFFICIENT_PHASE_A$1,
        POWER_COEFFICIENT_PHASE_B: POWER_COEFFICIENT_PHASE_B$1,
        POWER_THRESHOLD_T1: POWER_THRESHOLD_T1$1,
        POWER_THRESHOLD_T2: POWER_THRESHOLD_T2$1,
        POWER_THRESHOLD_T3: POWER_THRESHOLD_T3$1,
        POWER_THRESHOLD_T4: POWER_THRESHOLD_T4$1,
        SET_ALL_SEGMENT_DISPLAY: SET_ALL_SEGMENT_DISPLAY$1,
        SOFTWARE_VERSION: SOFTWARE_VERSION$1,
        TOTAL_ACTIVE_ENERGY: TOTAL_ACTIVE_ENERGY$1,
        TOTAL_EXPORTED_ACTIVE_ENERGY: TOTAL_EXPORTED_ACTIVE_ENERGY$1,
        VOLTAGE: VOLTAGE
    });

    invertObject(screenIds$1);

    const getDayEnergies = 0x78;
    const getDayMaxPower = 0x79;
    const errorResponse$1 = 0xfe;

    var uplinkIds$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activateRatePlan: activateRatePlan$1,
        errorResponse: errorResponse$1,
        getBuildVersion: getBuildVersion$1,
        getCorrectTime: getCorrectTime$1,
        getCriticalEvent: getCriticalEvent$1,
        getCurrentStatusMeter: getCurrentStatusMeter$1,
        getCurrentValues: getCurrentValues$1,
        getDateTime: getDateTime$1,
        getDayDemand: getDayDemand$1,
        getDayDemandExport: getDayDemandExport$1,
        getDayEnergies: getDayEnergies,
        getDayMaxDemand: getDayMaxDemand$1,
        getDayMaxDemandExport: getDayMaxDemandExport$1,
        getDayMaxDemandPrevious: getDayMaxDemandPrevious,
        getDayMaxPower: getDayMaxPower,
        getDayProfile: getDayProfile$1,
        getDemand: getDemand$1,
        getDeviceId: getDeviceId$1,
        getDeviceType: getDeviceType$1,
        getDisplayParam: getDisplayParam$1,
        getEnergy: getEnergy$1,
        getEnergyDayPrevious: getEnergyDayPrevious$1,
        getEnergyExport: getEnergyExport$1,
        getEnergyExportDayPrevious: getEnergyExportDayPrevious$1,
        getEventStatus: getEventStatus$1,
        getEvents: getEvents$1,
        getEventsCounters: getEventsCounters$1,
        getExtendedCurrentValues: getExtendedCurrentValues$1,
        getExtendedCurrentValues2: getExtendedCurrentValues2,
        getHalfHourDemand: getHalfHourDemand$1,
        getHalfHourDemandExport: getHalfHourDemandExport$1,
        getHalfHourDemandPrevious: getHalfHourDemandPrevious,
        getHalfhoursEnergies: getHalfhoursEnergies$1,
        getMagneticFieldThreshold: getMagneticFieldThreshold$1,
        getMeterInfo: getMeterInfo$1,
        getMonthDemand: getMonthDemand$1,
        getMonthDemandExport: getMonthDemandExport$1,
        getMonthMaxDemand: getMonthMaxDemand$1,
        getMonthMaxDemandExport: getMonthMaxDemandExport$1,
        getOperatorParameters: getOperatorParameters$1,
        getOperatorParametersExtended3: getOperatorParametersExtended3$1,
        getRatePlanInfo: getRatePlanInfo$1,
        getSaldo: getSaldo$1,
        getSaldoParameters: getSaldoParameters$1,
        getSeasonProfile: getSeasonProfile$1,
        getSpecialDay: getSpecialDay$1,
        getVersion: getVersion$1,
        prepareRatePlan: prepareRatePlan$1,
        resetPowerMaxDay: resetPowerMaxDay$1,
        resetPowerMaxMonth: resetPowerMaxMonth$1,
        runTariffPlan: runTariffPlan$1,
        setAccessKey: setAccessKey$1,
        setCorrectDateTime: setCorrectDateTime$1,
        setCorrectTime: setCorrectTime$1,
        setDateTime: setDateTime$1,
        setDayProfile: setDayProfile$1,
        setDisplayParam: setDisplayParam$1,
        setOperatorParameters: setOperatorParameters$1,
        setOperatorParametersExtended3: setOperatorParametersExtended3$1,
        setSaldo: setSaldo$1,
        setSaldoParameters: setSaldoParameters$1,
        setSeasonProfile: setSeasonProfile$1,
        setSpecialDay: setSpecialDay$1,
        setSpecialOperation: setSpecialOperation$1,
        turnRelayOff: turnRelayOff$1,
        turnRelayOn: turnRelayOn$1
    });

    var commandNames = invertObject(uplinkIds$1);

    commandNames$1[getDisplayParam$1];

    commandNames$1[getEnergy$1];

    commandNames$1[getEnergyDayPrevious$1];

    commandNames$1[getEnergyExport$1];

    commandNames$1[getEnergyExportDayPrevious$1];

    const id$22 = getEvents$1;
    commandNames$1[getEvents$1];
    const maxSize$1H = 4;
    const fromBytes$24 = (bytes) => {
        if (bytes.length !== maxSize$1H) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new CommandBinaryBuffer$2(bytes);
        const date = buffer.getDate();
        const offset = buffer.getUint8();
        return { date, offset };
    };
    const toBytes$24 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1H);
        buffer.setDate(parameters.date);
        buffer.setUint8(parameters.offset);
        return toBytes$2g(id$22, buffer.data);
    };

    const id$21 = getEventsCounters$1;
    commandNames$1[getEventsCounters$1];
    const maxSize$1G = 0;
    const fromBytes$23 = (bytes) => {
        if (bytes.length !== maxSize$1G) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$23 = () => toBytes$2g(id$21);

    const id$20 = getEventStatus$1;
    commandNames$1[getEventStatus$1];
    const maxSize$1F = 0;
    const fromBytes$22 = (bytes) => {
        if (bytes.length !== maxSize$1F) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$22 = () => toBytes$2g(id$20);

    const id$1$ = getExtendedCurrentValues$1;
    commandNames$1[getExtendedCurrentValues$1];
    const maxSize$1E = 0;
    const fromBytes$21 = (bytes) => {
        if (bytes.length !== maxSize$1E) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$21 = () => toBytes$2g(id$1$);

    commandNames$1[getExtendedCurrentValues2];

    const id$1_ = getHalfHourDemand$1;
    commandNames$1[getHalfHourDemand$1];
    const maxSize$1D = 3;
    const fromBytes$20 = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return { date: buffer.getDate() };
    };
    const toBytes$20 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1D);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$1_, buffer.data);
    };

    const id$1Z = getHalfHourDemandExport$1;
    commandNames$1[getHalfHourDemandExport$1];
    const maxSize$1C = 3;
    const fromBytes$1$ = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return { date: buffer.getDate() };
    };
    const toBytes$1$ = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1C);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$1Z, buffer.data);
    };

    commandNames$1[getHalfHourDemandPrevious];

    const TARIFF_NUMBER = 4;
    const UNDEFINED_ENERGY_VALUE = 0xffffffff;
    const energiesMask = {
        'A+': 0x01,
        'A+R+': 0x02,
        'A+R-': 0x04,
        'A-': 0x08,
        'A-R+': 0x10,
        'A-R-': 0x20
    };
    const getEnergiesFlags = (energies) => {
        const booleanObject = {};
        Object.keys(energies).forEach(name => {
            booleanObject[name] = !!energies[name];
        });
        return fromObject(energiesMask, booleanObject);
    };
    const getAPlusTariffBit = (tariff) => (tariff < TARIFF_NUMBER ? (1 << tariff) : 0);
    const getAMinusTariffBit = (tariff) => (tariff < TARIFF_NUMBER ? ((1 << tariff) << 4) : 0);
    const getTariffEnergiesFlag = (tariff, energies) => {
        let flag = 0;
        if (tariff < TARIFF_NUMBER) {
            if (energies['A+'] || energies['A+R+'] || energies['A+R-']) {
                flag |= getAPlusTariffBit(tariff);
            }
            if (energies['A-'] || energies['A-R+'] || energies['A-R-']) {
                flag |= getAMinusTariffBit(tariff);
            }
        }
        return flag;
    };
    function CommandBinaryBuffer$1(dataOrLength, isLittleEndian = false) {
        BinaryBuffer.call(this, dataOrLength, isLittleEndian);
    }
    CommandBinaryBuffer$1.prototype = Object.create(BinaryBuffer.prototype);
    CommandBinaryBuffer$1.prototype.constructor = CommandBinaryBuffer$1;
    CommandBinaryBuffer$1.prototype.getDate = function () {
        const date0 = this.getUint8();
        const date1 = this.getUint8();
        return {
            year: date0 >> 1,
            month: ((date0 << 3) & 0x0f) | (date1 >> 5),
            date: date1 & 0x1f
        };
    };
    CommandBinaryBuffer$1.prototype.setDate = function ({ year, month, date }) {
        const date0 = (year << 1) | ((month >> 3) & 0x01);
        const date1 = ((month << 5) & 0xe0) | (date & 0x1f);
        this.setUint8(date0);
        this.setUint8(date1);
    };
    CommandBinaryBuffer$1.prototype.getEnergiesFlags = function () {
        const byte = this.getUint8();
        return toObject(energiesMask, byte);
    };
    CommandBinaryBuffer$1.prototype.setEnergiesFlags = function (energies) {
        this.setUint8(getEnergiesFlags(energies));
    };
    CommandBinaryBuffer$1.prototype.getHalfhoursEnergy = function (halfhoursNumber) {
        const halfhours = [];
        for (let index = 0; index < halfhoursNumber; index++) {
            const value = this.getUint16();
            halfhours.push(value === UNDEFINED_ENERGY_VALUE ? undefined : value);
        }
        return halfhours;
    };
    CommandBinaryBuffer$1.prototype.setHalfhoursEnergy = function (halfhours) {
        if (halfhours) {
            for (let index = 0; index < halfhours.length; index++) {
                const value = halfhours[index];
                this.setUint16(value === undefined ? UNDEFINED_ENERGY_VALUE : value);
            }
        }
    };
    CommandBinaryBuffer$1.prototype.getHalfhoursEnergies = function (energiesFlags, halfhoursNumber) {
        const energies = {};
        if (energiesFlags['A+']) {
            energies['A+'] = this.getHalfhoursEnergy(halfhoursNumber);
        }
        if (energiesFlags['A+R+']) {
            energies['A+R+'] = this.getHalfhoursEnergy(halfhoursNumber);
        }
        if (energiesFlags['A+R-']) {
            energies['A+R-'] = this.getHalfhoursEnergy(halfhoursNumber);
        }
        if (energiesFlags['A-']) {
            energies['A-'] = this.getHalfhoursEnergy(halfhoursNumber);
        }
        if (energiesFlags['A-R+']) {
            energies['A-R+'] = this.getHalfhoursEnergy(halfhoursNumber);
        }
        if (energiesFlags['A-R-']) {
            energies['A-R-'] = this.getHalfhoursEnergy(halfhoursNumber);
        }
        return energies;
    };
    CommandBinaryBuffer$1.prototype.setHalfhoursEnergies = function (energies) {
        this.setHalfhoursEnergy(energies['A+']);
        this.setHalfhoursEnergy(energies['A+R+']);
        this.setHalfhoursEnergy(energies['A+R-']);
        this.setHalfhoursEnergy(energies['A-']);
        this.setHalfhoursEnergy(energies['A-R+']);
        this.setHalfhoursEnergy(energies['A-R-']);
    };
    CommandBinaryBuffer$1.prototype.getAPlusTariffEnergies = function (energyFlags) {
        const energies = {};
        if (energyFlags & energiesMask['A+']) {
            energies['A+'] = this.getUint32();
        }
        if (energyFlags & energiesMask['A+R+']) {
            energies['A+R+'] = this.getUint32();
        }
        if (energyFlags & energiesMask['A+R-']) {
            energies['A+R-'] = this.getUint32();
        }
        return energies;
    };
    CommandBinaryBuffer$1.prototype.setAPlusTariffEnergies = function (energies) {
        if (energies) {
            if (energies['A+']) {
                this.setUint32(energies['A+']);
            }
            if (energies['A+R+']) {
                this.setUint32(energies['A+R+']);
            }
            if (energies['A+R-']) {
                this.setUint32(energies['A+R-']);
            }
        }
    };
    CommandBinaryBuffer$1.prototype.getAMinusTariffEnergies = function (energyFlags) {
        const energies = {};
        if (energyFlags & energiesMask['A-']) {
            energies['A-'] = this.getUint32();
        }
        if (energyFlags & energiesMask['A-R+']) {
            energies['A-R+'] = this.getUint32();
        }
        if (energyFlags & energiesMask['A-R-']) {
            energies['A-R-'] = this.getUint32();
        }
        return energies;
    };
    CommandBinaryBuffer$1.prototype.setAMinusTariffEnergies = function (energies) {
        if (energies) {
            if (energies['A-']) {
                this.setUint32(energies['A-']);
            }
            if (energies['A-R+']) {
                this.setUint32(energies['A-R+']);
            }
            if (energies['A-R-']) {
                this.setUint32(energies['A-R-']);
            }
        }
    };
    CommandBinaryBuffer$1.prototype.getTariffsEnergies = function () {
        const energyFlags = this.getUint8();
        const tariffFlags = this.getUint8();
        const tariffs = new Array(TARIFF_NUMBER).fill(null);
        for (let index = 0; index < TARIFF_NUMBER; index++) {
            if (tariffFlags & getAPlusTariffBit(index)) {
                tariffs[index] = this.getAPlusTariffEnergies(energyFlags);
            }
        }
        for (let index = 0; index < TARIFF_NUMBER; index++) {
            if (tariffFlags & getAMinusTariffBit(index)) {
                tariffs[index] = { ...tariffs[index], ...this.getAMinusTariffEnergies(energyFlags) };
            }
        }
        return tariffs;
    };
    CommandBinaryBuffer$1.prototype.setTariffsEnergies = function (tariffs) {
        let energiesFlags = 0;
        let tariffsFlags = 0;
        tariffs.forEach((tariff, index) => {
            if (tariff) {
                energiesFlags |= getEnergiesFlags(tariff);
                tariffsFlags |= getTariffEnergiesFlag(index, tariff);
            }
        });
        this.setUint8(energiesFlags);
        this.setUint8(tariffsFlags);
        tariffs.forEach(tariff => this.setAPlusTariffEnergies(tariff));
        tariffs.forEach(tariff => this.setAMinusTariffEnergies(tariff));
    };
    CommandBinaryBuffer$1.prototype.getPowerMax = function () {
        return {
            hours: this.getUint8(),
            minutes: this.getUint8(),
            power: this.getUint32()
        };
    };
    CommandBinaryBuffer$1.prototype.setPowerMax = function (value) {
        if (value) {
            const { hours, minutes, power } = value;
            this.setUint8(hours);
            this.setUint8(minutes);
            this.setUint32(power);
        }
    };
    CommandBinaryBuffer$1.prototype.getAPlusTariffPowerMax = function (energyFlags) {
        const energies = {};
        if (energyFlags & energiesMask['A+']) {
            energies['A+'] = this.getPowerMax();
        }
        if (energyFlags & energiesMask['A+R+']) {
            energies['A+R+'] = this.getPowerMax();
        }
        if (energyFlags & energiesMask['A+R-']) {
            energies['A+R-'] = this.getPowerMax();
        }
        return energies;
    };
    CommandBinaryBuffer$1.prototype.setAPlusTariffPowerMax = function (energies) {
        if (energies) {
            this.setPowerMax(energies['A+']);
            this.setPowerMax(energies['A+R+']);
            this.setPowerMax(energies['A+R+']);
        }
    };
    CommandBinaryBuffer$1.prototype.getAMinusTariffPowerMax = function (energyFlags) {
        const energies = {};
        if (energyFlags & energiesMask['A-']) {
            energies['A-'] = this.getPowerMax();
        }
        if (energyFlags & energiesMask['A-R+']) {
            energies['A-R+'] = this.getPowerMax();
        }
        if (energyFlags & energiesMask['A-R-']) {
            energies['A-R-'] = this.getPowerMax();
        }
        return energies;
    };
    CommandBinaryBuffer$1.prototype.setAMinusTariffPowerMax = function (energies) {
        if (energies) {
            this.setPowerMax(energies['A-']);
            this.setPowerMax(energies['A-R+']);
            this.setPowerMax(energies['A-R-']);
        }
    };
    CommandBinaryBuffer$1.prototype.getTariffsPowerMax = function () {
        const energyFlags = this.getUint8();
        const tariffFlags = this.getUint8();
        const tariffs = new Array(TARIFF_NUMBER).fill(null);
        for (let index = 0; index < TARIFF_NUMBER; index++) {
            if (tariffFlags & getAPlusTariffBit(index)) {
                tariffs[index] = this.getAPlusTariffPowerMax(energyFlags);
            }
        }
        for (let index = 0; index < TARIFF_NUMBER; index++) {
            if (tariffFlags & getAMinusTariffBit(index)) {
                tariffs[index] = { ...tariffs[index], ...this.getAMinusTariffPowerMax(energyFlags) };
            }
        }
        return tariffs;
    };
    CommandBinaryBuffer$1.prototype.setTariffsPowerMax = function (tariffs) {
        let energiesFlags = 0;
        let tariffsFlags = 0;
        tariffs.forEach((tariff, index) => {
            if (tariff) {
                energiesFlags |= getEnergiesFlags(tariff);
                tariffsFlags |= getTariffEnergiesFlag(index, tariff);
            }
        });
        this.setUint8(energiesFlags);
        this.setUint8(tariffsFlags);
        tariffs.forEach(tariff => this.setAPlusTariffPowerMax(tariff));
        tariffs.forEach(tariff => this.setAMinusTariffPowerMax(tariff));
    };

    const id$1Y = getHalfhoursEnergies$1;
    commandNames$1[getHalfhoursEnergies$1];
    const maxSize$1B = 5;
    const fromBytes$1_ = (bytes) => {
        const buffer = new CommandBinaryBuffer$1(bytes);
        return {
            date: buffer.getDate(),
            energies: buffer.getEnergiesFlags(),
            firstHalfhour: buffer.getUint8(),
            halfhoursNumber: buffer.getUint8()
        };
    };
    const toBytes$1_ = (parameters) => {
        const buffer = new CommandBinaryBuffer$1(maxSize$1B);
        buffer.setDate(parameters.date);
        buffer.setEnergiesFlags(parameters.energies);
        buffer.setUint8(parameters.firstHalfhour);
        buffer.setUint8(parameters.halfhoursNumber);
        return toBytes$2g(id$1Y, buffer.data);
    };

    const id$1X = getMagneticFieldThreshold$1;
    commandNames$1[getMagneticFieldThreshold$1];
    const maxSize$1A = 0;
    const fromBytes$1Z = (bytes) => {
        if (bytes.length !== maxSize$1A) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1Z = () => toBytes$2g(id$1X);

    const id$1W = getMeterInfo$1;
    commandNames$1[getMeterInfo$1];
    const maxSize$1z = 0;
    const fromBytes$1Y = (bytes) => {
        if (bytes.length !== maxSize$1z) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1Y = () => toBytes$2g(id$1W);

    const id$1V = getMonthDemand$1;
    commandNames$1[getMonthDemand$1];
    const maxSize$1y = 2;
    const fromBytes$1X = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            year: buffer.getUint8(),
            month: buffer.getUint8()
        };
    };
    const toBytes$1X = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1y);
        buffer.setUint8(parameters.year);
        buffer.setUint8(parameters.month);
        return toBytes$2g(id$1V, buffer.data);
    };

    const id$1U = getMonthDemandExport$1;
    commandNames$1[getMonthDemandExport$1];
    const maxSize$1x = 2;
    const fromBytes$1W = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            year: buffer.getUint8(),
            month: buffer.getUint8()
        };
    };
    const toBytes$1W = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1x);
        buffer.setUint8(parameters.year);
        buffer.setUint8(parameters.month);
        return toBytes$2g(id$1U, buffer.data);
    };

    const id$1T = getMonthMaxDemand$1;
    commandNames$1[getMonthMaxDemand$1];
    const fromBytes$1V = (bytes) => {
        const [year, month] = bytes;
        return { year, month };
    };
    const toBytes$1V = ({ year, month }) => (toBytes$2g(id$1T, [year, month]));

    const id$1S = getMonthMaxDemandExport$1;
    commandNames$1[getMonthMaxDemandExport$1];
    const fromBytes$1U = (bytes) => {
        const [year, month] = bytes;
        return { year, month };
    };
    const toBytes$1U = ({ year, month }) => (toBytes$2g(id$1S, [year, month]));

    const id$1R = getOperatorParametersExtended3$1;
    commandNames$1[getOperatorParametersExtended3$1];
    const maxSize$1w = 0;
    const fromBytes$1T = (bytes) => {
        if (bytes.length !== maxSize$1w) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1T = () => toBytes$2g(id$1R);

    const id$1Q = getOperatorParameters$1;
    commandNames$1[getOperatorParameters$1];
    const maxSize$1v = 0;
    const fromBytes$1S = (bytes) => {
        if (bytes.length !== maxSize$1v) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1S = () => toBytes$2g(id$1Q);

    const id$1P = getRatePlanInfo$1;
    commandNames$1[getRatePlanInfo$1];
    const fromBytes$1R = (bytes) => ({ tariffTable: bytes[0] });
    const toBytes$1R = (parameters) => (toBytes$2g(id$1P, [parameters.tariffTable]));

    const id$1O = getSaldo$1;
    commandNames$1[getSaldo$1];
    const maxSize$1u = 0;
    const fromBytes$1Q = (bytes) => {
        if (bytes.length !== maxSize$1u) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1Q = () => toBytes$2g(id$1O);

    const id$1N = getSaldoParameters$1;
    commandNames$1[getSaldoParameters$1];
    const maxSize$1t = 0;
    const fromBytes$1P = (bytes) => {
        if (bytes.length !== maxSize$1t) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1P = () => toBytes$2g(id$1N);

    const id$1M = getSeasonProfile$1;
    commandNames$1[getSeasonProfile$1];
    const maxSize$1s = 3;
    const fromBytes$1O = ([tariffTable, index, isActive]) => ({ tariffTable, index, isActive: isActive === 0 });
    const toBytes$1O = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1s);
        buffer.setUint8(parameters.tariffTable);
        buffer.setUint8(parameters.index);
        buffer.setUint8(parameters.isActive ? 0 : 1);
        return toBytes$2g(id$1M, buffer.data);
    };

    const id$1L = getSpecialDay$1;
    commandNames$1[getSpecialDay$1];
    const maxSize$1r = 3;
    const fromBytes$1N = ([tariffTable, index, isActive]) => ({ tariffTable, index, isActive: isActive === 0 });
    const toBytes$1N = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1r);
        buffer.setUint8(parameters.tariffTable);
        buffer.setUint8(parameters.index);
        buffer.setUint8(parameters.isActive ? 0 : 1);
        return toBytes$2g(id$1L, buffer.data);
    };

    const id$1K = getVersion$1;
    commandNames$1[getVersion$1];
    const maxSize$1q = 0;
    const fromBytes$1M = (bytes) => {
        if (bytes.length !== maxSize$1q) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1M = () => toBytes$2g(id$1K);

    const id$1J = prepareRatePlan$1;
    commandNames$1[prepareRatePlan$1];
    const maxSize$1p = 5;
    const fromBytes$1L = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            tariffTable: buffer.getUint8(),
            id: buffer.getUint32()
        };
    };
    const toBytes$1L = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1p);
        buffer.setUint8(parameters.tariffTable);
        buffer.setUint32(parameters.id);
        return toBytes$2g(id$1J, buffer.data);
    };

    const id$1I = resetPowerMaxDay$1;
    commandNames$1[resetPowerMaxDay$1];
    const maxSize$1o = 0;
    const fromBytes$1K = (bytes) => {
        if (bytes.length !== maxSize$1o) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1K = () => toBytes$2g(id$1I);

    const id$1H = resetPowerMaxMonth$1;
    commandNames$1[resetPowerMaxMonth$1];
    const maxSize$1n = 0;
    const fromBytes$1J = (bytes) => {
        if (bytes.length !== maxSize$1n) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1J = () => toBytes$2g(id$1H);

    const id$1G = runTariffPlan$1;
    commandNames$1[runTariffPlan$1];
    const fromBytes$1I = (bytes) => ({ tariffTable: bytes[0] });
    const toBytes$1I = (parameters) => (toBytes$2g(id$1G, [parameters.tariffTable]));

    const KEY_SIZE = 16;
    const id$1F = setAccessKey$1;
    commandNames$1[setAccessKey$1];
    const maxSize$1m = 1 + KEY_SIZE;
    const fromBytes$1H = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            accessLevel: buffer.getUint8(),
            key: buffer.getBytes(KEY_SIZE)
        };
    };
    const toBytes$1H = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1m);
        buffer.setUint8(parameters.accessLevel);
        buffer.setBytes(parameters.key);
        return toBytes$2g(id$1F, buffer.data);
    };

    const id$1E = setCorrectDateTime$1;
    commandNames$1[setCorrectDateTime$1];
    const maxSize$1l = 2;
    const fromBytes$1G = (bytes) => {
        if (bytes.length !== maxSize$1l) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new CommandBinaryBuffer$2(bytes);
        return { seconds: buffer.getInt16() };
    };
    const toBytes$1G = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1l);
        buffer.setInt16(parameters.seconds);
        return toBytes$2g(id$1E, buffer.data);
    };

    const id$1D = setCorrectTime$1;
    commandNames$1[setCorrectTime$1];
    const maxSize$1k = 9;
    const fromBytes$1F = (bytes) => {
        if (bytes.length !== maxSize$1k) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getTimeCorrectionParameters();
    };
    const toBytes$1F = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1k);
        buffer.setTimeCorrectionParameters(parameters);
        return toBytes$2g(id$1D, buffer.data);
    };

    const id$1C = setDateTime$1;
    commandNames$1[setDateTime$1];
    const maxSize$1j = 8;
    const fromBytes$1E = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getDateTime();
    };
    const toBytes$1E = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1j);
        buffer.setDateTime(parameters);
        return toBytes$2g(id$1C, buffer.data);
    };

    const MAX_PERIODS_NUMBER$1 = 8;
    const PERIODS_FINAL_BYTE$1 = 0xff;
    const id$1B = setDayProfile$1;
    commandNames$1[setDayProfile$1];
    const fromBytes$1D = (bytes) => {
        const finalByteIndex = bytes.indexOf(PERIODS_FINAL_BYTE$1);
        const cleanBytes = finalByteIndex === -1 ? bytes : bytes.slice(0, finalByteIndex);
        const buffer = new CommandBinaryBuffer$2(cleanBytes);
        return {
            tariffTable: buffer.getUint8(),
            index: buffer.getUint8(),
            periods: [...cleanBytes.slice(buffer.offset)].map(CommandBinaryBuffer$2.getDayProfileFromByte)
        };
    };
    const toBytes$1D = (parameters) => {
        const hasPeriodsFinalByte = parameters.periods.length < MAX_PERIODS_NUMBER$1;
        const size = 2 + parameters.periods.length + +hasPeriodsFinalByte;
        const buffer = new CommandBinaryBuffer$2(size);
        buffer.setUint8(parameters.tariffTable);
        buffer.setUint8(parameters.index);
        parameters.periods.forEach(period => {
            buffer.setDayProfile(period);
        });
        if (hasPeriodsFinalByte) {
            buffer.setUint8(PERIODS_FINAL_BYTE$1);
        }
        return toBytes$2g(id$1B, buffer.data);
    };

    commandNames$1[setDisplayParam$1];

    const id$1A = setOperatorParametersExtended3$1;
    commandNames$1[setOperatorParametersExtended3$1];
    const maxSize$1i = 17;
    const fromBytes$1C = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getOperatorParametersExtended3();
    };
    const toBytes$1C = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1i);
        buffer.setOperatorParametersExtended3(parameters);
        return toBytes$2g(id$1A, buffer.data);
    };

    commandNames$1[setOperatorParameters$1];

    const id$1z = setSaldo$1;
    commandNames$1[setSaldo$1];
    const maxSize$1h = 12;
    const fromBytes$1B = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            date: {
                month: buffer.getUint8(),
                date: buffer.getUint8(),
                hours: buffer.getUint8(),
                minutes: buffer.getUint8()
            },
            saldoNew: buffer.getInt32(),
            saldoOld: buffer.getInt32()
        };
    };
    const toBytes$1B = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1h);
        buffer.setUint8(parameters.date.month);
        buffer.setUint8(parameters.date.date);
        buffer.setUint8(parameters.date.hours);
        buffer.setUint8(parameters.date.minutes);
        buffer.setInt32(parameters.saldoNew);
        buffer.setInt32(parameters.saldoOld);
        return toBytes$2g(id$1z, buffer.data);
    };

    const id$1y = setSaldoParameters$1;
    commandNames$1[setSaldoParameters$1];
    const maxSize$1g = 37;
    const fromBytes$1A = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getSaldoParameters();
    };
    const toBytes$1A = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1g);
        buffer.setSaldoParameters(parameters);
        return toBytes$2g(id$1y, buffer.data);
    };

    const id$1x = setSeasonProfile$1;
    commandNames$1[setSeasonProfile$1];
    const maxSize$1f = SEASON_PROFILE_SIZE;
    const fromBytes$1z = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            tariffTable: buffer.getUint8(),
            index: buffer.getUint8(),
            ...buffer.getSeasonProfile()
        };
    };
    const toBytes$1z = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1f);
        buffer.setUint8(parameters.tariffTable);
        buffer.setUint8(parameters.index);
        buffer.setSeasonProfile(parameters);
        return toBytes$2g(id$1x, buffer.data);
    };

    const id$1w = setSpecialDay$1;
    commandNames$1[setSpecialDay$1];
    const maxSize$1e = 6;
    const fromBytes$1y = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            tariffTable: buffer.getUint8(),
            index: buffer.getUint8(),
            ...buffer.getSpecialDay()
        };
    };
    const toBytes$1y = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1e);
        buffer.setUint8(parameters.tariffTable);
        buffer.setUint8(parameters.index);
        buffer.setSpecialDay(parameters);
        return toBytes$2g(id$1w, buffer.data);
    };

    const id$1v = setSpecialOperation$1;
    commandNames$1[setSpecialOperation$1];
    const maxSize$1d = 2;
    const fromBytes$1x = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        const type = buffer.getUint8();
        const flags = buffer.getUint8();
        const readScreensInfo = !!(flags & 0x80);
        const resetElectroMagneticIndication = !!(flags & 1);
        const resetMagneticIndication = !!(flags & 2);
        return {
            type,
            readScreensInfo,
            resetElectroMagneticIndication,
            resetMagneticIndication
        };
    };
    const toBytes$1x = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$1d);
        let flags = 0;
        if (parameters.readScreensInfo) {
            flags |= 0x80;
        }
        if (parameters.resetElectroMagneticIndication) {
            flags |= 1;
        }
        if (parameters.resetMagneticIndication) {
            flags |= 2;
        }
        buffer.setUint8(parameters.type);
        buffer.setUint8(flags);
        return toBytes$2g(id$1v, buffer.data);
    };

    const id$1u = turnRelayOff$1;
    commandNames$1[turnRelayOff$1];
    const maxSize$1c = 0;
    const fromBytes$1w = (bytes) => {
        if (bytes.length !== maxSize$1c) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1w = () => toBytes$2g(id$1u);

    const id$1t = turnRelayOn$1;
    commandNames$1[turnRelayOn$1];
    const maxSize$1b = 0;
    const fromBytes$1v = (bytes) => {
        if (bytes.length !== maxSize$1b) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1v = () => toBytes$2g(id$1t);

    // this is required to shadow crypto-js implementation
    const aes = {
        encrypt: () => {},
        decrypt: () => {}
    };

    var calculateLrc = (data, initialLrc = 0x55) => {
        let lrc = initialLrc;
        data.forEach(item => {
            lrc ^= item;
        });
        return lrc;
    };

    const ACCESS_LEVEL_MASK = 0x03;
    const MESSAGE_HEADER_SIZE = 2;
    const BLOCK_SIZE = 16;
    const COMMANDS_END_MARK = [0];
    const COMMAND_HEADER_SIZE = 2;
    const getFromBytes$2 = (fromBytesMap, nameMap) => (bytes = [], config = {}) => {
        const aesKey = config?.aesKey;
        const commands = [];
        const [messageId, maskedAccessLevel] = bytes;
        const accessLevel = maskedAccessLevel & ACCESS_LEVEL_MASK;
        const message = {
            messageId,
            accessLevel,
            commands,
            bytes,
            lrc: { received: undefined, calculated: 0 }
        };
        let messageBody = bytes.slice(MESSAGE_HEADER_SIZE);
        let error;
        if (aesKey && accessLevel !== UNENCRYPTED) {
            messageBody = [...aes.decrypt(aesKey, messageBody)];
        }
        const receivedLrc = messageBody[messageBody.length - 1];
        messageBody = messageBody.slice(0, -1);
        const calculatedLrc = calculateLrc(messageBody);
        if (accessLevel !== UNENCRYPTED || receivedLrc !== 0) {
            if (receivedLrc !== calculatedLrc) {
                error = 'Mismatch LRC.';
            }
        }
        const accessLevel2 = messageBody[0] & ACCESS_LEVEL_MASK;
        const commandsData = messageBody.slice(1);
        if (accessLevel !== accessLevel2) {
            error = 'Mismatch access levels.';
        }
        let position = 0;
        do {
            const commandId = commandsData[position];
            const commandBodySize = commandsData[position + 1];
            const commandSize = COMMAND_HEADER_SIZE + commandBodySize;
            const commandBody = commandsData.slice(position + COMMAND_HEADER_SIZE, position + commandSize);
            const command = {
                id: commandId,
                name: nameMap[commandId],
                headerSize: COMMAND_HEADER_SIZE,
                bytes: commandsData.slice(position, position + commandSize)
            };
            if (!commandId) {
                break;
            }
            try {
                if (!fromBytesMap[commandId]) {
                    throw new Error(`Unsupported command id: ${commandId}!`);
                }
                command.parameters = fromBytesMap[commandId](commandBody, config);
                commands.push(command);
            }
            catch (exception) {
                commands.push({
                    command,
                    error: exception.message
                });
            }
            position += commandSize;
        } while (position <= commandsData.length);
        message.lrc.calculated = calculatedLrc;
        message.lrc.received = receivedLrc;
        if (error) {
            return {
                message,
                error
            };
        }
        return message;
    };
    const getToBytes$1 = toBytesMap => (commands, { messageId = 1, accessLevel = READ_ONLY, aesKey }) => {
        const commandBytes = commands.map(command => {
            if ('id' in command) {
                return toBytesMap[command.id](command.parameters || {});
            }
            if ('command' in command) {
                return command.command.bytes;
            }
            throw new Error('wrong command format');
        });
        const maskedAccessLevel = accessLevel | 0x10;
        const header = [messageId, maskedAccessLevel];
        let body = [].concat(maskedAccessLevel, ...commandBytes, COMMANDS_END_MARK);
        if (accessLevel !== UNENCRYPTED) {
            const padding = (body.length + 1) % BLOCK_SIZE;
            if (padding) {
                body = body.concat(new Array(BLOCK_SIZE - padding).fill(0));
            }
        }
        body = body.concat(calculateLrc(body));
        if (aesKey && accessLevel !== UNENCRYPTED) {
            body = [...aes.encrypt(aesKey, body)];
        }
        return header.concat(body);
    };

    const getEventStatus = 0x01;
    const getEnergyDayPrevious = 0x03;
    const getDeviceType = 0x04;
    const getDeviceId = 0x05;
    const getDateTime = 0x07;
    const setDateTime = 0x08;
    const setAccessKey = 0x09;
    const getCurrentValues = 0x0d;
    const getEnergy = 0x0f;
    const setDayProfile = 0x10;
    const setSeasonProfile = 0x11;
    const setSpecialDay = 0x12;
    const activateRatePlan = 0x13;
    const prepareRatePlan = 0x14;
    const getHalfHourDemand = 0x15;
    const getDayDemand = 0x16;
    const getMonthDemand = 0x17;
    const turnRelayOn = 0x18;
    const turnRelayOff = 0x19;
    const setCorrectTime = 0x1c;
    const getOperatorParameters = 0x1e;
    const setOperatorParameters = 0x1f;
    const getVersion = 0x28;
    const getSaldo = 0x29;
    const setSaldo = 0x2a;
    const getRatePlanInfo = 0x2c;
    const getSaldoParameters = 0x2e;
    const setSaldoParameters = 0x2f;
    const getDayMaxDemand = 0x31;
    const getMonthMaxDemand = 0x32;
    const getEvents = 0x33;
    const getEventsCounters = 0x34;
    const resetPowerMaxDay = 0x35;
    const resetPowerMaxMonth = 0x36;
    const getCurrentStatusMeter = 0x39;
    const getExtendedCurrentValues = 0x3a;
    const getDayProfile = 0x3b;
    const getSeasonProfile = 0x3c;
    const getSpecialDay = 0x3d;
    const getCorrectTime = 0x3e;
    const getOperatorParametersExtended = 0x3f;
    const setOperatorParametersExtended = 0x40;
    const setOperatorParametersExtended2 = 0x45;
    const runTariffPlan = 0x46;
    const getOperatorParametersExtended2 = 0x47;
    const getHalfHourDemandVari = 0x48;
    const getHalfHourDemandVare = 0x49;
    const getEnergyExport = 0x4e;
    const getDayDemandExport = 0x4f;
    const getEnergyExportDayPrevious = 0x50;
    const getMonthDemandExport = 0x52;
    const getHalfHourDemandExport = 0x53;
    const getHalfHourDemandVariExport = 0x54;
    const getHalfHourDemandVareExport = 0x55;
    const getCriticalEvent = 0x56;
    const getDayMaxDemandExport = 0x58;
    const getMonthMaxDemandExport = 0x59;
    const getHalfHourDemandChannel = 0x5a;
    const setCorrectDateTime = 0x5c;
    const setDisplayParam = 0x5d;
    const getDisplayParam = 0x5e;
    const setSpecialOperation = 0x64;
    const getMagneticFieldThreshold = 0x6d;
    const getHalfhoursEnergies = 0x6f;
    const getBuildVersion = 0x70;
    const getOperatorParametersExtended3 = 0x71;
    const setOperatorParametersExtended3 = 0x72;
    const setOperatorParametersExtended4 = 0x75;
    const getDemand = 0x76;
    const getMeterInfo = 0x7a;

    var downlinkIds = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activateRatePlan: activateRatePlan,
        getBuildVersion: getBuildVersion,
        getCorrectTime: getCorrectTime,
        getCriticalEvent: getCriticalEvent,
        getCurrentStatusMeter: getCurrentStatusMeter,
        getCurrentValues: getCurrentValues,
        getDateTime: getDateTime,
        getDayDemand: getDayDemand,
        getDayDemandExport: getDayDemandExport,
        getDayMaxDemand: getDayMaxDemand,
        getDayMaxDemandExport: getDayMaxDemandExport,
        getDayProfile: getDayProfile,
        getDemand: getDemand,
        getDeviceId: getDeviceId,
        getDeviceType: getDeviceType,
        getDisplayParam: getDisplayParam,
        getEnergy: getEnergy,
        getEnergyDayPrevious: getEnergyDayPrevious,
        getEnergyExport: getEnergyExport,
        getEnergyExportDayPrevious: getEnergyExportDayPrevious,
        getEventStatus: getEventStatus,
        getEvents: getEvents,
        getEventsCounters: getEventsCounters,
        getExtendedCurrentValues: getExtendedCurrentValues,
        getHalfHourDemand: getHalfHourDemand,
        getHalfHourDemandChannel: getHalfHourDemandChannel,
        getHalfHourDemandExport: getHalfHourDemandExport,
        getHalfHourDemandVare: getHalfHourDemandVare,
        getHalfHourDemandVareExport: getHalfHourDemandVareExport,
        getHalfHourDemandVari: getHalfHourDemandVari,
        getHalfHourDemandVariExport: getHalfHourDemandVariExport,
        getHalfhoursEnergies: getHalfhoursEnergies,
        getMagneticFieldThreshold: getMagneticFieldThreshold,
        getMeterInfo: getMeterInfo,
        getMonthDemand: getMonthDemand,
        getMonthDemandExport: getMonthDemandExport,
        getMonthMaxDemand: getMonthMaxDemand,
        getMonthMaxDemandExport: getMonthMaxDemandExport,
        getOperatorParameters: getOperatorParameters,
        getOperatorParametersExtended: getOperatorParametersExtended,
        getOperatorParametersExtended2: getOperatorParametersExtended2,
        getOperatorParametersExtended3: getOperatorParametersExtended3,
        getRatePlanInfo: getRatePlanInfo,
        getSaldo: getSaldo,
        getSaldoParameters: getSaldoParameters,
        getSeasonProfile: getSeasonProfile,
        getSpecialDay: getSpecialDay,
        getVersion: getVersion,
        prepareRatePlan: prepareRatePlan,
        resetPowerMaxDay: resetPowerMaxDay,
        resetPowerMaxMonth: resetPowerMaxMonth,
        runTariffPlan: runTariffPlan,
        setAccessKey: setAccessKey,
        setCorrectDateTime: setCorrectDateTime,
        setCorrectTime: setCorrectTime,
        setDateTime: setDateTime,
        setDayProfile: setDayProfile,
        setDisplayParam: setDisplayParam,
        setOperatorParameters: setOperatorParameters,
        setOperatorParametersExtended: setOperatorParametersExtended,
        setOperatorParametersExtended2: setOperatorParametersExtended2,
        setOperatorParametersExtended3: setOperatorParametersExtended3,
        setOperatorParametersExtended4: setOperatorParametersExtended4,
        setSaldo: setSaldo,
        setSaldoParameters: setSaldoParameters,
        setSeasonProfile: setSeasonProfile,
        setSpecialDay: setSpecialDay,
        setSpecialOperation: setSpecialOperation,
        turnRelayOff: turnRelayOff,
        turnRelayOn: turnRelayOn
    });

    var downlinkNames = invertObject(downlinkIds);

    const ENERGY_T0_FAULT = 0x01;
    const ENERGY_T1_FAULT = 0x02;
    const ENERGY_T2_FAULT = 0x03;
    const ENERGY_T3_FAULT = 0x04;
    const ACCESS_LOCKED = 0x11;
    const ACCESS_UNLOCKED = 0x12;
    const ERR_ACCESS = 0x13;
    const CASE_OPEN = 0x14;
    const CASE_CLOSE = 0x15;
    const MAGNETIC_ON = 0x16;
    const MAGNETIC_OFF = 0x17;
    const CHANGE_ACCESS_KEY0 = 0x20;
    const CHANGE_ACCESS_KEY1 = 0x21;
    const CHANGE_ACCESS_KEY2 = 0x22;
    const CHANGE_ACCESS_KEY3 = 0x23;
    const CHANGE_PARAMETERS_LOCAL = 0x24;
    const CHANGE_PARAMETERS_REMOTE = 0x25;
    const CMD_CHANGE_TIME = 0x26;
    const CMD_RELAY_ON = 0x27;
    const CMD_RELAY_OFF = 0x28;
    const ENERGY_REGISTER_OVERFLOW = 0x31;
    const CHANGE_TARIFF_TABLE = 0x32;
    const SET_TARIFF_TABLE = 0x33;
    const SUMMER_TIME = 0x34;
    const WINTER_TIME = 0x35;
    const RELAY_ON = 0x36;
    const RELAY_OFF = 0x37;
    const RESTART = 0x38;
    const WD_RESTART = 0x39;
    const VA_MAX_OK = 0x40;
    const VA_MAX_OVER = 0x41;
    const VA_MIN_OK = 0x42;
    const VA_MIN_UNDER = 0x43;
    const VB_MAX_OK = 0x44;
    const VB_MAX_OVER = 0x45;
    const VB_MIN_OK = 0x46;
    const VB_MIN_UNDER = 0x47;
    const VC_MAX_OK = 0x48;
    const VC_MAX_OVER = 0x49;
    const VC_MIN_OK = 0x4A;
    const VC_MIN_UNDER = 0x4B;
    const F_MAX_OK = 0x4C;
    const F_MAX_OVER = 0x4D;
    const F_MIN_OK = 0x4E;
    const F_MIN_UNDER = 0x4F;
    const T_MAX_OK = 0x50;
    const T_MAX_OVER = 0x51;
    const T_MIN_OK = 0x52;
    const T_MIN_UNDER = 0x53;
    const IA_MAX_OK = 0x54;
    const IA_MAX_OVER = 0x55;
    const IB_MAX_OK = 0x56;
    const IB_MAX_OVER = 0x57;
    const IC_MAX_OK = 0x58;
    const IC_MAX_OVER = 0x59;
    const PA_MAX_OK = 0x5A;
    const PA_MAX_OVER = 0x5B;
    const PV_MAX_OK = 0x5C;
    const PV_MAX_OVER = 0x5D;
    const IDIFF_OK = 0x5E;
    const IDIFF_OVER = 0x5F;
    const CLOCK_OK = 0x60;
    const CLOCK_FAULT = 0x61;
    const POWER_C_ON = 0x62;
    const POWER_C_OFF = 0x63;
    const POWER_B_ON = 0x64;
    const POWER_B_OFF = 0x65;
    const POWER_A_ON = 0x66;
    const POWER_A_OFF = 0x67;
    const BATTERY_OK = 0x68;
    const BATTERY_FAULT = 0x69;
    const CALIBRATION_OK = 0x6A;
    const CALIBRATION_FAULT = 0x6B;
    const V_PARAMETERS_OK = 0x6C;
    const V_PARAMETERS_FAULT = 0x6D;
    const O_PARAMETERS_OK = 0x6E;
    const O_PARAMETERS_FAULT = 0x6F;
    const CHANGE_COR_TIME = 0x70;
    const CMD_RELAY_2_ON = 0x71;
    const CMD_RELAY_2_OFF = 0x72;
    const CROSS_ZERO_ENT0 = 0x73;
    const CROSS_ZERO_ENT1 = 0x74;
    const CROSS_ZERO_ENT2 = 0x75;
    const CROSS_ZERO_ENT3 = 0x76;
    const CROSS_ZERO_VARI0 = 0x77;
    const CROSS_ZERO_VARI1 = 0x78;
    const CROSS_ZERO_VARI2 = 0x79;
    const CROSS_ZERO_VARI3 = 0x7A;
    const CROSS_ZERO_VARE0 = 0x7B;
    const CROSS_ZERO_VARE1 = 0x7C;
    const CROSS_ZERO_VARE2 = 0x7D;
    const CROSS_ZERO_VARE3 = 0x7E;
    const CALIBRATION_FLAG_SET = 0x7F;
    const CALIBRATION_FLAG_RESET = 0x80;
    const BAD_TEST_EEPROM = 0x81;
    const BAD_TEST_FRAM = 0x82;
    const SET_NEW_SALDO = 0x83;
    const SALDO_PARAM_BAD = 0x84;
    const ACCUMULATION_PARAM_BAD = 0x85;
    const ACCUMULATION_PARAM_EXT_BAD = 0x86;
    const CALCULATION_PERIOD_BAD = 0x87;
    const BLOCK_TARIFF_BAD = 0x88;
    const CALIBRATION_PARAM_BAD = 0x89;
    const WINTER_SUMMER_BAD = 0x8A;
    const OP_PARAM_BAD = 0x8B;
    const OP_PARAM_EXT_BAD = 0x8C;
    const SALDO_ENERGY_BAD = 0x8D;
    const TIME_CORRECT = 0x8E;
    const COEFFICIENT_TRANSFORMATION_CHANGE = 0x8F;
    const RELAY_HARD_BAD_OFF = 0x90;
    const RELAY_HARD_ON = 0x91;
    const RELAY_HARD_BAD_ON = 0x93;
    const RELAY_HARD_OFF = 0x94;
    const METER_TROUBLE = 0x95;
    const CASE_KLEMA_OPEN = 0x96;
    const CASE_KLEMA_CLOSE = 0x97;
    const CHANGE_TARIFF_TABLE_2 = 0x98;
    const CHANGE_TARIFF_TABLE_3 = 0x99;
    const CASE_MODULE_OPEN = 0x9A;
    const CASE_MODULE_CLOSE = 0x9B;
    const SET_SALDO_PARAM = 0x9C;
    const POWER_OVER_RELAY_OFF = 0x9D;
    const CHANGE_PARAM_CHANNEL1 = 0x9E;
    const CHANGE_PARAM_CHANNEL2 = 0x9F;
    const CHANGE_PARAM_CHANNEL3 = 0xA0;
    const CHANGE_PARAM_CHANNEL4 = 0xA1;
    const CHANGE_PARAM_CHANNEL5 = 0xA2;
    const CHANGE_PARAM_CHANNEL6 = 0xA3;
    const CROSS_ZERO_EXPORT_ENT0 = 0xA4;
    const CROSS_ZERO_EXPORT_ENT1 = 0xA5;
    const CROSS_ZERO_EXPORT_ENT2 = 0xA6;
    const CROSS_ZERO_EXPORT_ENT3 = 0xA7;
    const CROSS_ZERO_EXPORT_VARI0 = 0xA8;
    const CROSS_ZERO_EXPORT_VARI1 = 0xA9;
    const CROSS_ZERO_EXPORT_VARI2 = 0xAA;
    const CROSS_ZERO_EXPORT_VARI3 = 0xAB;
    const CROSS_ZERO_EXPORT_VARE0 = 0xAC;
    const CROSS_ZERO_EXPORT_VARE1 = 0xAD;
    const CROSS_ZERO_EXPORT_VARE2 = 0xAE;
    const CROSS_ZERO_EXPORT_VARE3 = 0xAF;
    const EM_MAGNETIC_ON = 0xB0;
    const EM_MAGNETIC_OFF = 0xB1;
    const RESET_EM_FLAG = 0xB2;
    const RESET_MAGNETIC_FLAG = 0xB3;
    const SET_DEMAND_EN_1_MIN = 0xE0;
    const SET_DEMAND_EN_3_MIN = 0xE1;
    const SET_DEMAND_EN_5_MIN = 0xE2;
    const SET_DEMAND_EN_10_MIN = 0xE3;
    const SET_DEMAND_EN_15_MIN = 0xE4;
    const SET_DEMAND_EN_30_MIN = 0xE5;
    const SET_DEMAND_EN_60_MIN = 0xE6;
    const P_MAX_A_MINUS_OK = 0xE7;
    const P_MAX_A_MINUS_OVER = 0xE8;

    var events = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACCESS_LOCKED: ACCESS_LOCKED,
        ACCESS_UNLOCKED: ACCESS_UNLOCKED,
        ACCUMULATION_PARAM_BAD: ACCUMULATION_PARAM_BAD,
        ACCUMULATION_PARAM_EXT_BAD: ACCUMULATION_PARAM_EXT_BAD,
        BAD_TEST_EEPROM: BAD_TEST_EEPROM,
        BAD_TEST_FRAM: BAD_TEST_FRAM,
        BATTERY_FAULT: BATTERY_FAULT,
        BATTERY_OK: BATTERY_OK,
        BLOCK_TARIFF_BAD: BLOCK_TARIFF_BAD,
        CALCULATION_PERIOD_BAD: CALCULATION_PERIOD_BAD,
        CALIBRATION_FAULT: CALIBRATION_FAULT,
        CALIBRATION_FLAG_RESET: CALIBRATION_FLAG_RESET,
        CALIBRATION_FLAG_SET: CALIBRATION_FLAG_SET,
        CALIBRATION_OK: CALIBRATION_OK,
        CALIBRATION_PARAM_BAD: CALIBRATION_PARAM_BAD,
        CASE_CLOSE: CASE_CLOSE,
        CASE_KLEMA_CLOSE: CASE_KLEMA_CLOSE,
        CASE_KLEMA_OPEN: CASE_KLEMA_OPEN,
        CASE_MODULE_CLOSE: CASE_MODULE_CLOSE,
        CASE_MODULE_OPEN: CASE_MODULE_OPEN,
        CASE_OPEN: CASE_OPEN,
        CHANGE_ACCESS_KEY0: CHANGE_ACCESS_KEY0,
        CHANGE_ACCESS_KEY1: CHANGE_ACCESS_KEY1,
        CHANGE_ACCESS_KEY2: CHANGE_ACCESS_KEY2,
        CHANGE_ACCESS_KEY3: CHANGE_ACCESS_KEY3,
        CHANGE_COR_TIME: CHANGE_COR_TIME,
        CHANGE_PARAMETERS_LOCAL: CHANGE_PARAMETERS_LOCAL,
        CHANGE_PARAMETERS_REMOTE: CHANGE_PARAMETERS_REMOTE,
        CHANGE_PARAM_CHANNEL1: CHANGE_PARAM_CHANNEL1,
        CHANGE_PARAM_CHANNEL2: CHANGE_PARAM_CHANNEL2,
        CHANGE_PARAM_CHANNEL3: CHANGE_PARAM_CHANNEL3,
        CHANGE_PARAM_CHANNEL4: CHANGE_PARAM_CHANNEL4,
        CHANGE_PARAM_CHANNEL5: CHANGE_PARAM_CHANNEL5,
        CHANGE_PARAM_CHANNEL6: CHANGE_PARAM_CHANNEL6,
        CHANGE_TARIFF_TABLE: CHANGE_TARIFF_TABLE,
        CHANGE_TARIFF_TABLE_2: CHANGE_TARIFF_TABLE_2,
        CHANGE_TARIFF_TABLE_3: CHANGE_TARIFF_TABLE_3,
        CLOCK_FAULT: CLOCK_FAULT,
        CLOCK_OK: CLOCK_OK,
        CMD_CHANGE_TIME: CMD_CHANGE_TIME,
        CMD_RELAY_2_OFF: CMD_RELAY_2_OFF,
        CMD_RELAY_2_ON: CMD_RELAY_2_ON,
        CMD_RELAY_OFF: CMD_RELAY_OFF,
        CMD_RELAY_ON: CMD_RELAY_ON,
        COEFFICIENT_TRANSFORMATION_CHANGE: COEFFICIENT_TRANSFORMATION_CHANGE,
        CROSS_ZERO_ENT0: CROSS_ZERO_ENT0,
        CROSS_ZERO_ENT1: CROSS_ZERO_ENT1,
        CROSS_ZERO_ENT2: CROSS_ZERO_ENT2,
        CROSS_ZERO_ENT3: CROSS_ZERO_ENT3,
        CROSS_ZERO_EXPORT_ENT0: CROSS_ZERO_EXPORT_ENT0,
        CROSS_ZERO_EXPORT_ENT1: CROSS_ZERO_EXPORT_ENT1,
        CROSS_ZERO_EXPORT_ENT2: CROSS_ZERO_EXPORT_ENT2,
        CROSS_ZERO_EXPORT_ENT3: CROSS_ZERO_EXPORT_ENT3,
        CROSS_ZERO_EXPORT_VARE0: CROSS_ZERO_EXPORT_VARE0,
        CROSS_ZERO_EXPORT_VARE1: CROSS_ZERO_EXPORT_VARE1,
        CROSS_ZERO_EXPORT_VARE2: CROSS_ZERO_EXPORT_VARE2,
        CROSS_ZERO_EXPORT_VARE3: CROSS_ZERO_EXPORT_VARE3,
        CROSS_ZERO_EXPORT_VARI0: CROSS_ZERO_EXPORT_VARI0,
        CROSS_ZERO_EXPORT_VARI1: CROSS_ZERO_EXPORT_VARI1,
        CROSS_ZERO_EXPORT_VARI2: CROSS_ZERO_EXPORT_VARI2,
        CROSS_ZERO_EXPORT_VARI3: CROSS_ZERO_EXPORT_VARI3,
        CROSS_ZERO_VARE0: CROSS_ZERO_VARE0,
        CROSS_ZERO_VARE1: CROSS_ZERO_VARE1,
        CROSS_ZERO_VARE2: CROSS_ZERO_VARE2,
        CROSS_ZERO_VARE3: CROSS_ZERO_VARE3,
        CROSS_ZERO_VARI0: CROSS_ZERO_VARI0,
        CROSS_ZERO_VARI1: CROSS_ZERO_VARI1,
        CROSS_ZERO_VARI2: CROSS_ZERO_VARI2,
        CROSS_ZERO_VARI3: CROSS_ZERO_VARI3,
        EM_MAGNETIC_OFF: EM_MAGNETIC_OFF,
        EM_MAGNETIC_ON: EM_MAGNETIC_ON,
        ENERGY_REGISTER_OVERFLOW: ENERGY_REGISTER_OVERFLOW,
        ENERGY_T0_FAULT: ENERGY_T0_FAULT,
        ENERGY_T1_FAULT: ENERGY_T1_FAULT,
        ENERGY_T2_FAULT: ENERGY_T2_FAULT,
        ENERGY_T3_FAULT: ENERGY_T3_FAULT,
        ERR_ACCESS: ERR_ACCESS,
        F_MAX_OK: F_MAX_OK,
        F_MAX_OVER: F_MAX_OVER,
        F_MIN_OK: F_MIN_OK,
        F_MIN_UNDER: F_MIN_UNDER,
        IA_MAX_OK: IA_MAX_OK,
        IA_MAX_OVER: IA_MAX_OVER,
        IB_MAX_OK: IB_MAX_OK,
        IB_MAX_OVER: IB_MAX_OVER,
        IC_MAX_OK: IC_MAX_OK,
        IC_MAX_OVER: IC_MAX_OVER,
        IDIFF_OK: IDIFF_OK,
        IDIFF_OVER: IDIFF_OVER,
        MAGNETIC_OFF: MAGNETIC_OFF,
        MAGNETIC_ON: MAGNETIC_ON,
        METER_TROUBLE: METER_TROUBLE,
        OP_PARAM_BAD: OP_PARAM_BAD,
        OP_PARAM_EXT_BAD: OP_PARAM_EXT_BAD,
        O_PARAMETERS_FAULT: O_PARAMETERS_FAULT,
        O_PARAMETERS_OK: O_PARAMETERS_OK,
        PA_MAX_OK: PA_MAX_OK,
        PA_MAX_OVER: PA_MAX_OVER,
        POWER_A_OFF: POWER_A_OFF,
        POWER_A_ON: POWER_A_ON,
        POWER_B_OFF: POWER_B_OFF,
        POWER_B_ON: POWER_B_ON,
        POWER_C_OFF: POWER_C_OFF,
        POWER_C_ON: POWER_C_ON,
        POWER_OVER_RELAY_OFF: POWER_OVER_RELAY_OFF,
        PV_MAX_OK: PV_MAX_OK,
        PV_MAX_OVER: PV_MAX_OVER,
        P_MAX_A_MINUS_OK: P_MAX_A_MINUS_OK,
        P_MAX_A_MINUS_OVER: P_MAX_A_MINUS_OVER,
        RELAY_HARD_BAD_OFF: RELAY_HARD_BAD_OFF,
        RELAY_HARD_BAD_ON: RELAY_HARD_BAD_ON,
        RELAY_HARD_OFF: RELAY_HARD_OFF,
        RELAY_HARD_ON: RELAY_HARD_ON,
        RELAY_OFF: RELAY_OFF,
        RELAY_ON: RELAY_ON,
        RESET_EM_FLAG: RESET_EM_FLAG,
        RESET_MAGNETIC_FLAG: RESET_MAGNETIC_FLAG,
        RESTART: RESTART,
        SALDO_ENERGY_BAD: SALDO_ENERGY_BAD,
        SALDO_PARAM_BAD: SALDO_PARAM_BAD,
        SET_DEMAND_EN_10_MIN: SET_DEMAND_EN_10_MIN,
        SET_DEMAND_EN_15_MIN: SET_DEMAND_EN_15_MIN,
        SET_DEMAND_EN_1_MIN: SET_DEMAND_EN_1_MIN,
        SET_DEMAND_EN_30_MIN: SET_DEMAND_EN_30_MIN,
        SET_DEMAND_EN_3_MIN: SET_DEMAND_EN_3_MIN,
        SET_DEMAND_EN_5_MIN: SET_DEMAND_EN_5_MIN,
        SET_DEMAND_EN_60_MIN: SET_DEMAND_EN_60_MIN,
        SET_NEW_SALDO: SET_NEW_SALDO,
        SET_SALDO_PARAM: SET_SALDO_PARAM,
        SET_TARIFF_TABLE: SET_TARIFF_TABLE,
        SUMMER_TIME: SUMMER_TIME,
        TIME_CORRECT: TIME_CORRECT,
        T_MAX_OK: T_MAX_OK,
        T_MAX_OVER: T_MAX_OVER,
        T_MIN_OK: T_MIN_OK,
        T_MIN_UNDER: T_MIN_UNDER,
        VA_MAX_OK: VA_MAX_OK,
        VA_MAX_OVER: VA_MAX_OVER,
        VA_MIN_OK: VA_MIN_OK,
        VA_MIN_UNDER: VA_MIN_UNDER,
        VB_MAX_OK: VB_MAX_OK,
        VB_MAX_OVER: VB_MAX_OVER,
        VB_MIN_OK: VB_MIN_OK,
        VB_MIN_UNDER: VB_MIN_UNDER,
        VC_MAX_OK: VC_MAX_OK,
        VC_MAX_OVER: VC_MAX_OVER,
        VC_MIN_OK: VC_MIN_OK,
        VC_MIN_UNDER: VC_MIN_UNDER,
        V_PARAMETERS_FAULT: V_PARAMETERS_FAULT,
        V_PARAMETERS_OK: V_PARAMETERS_OK,
        WD_RESTART: WD_RESTART,
        WINTER_SUMMER_BAD: WINTER_SUMMER_BAD,
        WINTER_TIME: WINTER_TIME
    });

    var eventNames = invertObject(events);

    const SET_ALL_SEGMENT_DISPLAY = 1;
    const SOFTWARE_VERSION = 2;
    const TOTAL_ACTIVE_ENERGY = 3;
    const ACTIVE_ENERGY_T1 = 4;
    const ACTIVE_ENERGY_T2 = 5;
    const ACTIVE_ENERGY_T3 = 6;
    const ACTIVE_ENERGY_T4 = 7;
    const TOTAL_REACTIVE_ENERGY = 8;
    const REACTIVE_ENERGY_T1 = 9;
    const REACTIVE_ENERGY_T2 = 10;
    const REACTIVE_ENERGY_T3 = 11;
    const REACTIVE_ENERGY_T4 = 12;
    const TOTAL_NEGATIVE_REACTIVE_ENERGY = 13;
    const NEGATIVE_REACTIVE_ENERGY_T1 = 14;
    const NEGATIVE_REACTIVE_ENERGY_T2 = 15;
    const NEGATIVE_REACTIVE_ENERGY_T3 = 16;
    const NEGATIVE_REACTIVE_ENERGY_T4 = 17;
    const TOTAL_EXPORTED_ACTIVE_ENERGY = 18;
    const EXPORTED_ACTIVE_ENERGY_T1 = 19;
    const EXPORTED_ACTIVE_ENERGY_T2 = 20;
    const EXPORTED_ACTIVE_ENERGY_T3 = 21;
    const EXPORTED_ACTIVE_ENERGY_T4 = 22;
    const TOTAL_EXPORTED_REACTIVE_ENERGY = 23;
    const EXPORTED_REACTIVE_ENERGY_T1 = 24;
    const EXPORTED_REACTIVE_ENERGY_T2 = 25;
    const EXPORTED_REACTIVE_ENERGY_T3 = 26;
    const EXPORTED_REACTIVE_ENERGY_T4 = 27;
    const TOTAL_EXPORTED_NEGATIVE_REACTIVE_ENERGY = 28;
    const EXPORTED_NEGATIVE_REACTIVE_ENERGY_T1 = 29;
    const EXPORTED_NEGATIVE_REACTIVE_ENERGY_T2 = 30;
    const EXPORTED_NEGATIVE_REACTIVE_ENERGY_T3 = 31;
    const EXPORTED_NEGATIVE_REACTIVE_ENERGY_T4 = 32;
    const CURRENT_IN_PHASE_A = 33;
    const CURRENT_IN_PHASE_B = 34;
    const CURRENT_IN_PHASE_C = 35;
    const CURRENT_IN_NEUTRAL = 36;
    const VOLTAGE_IN_PHASE_A = 37;
    const VOLTAGE_IN_PHASE_B = 38;
    const VOLTAGE_IN_PHASE_C = 39;
    const BATTERY_VOLTAGE = 40;
    const FREQUENCY = 41;
    const ACTIVE_POWER_SUM = 42;
    const ACTIVE_POWER_PHASE_A = 43;
    const ACTIVE_POWER_PHASE_B = 44;
    const ACTIVE_POWER_PHASE_C = 45;
    const REACTIVE_POWER_QPLUS_SUM = 46;
    const REACTIVE_POWER_QPLUS_PHASE_A = 47;
    const REACTIVE_POWER_QPLUS_PHASE_B = 48;
    const REACTIVE_POWER_QPLUS_PHASE_C = 49;
    const REACTIVE_POWER_QMINUS_SUM = 50;
    const REACTIVE_POWER_QMINUS_PHASE_A = 51;
    const REACTIVE_POWER_QMINUS_PHASE_B = 52;
    const REACTIVE_POWER_QMINUS_PHASE_C = 53;
    const POWER_COEFFICIENT_SUM = 54;
    const POWER_COEFFICIENT_PHASE_A = 55;
    const POWER_COEFFICIENT_PHASE_B = 56;
    const POWER_COEFFICIENT_PHASE_C = 57;
    const APPARENT_POWER_QPLUS_SUM = 58;
    const APPARENT_POWER_QPLUS_PHASE_A = 59;
    const APPARENT_POWER_QPLUS_PHASE_B = 60;
    const APPARENT_POWER_QPLUS_PHASE_C = 61;
    const APPARENT_POWER_QMINUS_SUM = 62;
    const APPARENT_POWER_QMINUS_PHASE_A = 63;
    const APPARENT_POWER_QMINUS_PHASE_B = 64;
    const APPARENT_POWER_QMINUS_PHASE_C = 65;
    const MAX_ACTIVE_POWER_DAY_T1 = 66;
    const MAX_ACTIVE_POWER_DAY_T2 = 67;
    const MAX_ACTIVE_POWER_DAY_T3 = 68;
    const MAX_ACTIVE_POWER_DAY_T4 = 69;
    const MAX_ACTIVE_POWER_MONTH_T1 = 70;
    const MAX_ACTIVE_POWER_MONTH_T2 = 71;
    const MAX_ACTIVE_POWER_MONTH_T3 = 72;
    const MAX_ACTIVE_POWER_MONTH_T4 = 73;
    const MAX_REACTIVE_POWER_DAY_T1 = 74;
    const MAX_REACTIVE_POWER_DAY_T2 = 75;
    const MAX_REACTIVE_POWER_DAY_T3 = 76;
    const MAX_REACTIVE_POWER_DAY_T4 = 77;
    const MAX_REACTIVE_POWER_MONTH_T1 = 78;
    const MAX_REACTIVE_POWER_MONTH_T2 = 79;
    const MAX_REACTIVE_POWER_MONTH_T3 = 80;
    const MAX_REACTIVE_POWER_MONTH_T4 = 81;
    const MAX_NEGATIVE_REACTIVE_POWER_DAY_T1 = 82;
    const MAX_NEGATIVE_REACTIVE_POWER_DAY_T2 = 83;
    const MAX_NEGATIVE_REACTIVE_POWER_DAY_T3 = 84;
    const MAX_NEGATIVE_REACTIVE_POWER_DAY_T4 = 85;
    const MAX_NEGATIVE_REACTIVE_POWER_MONTH_T1 = 86;
    const MAX_NEGATIVE_REACTIVE_POWER_MONTH_T2 = 87;
    const MAX_NEGATIVE_REACTIVE_POWER_MONTH_T3 = 88;
    const MAX_NEGATIVE_REACTIVE_POWER_MONTH_T4 = 89;
    const MAX_EXPORTED_ACTIVE_POWER_DAY_T1 = 90;
    const MAX_EXPORTED_ACTIVE_POWER_DAY_T2 = 91;
    const MAX_EXPORTED_ACTIVE_POWER_DAY_T3 = 92;
    const MAX_EXPORTED_ACTIVE_POWER_DAY_T4 = 93;
    const MAX_EXPORTED_ACTIVE_POWER_MONTH_T1 = 94;
    const MAX_EXPORTED_ACTIVE_POWER_MONTH_T2 = 95;
    const MAX_EXPORTED_ACTIVE_POWER_MONTH_T3 = 96;
    const MAX_EXPORTED_ACTIVE_POWER_MONTH_T4 = 97;
    const MAX_EXPORTED_REACTIVE_POWER_DAY_T1 = 98;
    const MAX_EXPORTED_REACTIVE_POWER_DAY_T2 = 99;
    const MAX_EXPORTED_REACTIVE_POWER_DAY_T3 = 100;
    const MAX_EXPORTED_REACTIVE_POWER_DAY_T4 = 101;
    const MAX_EXPORTED_REACTIVE_POWER_MONTH_T1 = 102;
    const MAX_EXPORTED_REACTIVE_POWER_MONTH_T2 = 103;
    const MAX_EXPORTED_REACTIVE_POWER_MONTH_T3 = 104;
    const MAX_EXPORTED_REACTIVE_POWER_MONTH_T4 = 105;
    const MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T1 = 106;
    const MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T2 = 107;
    const MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T3 = 108;
    const MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T4 = 109;
    const MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T1 = 110;
    const MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T2 = 111;
    const MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T3 = 112;
    const MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T4 = 113;
    const HOUR_MINUTE_SECOND = 114;
    const DATE_MONTH_YEAR = 115;
    const CURRENT_TRANSFORMATION_RATIO = 116;
    const VOLTAGE_TRANSFORMATION_RATIO = 117;
    const CURRENT_BALANCE = 118;
    const POWER_THRESHOLD_T1 = 119;
    const POWER_THRESHOLD_T2 = 120;
    const POWER_THRESHOLD_T3 = 121;
    const POWER_THRESHOLD_T4 = 122;
    const OPTOPORT_SPEED = 123;
    const MAGNET_INDUCTION = 124;

    var screenIds = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTIVE_ENERGY_T1: ACTIVE_ENERGY_T1,
        ACTIVE_ENERGY_T2: ACTIVE_ENERGY_T2,
        ACTIVE_ENERGY_T3: ACTIVE_ENERGY_T3,
        ACTIVE_ENERGY_T4: ACTIVE_ENERGY_T4,
        ACTIVE_POWER_PHASE_A: ACTIVE_POWER_PHASE_A,
        ACTIVE_POWER_PHASE_B: ACTIVE_POWER_PHASE_B,
        ACTIVE_POWER_PHASE_C: ACTIVE_POWER_PHASE_C,
        ACTIVE_POWER_SUM: ACTIVE_POWER_SUM,
        APPARENT_POWER_QMINUS_PHASE_A: APPARENT_POWER_QMINUS_PHASE_A,
        APPARENT_POWER_QMINUS_PHASE_B: APPARENT_POWER_QMINUS_PHASE_B,
        APPARENT_POWER_QMINUS_PHASE_C: APPARENT_POWER_QMINUS_PHASE_C,
        APPARENT_POWER_QMINUS_SUM: APPARENT_POWER_QMINUS_SUM,
        APPARENT_POWER_QPLUS_PHASE_A: APPARENT_POWER_QPLUS_PHASE_A,
        APPARENT_POWER_QPLUS_PHASE_B: APPARENT_POWER_QPLUS_PHASE_B,
        APPARENT_POWER_QPLUS_PHASE_C: APPARENT_POWER_QPLUS_PHASE_C,
        APPARENT_POWER_QPLUS_SUM: APPARENT_POWER_QPLUS_SUM,
        BATTERY_VOLTAGE: BATTERY_VOLTAGE,
        CURRENT_BALANCE: CURRENT_BALANCE,
        CURRENT_IN_NEUTRAL: CURRENT_IN_NEUTRAL,
        CURRENT_IN_PHASE_A: CURRENT_IN_PHASE_A,
        CURRENT_IN_PHASE_B: CURRENT_IN_PHASE_B,
        CURRENT_IN_PHASE_C: CURRENT_IN_PHASE_C,
        CURRENT_TRANSFORMATION_RATIO: CURRENT_TRANSFORMATION_RATIO,
        DATE_MONTH_YEAR: DATE_MONTH_YEAR,
        EXPORTED_ACTIVE_ENERGY_T1: EXPORTED_ACTIVE_ENERGY_T1,
        EXPORTED_ACTIVE_ENERGY_T2: EXPORTED_ACTIVE_ENERGY_T2,
        EXPORTED_ACTIVE_ENERGY_T3: EXPORTED_ACTIVE_ENERGY_T3,
        EXPORTED_ACTIVE_ENERGY_T4: EXPORTED_ACTIVE_ENERGY_T4,
        EXPORTED_NEGATIVE_REACTIVE_ENERGY_T1: EXPORTED_NEGATIVE_REACTIVE_ENERGY_T1,
        EXPORTED_NEGATIVE_REACTIVE_ENERGY_T2: EXPORTED_NEGATIVE_REACTIVE_ENERGY_T2,
        EXPORTED_NEGATIVE_REACTIVE_ENERGY_T3: EXPORTED_NEGATIVE_REACTIVE_ENERGY_T3,
        EXPORTED_NEGATIVE_REACTIVE_ENERGY_T4: EXPORTED_NEGATIVE_REACTIVE_ENERGY_T4,
        EXPORTED_REACTIVE_ENERGY_T1: EXPORTED_REACTIVE_ENERGY_T1,
        EXPORTED_REACTIVE_ENERGY_T2: EXPORTED_REACTIVE_ENERGY_T2,
        EXPORTED_REACTIVE_ENERGY_T3: EXPORTED_REACTIVE_ENERGY_T3,
        EXPORTED_REACTIVE_ENERGY_T4: EXPORTED_REACTIVE_ENERGY_T4,
        FREQUENCY: FREQUENCY,
        HOUR_MINUTE_SECOND: HOUR_MINUTE_SECOND,
        MAGNET_INDUCTION: MAGNET_INDUCTION,
        MAX_ACTIVE_POWER_DAY_T1: MAX_ACTIVE_POWER_DAY_T1,
        MAX_ACTIVE_POWER_DAY_T2: MAX_ACTIVE_POWER_DAY_T2,
        MAX_ACTIVE_POWER_DAY_T3: MAX_ACTIVE_POWER_DAY_T3,
        MAX_ACTIVE_POWER_DAY_T4: MAX_ACTIVE_POWER_DAY_T4,
        MAX_ACTIVE_POWER_MONTH_T1: MAX_ACTIVE_POWER_MONTH_T1,
        MAX_ACTIVE_POWER_MONTH_T2: MAX_ACTIVE_POWER_MONTH_T2,
        MAX_ACTIVE_POWER_MONTH_T3: MAX_ACTIVE_POWER_MONTH_T3,
        MAX_ACTIVE_POWER_MONTH_T4: MAX_ACTIVE_POWER_MONTH_T4,
        MAX_EXPORTED_ACTIVE_POWER_DAY_T1: MAX_EXPORTED_ACTIVE_POWER_DAY_T1,
        MAX_EXPORTED_ACTIVE_POWER_DAY_T2: MAX_EXPORTED_ACTIVE_POWER_DAY_T2,
        MAX_EXPORTED_ACTIVE_POWER_DAY_T3: MAX_EXPORTED_ACTIVE_POWER_DAY_T3,
        MAX_EXPORTED_ACTIVE_POWER_DAY_T4: MAX_EXPORTED_ACTIVE_POWER_DAY_T4,
        MAX_EXPORTED_ACTIVE_POWER_MONTH_T1: MAX_EXPORTED_ACTIVE_POWER_MONTH_T1,
        MAX_EXPORTED_ACTIVE_POWER_MONTH_T2: MAX_EXPORTED_ACTIVE_POWER_MONTH_T2,
        MAX_EXPORTED_ACTIVE_POWER_MONTH_T3: MAX_EXPORTED_ACTIVE_POWER_MONTH_T3,
        MAX_EXPORTED_ACTIVE_POWER_MONTH_T4: MAX_EXPORTED_ACTIVE_POWER_MONTH_T4,
        MAX_EXPORTED_REACTIVE_POWER_DAY_T1: MAX_EXPORTED_REACTIVE_POWER_DAY_T1,
        MAX_EXPORTED_REACTIVE_POWER_DAY_T2: MAX_EXPORTED_REACTIVE_POWER_DAY_T2,
        MAX_EXPORTED_REACTIVE_POWER_DAY_T3: MAX_EXPORTED_REACTIVE_POWER_DAY_T3,
        MAX_EXPORTED_REACTIVE_POWER_DAY_T4: MAX_EXPORTED_REACTIVE_POWER_DAY_T4,
        MAX_EXPORTED_REACTIVE_POWER_MONTH_T1: MAX_EXPORTED_REACTIVE_POWER_MONTH_T1,
        MAX_EXPORTED_REACTIVE_POWER_MONTH_T2: MAX_EXPORTED_REACTIVE_POWER_MONTH_T2,
        MAX_EXPORTED_REACTIVE_POWER_MONTH_T3: MAX_EXPORTED_REACTIVE_POWER_MONTH_T3,
        MAX_EXPORTED_REACTIVE_POWER_MONTH_T4: MAX_EXPORTED_REACTIVE_POWER_MONTH_T4,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T1: MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T1,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T2: MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T2,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T3: MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T3,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T4: MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T4,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T1: MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T1,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T2: MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T2,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T3: MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T3,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T4: MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T4,
        MAX_NEGATIVE_REACTIVE_POWER_DAY_T1: MAX_NEGATIVE_REACTIVE_POWER_DAY_T1,
        MAX_NEGATIVE_REACTIVE_POWER_DAY_T2: MAX_NEGATIVE_REACTIVE_POWER_DAY_T2,
        MAX_NEGATIVE_REACTIVE_POWER_DAY_T3: MAX_NEGATIVE_REACTIVE_POWER_DAY_T3,
        MAX_NEGATIVE_REACTIVE_POWER_DAY_T4: MAX_NEGATIVE_REACTIVE_POWER_DAY_T4,
        MAX_NEGATIVE_REACTIVE_POWER_MONTH_T1: MAX_NEGATIVE_REACTIVE_POWER_MONTH_T1,
        MAX_NEGATIVE_REACTIVE_POWER_MONTH_T2: MAX_NEGATIVE_REACTIVE_POWER_MONTH_T2,
        MAX_NEGATIVE_REACTIVE_POWER_MONTH_T3: MAX_NEGATIVE_REACTIVE_POWER_MONTH_T3,
        MAX_NEGATIVE_REACTIVE_POWER_MONTH_T4: MAX_NEGATIVE_REACTIVE_POWER_MONTH_T4,
        MAX_REACTIVE_POWER_DAY_T1: MAX_REACTIVE_POWER_DAY_T1,
        MAX_REACTIVE_POWER_DAY_T2: MAX_REACTIVE_POWER_DAY_T2,
        MAX_REACTIVE_POWER_DAY_T3: MAX_REACTIVE_POWER_DAY_T3,
        MAX_REACTIVE_POWER_DAY_T4: MAX_REACTIVE_POWER_DAY_T4,
        MAX_REACTIVE_POWER_MONTH_T1: MAX_REACTIVE_POWER_MONTH_T1,
        MAX_REACTIVE_POWER_MONTH_T2: MAX_REACTIVE_POWER_MONTH_T2,
        MAX_REACTIVE_POWER_MONTH_T3: MAX_REACTIVE_POWER_MONTH_T3,
        MAX_REACTIVE_POWER_MONTH_T4: MAX_REACTIVE_POWER_MONTH_T4,
        NEGATIVE_REACTIVE_ENERGY_T1: NEGATIVE_REACTIVE_ENERGY_T1,
        NEGATIVE_REACTIVE_ENERGY_T2: NEGATIVE_REACTIVE_ENERGY_T2,
        NEGATIVE_REACTIVE_ENERGY_T3: NEGATIVE_REACTIVE_ENERGY_T3,
        NEGATIVE_REACTIVE_ENERGY_T4: NEGATIVE_REACTIVE_ENERGY_T4,
        OPTOPORT_SPEED: OPTOPORT_SPEED,
        POWER_COEFFICIENT_PHASE_A: POWER_COEFFICIENT_PHASE_A,
        POWER_COEFFICIENT_PHASE_B: POWER_COEFFICIENT_PHASE_B,
        POWER_COEFFICIENT_PHASE_C: POWER_COEFFICIENT_PHASE_C,
        POWER_COEFFICIENT_SUM: POWER_COEFFICIENT_SUM,
        POWER_THRESHOLD_T1: POWER_THRESHOLD_T1,
        POWER_THRESHOLD_T2: POWER_THRESHOLD_T2,
        POWER_THRESHOLD_T3: POWER_THRESHOLD_T3,
        POWER_THRESHOLD_T4: POWER_THRESHOLD_T4,
        REACTIVE_ENERGY_T1: REACTIVE_ENERGY_T1,
        REACTIVE_ENERGY_T2: REACTIVE_ENERGY_T2,
        REACTIVE_ENERGY_T3: REACTIVE_ENERGY_T3,
        REACTIVE_ENERGY_T4: REACTIVE_ENERGY_T4,
        REACTIVE_POWER_QMINUS_PHASE_A: REACTIVE_POWER_QMINUS_PHASE_A,
        REACTIVE_POWER_QMINUS_PHASE_B: REACTIVE_POWER_QMINUS_PHASE_B,
        REACTIVE_POWER_QMINUS_PHASE_C: REACTIVE_POWER_QMINUS_PHASE_C,
        REACTIVE_POWER_QMINUS_SUM: REACTIVE_POWER_QMINUS_SUM,
        REACTIVE_POWER_QPLUS_PHASE_A: REACTIVE_POWER_QPLUS_PHASE_A,
        REACTIVE_POWER_QPLUS_PHASE_B: REACTIVE_POWER_QPLUS_PHASE_B,
        REACTIVE_POWER_QPLUS_PHASE_C: REACTIVE_POWER_QPLUS_PHASE_C,
        REACTIVE_POWER_QPLUS_SUM: REACTIVE_POWER_QPLUS_SUM,
        SET_ALL_SEGMENT_DISPLAY: SET_ALL_SEGMENT_DISPLAY,
        SOFTWARE_VERSION: SOFTWARE_VERSION,
        TOTAL_ACTIVE_ENERGY: TOTAL_ACTIVE_ENERGY,
        TOTAL_EXPORTED_ACTIVE_ENERGY: TOTAL_EXPORTED_ACTIVE_ENERGY,
        TOTAL_EXPORTED_NEGATIVE_REACTIVE_ENERGY: TOTAL_EXPORTED_NEGATIVE_REACTIVE_ENERGY,
        TOTAL_EXPORTED_REACTIVE_ENERGY: TOTAL_EXPORTED_REACTIVE_ENERGY,
        TOTAL_NEGATIVE_REACTIVE_ENERGY: TOTAL_NEGATIVE_REACTIVE_ENERGY,
        TOTAL_REACTIVE_ENERGY: TOTAL_REACTIVE_ENERGY,
        VOLTAGE_IN_PHASE_A: VOLTAGE_IN_PHASE_A,
        VOLTAGE_IN_PHASE_B: VOLTAGE_IN_PHASE_B,
        VOLTAGE_IN_PHASE_C: VOLTAGE_IN_PHASE_C,
        VOLTAGE_TRANSFORMATION_RATIO: VOLTAGE_TRANSFORMATION_RATIO
    });

    invertObject(screenIds);

    const errorResponse = 0xfe;

    var uplinkIds = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activateRatePlan: activateRatePlan,
        errorResponse: errorResponse,
        getBuildVersion: getBuildVersion,
        getCorrectTime: getCorrectTime,
        getCriticalEvent: getCriticalEvent,
        getCurrentStatusMeter: getCurrentStatusMeter,
        getCurrentValues: getCurrentValues,
        getDateTime: getDateTime,
        getDayDemand: getDayDemand,
        getDayDemandExport: getDayDemandExport,
        getDayMaxDemand: getDayMaxDemand,
        getDayMaxDemandExport: getDayMaxDemandExport,
        getDayProfile: getDayProfile,
        getDemand: getDemand,
        getDeviceId: getDeviceId,
        getDeviceType: getDeviceType,
        getDisplayParam: getDisplayParam,
        getEnergy: getEnergy,
        getEnergyDayPrevious: getEnergyDayPrevious,
        getEnergyExport: getEnergyExport,
        getEnergyExportDayPrevious: getEnergyExportDayPrevious,
        getEventStatus: getEventStatus,
        getEvents: getEvents,
        getEventsCounters: getEventsCounters,
        getExtendedCurrentValues: getExtendedCurrentValues,
        getHalfHourDemand: getHalfHourDemand,
        getHalfHourDemandChannel: getHalfHourDemandChannel,
        getHalfHourDemandExport: getHalfHourDemandExport,
        getHalfHourDemandVare: getHalfHourDemandVare,
        getHalfHourDemandVareExport: getHalfHourDemandVareExport,
        getHalfHourDemandVari: getHalfHourDemandVari,
        getHalfHourDemandVariExport: getHalfHourDemandVariExport,
        getHalfhoursEnergies: getHalfhoursEnergies,
        getMagneticFieldThreshold: getMagneticFieldThreshold,
        getMeterInfo: getMeterInfo,
        getMonthDemand: getMonthDemand,
        getMonthDemandExport: getMonthDemandExport,
        getMonthMaxDemand: getMonthMaxDemand,
        getMonthMaxDemandExport: getMonthMaxDemandExport,
        getOperatorParameters: getOperatorParameters,
        getOperatorParametersExtended: getOperatorParametersExtended,
        getOperatorParametersExtended2: getOperatorParametersExtended2,
        getOperatorParametersExtended3: getOperatorParametersExtended3,
        getRatePlanInfo: getRatePlanInfo,
        getSaldo: getSaldo,
        getSaldoParameters: getSaldoParameters,
        getSeasonProfile: getSeasonProfile,
        getSpecialDay: getSpecialDay,
        getVersion: getVersion,
        prepareRatePlan: prepareRatePlan,
        resetPowerMaxDay: resetPowerMaxDay,
        resetPowerMaxMonth: resetPowerMaxMonth,
        runTariffPlan: runTariffPlan,
        setAccessKey: setAccessKey,
        setCorrectDateTime: setCorrectDateTime,
        setCorrectTime: setCorrectTime,
        setDateTime: setDateTime,
        setDayProfile: setDayProfile,
        setDisplayParam: setDisplayParam,
        setOperatorParameters: setOperatorParameters,
        setOperatorParametersExtended: setOperatorParametersExtended,
        setOperatorParametersExtended2: setOperatorParametersExtended2,
        setOperatorParametersExtended3: setOperatorParametersExtended3,
        setOperatorParametersExtended4: setOperatorParametersExtended4,
        setSaldo: setSaldo,
        setSaldoParameters: setSaldoParameters,
        setSeasonProfile: setSeasonProfile,
        setSpecialDay: setSpecialDay,
        setSpecialOperation: setSpecialOperation,
        turnRelayOff: turnRelayOff,
        turnRelayOn: turnRelayOn
    });

    var uplinkNames = invertObject(uplinkIds);

    const RATE_2400 = 2400;
    const RATE_9600 = 9600;
    const valueToRate = {
        plc: {
            0: RATE_9600,
            2: RATE_2400,
            4: RATE_9600
        },
        optoport: {
            0: RATE_2400,
            2: RATE_2400,
            4: RATE_9600
        }
    };
    const rateToValue = {
        plc: invertObject(valueToRate.plc),
        optoport: invertObject(valueToRate.optoport)
    };

    const id$1s = getCriticalEvent;
    downlinkNames[getCriticalEvent];
    const maxSize$1a = 2;
    const fromBytes$1u = (bytes) => {
        if (bytes.length !== maxSize$1a) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const [event, index] = bytes;
        return { event, index };
    };
    const toBytes$1u = (parameters) => (toBytes$2g(id$1s, [parameters.event, parameters.index]));

    const OPERATOR_PARAMETERS_SIZE = 95;
    const OPERATOR_PARAMETERS_EXTENDED_SIZE = 9;
    const OPERATOR_PARAMETERS_EXTENDED2_SIZE = 28;
    const OPERATOR_PARAMETERS_EXTENDED4_SIZE = 28;
    const PACKED_ENERGY_TYPE_SIZE = 1;
    const ENERGY_TYPE_BITS = 4;
    const displaySet1Mask = {
        SET_ALL_SEGMENT_DISPLAY: 1 << 0,
        SOFTWARE_VERSION: 1 << 1,
        TOTAL_ACTIVE_ENERGY: 1 << 2,
        ACTIVE_ENERGY_T1: 1 << 3,
        ACTIVE_ENERGY_T2: 1 << 4,
        ACTIVE_ENERGY_T3: 1 << 5,
        ACTIVE_ENERGY_T4: 1 << 6,
        TOTAL_REACTIVE_ENERGY: 1 << 7,
        REACTIVE_ENERGY_T1: 1 << 8,
        REACTIVE_ENERGY_T2: 1 << 9,
        REACTIVE_ENERGY_T3: 1 << 10,
        REACTIVE_ENERGY_T4: 1 << 11,
        TOTAL_NEGATIVE_REACTIVE_ENERGY: 1 << 12,
        NEGATIVE_REACTIVE_ENERGY_T1: 1 << 13,
        NEGATIVE_REACTIVE_ENERGY_T2: 1 << 14,
        NEGATIVE_REACTIVE_ENERGY_T3: 1 << 15,
        NEGATIVE_REACTIVE_ENERGY_T4: 1 << 16,
        TOTAL_EXPORTED_ACTIVE_ENERGY: 1 << 17,
        EXPORTED_ACTIVE_ENERGY_T1: 1 << 18,
        EXPORTED_ACTIVE_ENERGY_T2: 1 << 19,
        EXPORTED_ACTIVE_ENERGY_T3: 1 << 20,
        EXPORTED_ACTIVE_ENERGY_T4: 1 << 21,
        TOTAL_EXPORTED_REACTIVE_ENERGY: 1 << 22,
        EXPORTED_REACTIVE_ENERGY_T1: 1 << 23,
        EXPORTED_REACTIVE_ENERGY_T2: 1 << 24,
        EXPORTED_REACTIVE_ENERGY_T3: 1 << 25,
        EXPORTED_REACTIVE_ENERGY_T4: 1 << 26,
        TOTAL_EXPORTED_NEGATIVE_REACTIVE_ENERGY: 1 << 27,
        EXPORTED_NEGATIVE_REACTIVE_ENERGY_T1: 1 << 28,
        EXPORTED_NEGATIVE_REACTIVE_ENERGY_T2: 1 << 29,
        EXPORTED_NEGATIVE_REACTIVE_ENERGY_T3: 1 << 30,
        EXPORTED_NEGATIVE_REACTIVE_ENERGY_T4: 1 << 31
    };
    const displaySet2Mask = {
        CURRENT_IN_PHASE_A: 1 << 0,
        CURRENT_IN_PHASE_B: 1 << 1,
        CURRENT_IN_PHASE_C: 1 << 2,
        CURRENT_IN_NEUTRAL: 1 << 3,
        VOLTAGE_IN_PHASE_A: 1 << 4,
        VOLTAGE_IN_PHASE_B: 1 << 5,
        VOLTAGE_IN_PHASE_C: 1 << 6,
        BATTERY_VOLTAGE: 1 << 7,
        FREQUENCY: 1 << 8,
        ACTIVE_POWER_SUM: 1 << 9,
        ACTIVE_POWER_PHASE_A: 1 << 10,
        ACTIVE_POWER_PHASE_B: 1 << 11,
        ACTIVE_POWER_PHASE_C: 1 << 12,
        REACTIVE_POWER_QPLUS_SUM: 1 << 13,
        REACTIVE_POWER_QPLUS_PHASE_A: 1 << 14,
        REACTIVE_POWER_QPLUS_PHASE_B: 1 << 15,
        REACTIVE_POWER_QPLUS_PHASE_C: 1 << 16,
        REACTIVE_POWER_QMINUS_SUM: 1 << 17,
        REACTIVE_POWER_QMINUS_PHASE_A: 1 << 18,
        REACTIVE_POWER_QMINUS_PHASE_B: 1 << 19,
        REACTIVE_POWER_QMINUS_PHASE_C: 1 << 20,
        POWER_COEFFICIENT_SUM: 1 << 21,
        POWER_COEFFICIENT_PHASE_A: 1 << 22,
        POWER_COEFFICIENT_PHASE_B: 1 << 23,
        POWER_COEFFICIENT_PHASE_C: 1 << 24,
        APPARENT_POWER_QPLUS_SUM: 1 << 25,
        APPARENT_POWER_QPLUS_PHASE_A: 1 << 26,
        APPARENT_POWER_QPLUS_PHASE_B: 1 << 27,
        APPARENT_POWER_QPLUS_PHASE_C: 1 << 28,
        APPARENT_POWER_QMINUS_SUM: 1 << 29,
        APPARENT_POWER_QMINUS_PHASE_A: 1 << 30,
        APPARENT_POWER_QMINUS_PHASE_B: 1 << 31
    };
    const displaySet3Mask = {
        APPARENT_POWER_QMINUS_PHASE_C: 1 << 0,
        MAX_ACTIVE_POWER_DAY_T1: 1 << 1,
        MAX_ACTIVE_POWER_DAY_T2: 1 << 2,
        MAX_ACTIVE_POWER_DAY_T3: 1 << 3,
        MAX_ACTIVE_POWER_DAY_T4: 1 << 4,
        MAX_ACTIVE_POWER_MONTH_T1: 1 << 5,
        MAX_ACTIVE_POWER_MONTH_T2: 1 << 6,
        MAX_ACTIVE_POWER_MONTH_T3: 1 << 7,
        MAX_ACTIVE_POWER_MONTH_T4: 1 << 8,
        MAX_REACTIVE_POWER_DAY_T1: 1 << 9,
        MAX_REACTIVE_POWER_DAY_T2: 1 << 10,
        MAX_REACTIVE_POWER_DAY_T3: 1 << 11,
        MAX_REACTIVE_POWER_DAY_T4: 1 << 12,
        MAX_REACTIVE_POWER_MONTH_T1: 1 << 13,
        MAX_REACTIVE_POWER_MONTH_T2: 1 << 14,
        MAX_REACTIVE_POWER_MONTH_T3: 1 << 15,
        MAX_REACTIVE_POWER_MONTH_T4: 1 << 16,
        MAX_NEGATIVE_REACTIVE_POWER_DAY_T1: 1 << 17,
        MAX_NEGATIVE_REACTIVE_POWER_DAY_T2: 1 << 18,
        MAX_NEGATIVE_REACTIVE_POWER_DAY_T3: 1 << 19,
        MAX_NEGATIVE_REACTIVE_POWER_DAY_T4: 1 << 20,
        MAX_NEGATIVE_REACTIVE_POWER_MONTH_T1: 1 << 21,
        MAX_NEGATIVE_REACTIVE_POWER_MONTH_T2: 1 << 22,
        MAX_NEGATIVE_REACTIVE_POWER_MONTH_T3: 1 << 23,
        MAX_NEGATIVE_REACTIVE_POWER_MONTH_T4: 1 << 24,
        MAX_EXPORTED_ACTIVE_POWER_DAY_T1: 1 << 25,
        MAX_EXPORTED_ACTIVE_POWER_DAY_T2: 1 << 26,
        MAX_EXPORTED_ACTIVE_POWER_DAY_T3: 1 << 27,
        MAX_EXPORTED_ACTIVE_POWER_DAY_T4: 1 << 28,
        MAX_EXPORTED_ACTIVE_POWER_MONTH_T1: 1 << 29,
        MAX_EXPORTED_ACTIVE_POWER_MONTH_T2: 1 << 30,
        MAX_EXPORTED_ACTIVE_POWER_MONTH_T3: 1 << 31
    };
    const displaySet4BaseMask = {
        MAX_EXPORTED_ACTIVE_POWER_MONTH_T4: 1 << 0,
        MAX_EXPORTED_REACTIVE_POWER_DAY_T1: 1 << 1,
        MAX_EXPORTED_REACTIVE_POWER_DAY_T2: 1 << 2,
        MAX_EXPORTED_REACTIVE_POWER_DAY_T3: 1 << 3,
        MAX_EXPORTED_REACTIVE_POWER_DAY_T4: 1 << 4,
        MAX_EXPORTED_REACTIVE_POWER_MONTH_T1: 1 << 5,
        MAX_EXPORTED_REACTIVE_POWER_MONTH_T2: 1 << 6,
        MAX_EXPORTED_REACTIVE_POWER_MONTH_T3: 1 << 7,
        MAX_EXPORTED_REACTIVE_POWER_MONTH_T4: 1 << 8,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T1: 1 << 9,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T2: 1 << 10,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T3: 1 << 11,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_DAY_T4: 1 << 12,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T1: 1 << 13,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T2: 1 << 14,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T3: 1 << 15,
        MAX_NEGATIVE_EXPORTED_REACTIVE_POWER_MONTH_T4: 1 << 16,
        HOUR_MINUTE_SECOND: 1 << 17,
        DATE_MONTH_YEAR: 1 << 18,
        CURRENT_TRANSFORMATION_RATIO: 1 << 19,
        VOLTAGE_TRANSFORMATION_RATIO: 1 << 20,
        CURRENT_BALANCE: 1 << 21,
        POWER_THRESHOLD_T1: 1 << 22,
        POWER_THRESHOLD_T2: 1 << 23,
        POWER_THRESHOLD_T3: 1 << 24,
        POWER_THRESHOLD_T4: 1 << 25
    };
    const displaySet4Mask = {
        ...displaySet4BaseMask,
        SORT_DISPLAY_SCREENS: 1 << 29,
        AUTO_SCREEN_SCROLLING: 1 << 31
    };
    const displaySet5Mask = {
        EVENT: 1 << 0,
        PROFILE_P01: 1 << 1,
        PROFILE_P02: 1 << 2,
        PROFILE_P03: 1 << 3,
        PROFILE_P04: 1 << 4,
        PROFILE_P05: 1 << 5,
        PROFILE_P06: 1 << 6
    };
    const relaySetMask = {
        RELAY_ON_Y: 1 << 0,
        RELAY_ON_CENTER: 1 << 1,
        RELAY_ON_PB: 1 << 2,
        RELAY_ON_TARIFF_0: 1 << 3,
        RELAY_ON_TARIFF_1: 1 << 4,
        RELAY_ON_TARIFF_2: 1 << 5,
        RELAY_ON_TARIFF_3: 1 << 6,
        RELAY_ON_V_GOOD: 1 << 7,
        RELAY_OFF_Y: 1 << 8,
        RELAY_OFF_CENTER: 1 << 9,
        RELAY_OFF_TARIFF_0: 1 << 10,
        RELAY_OFF_TARIFF_1: 1 << 11,
        RELAY_OFF_TARIFF_2: 1 << 12,
        RELAY_OFF_TARIFF_3: 1 << 13,
        RELAY_OFF_I_LIMIT: 1 << 14,
        RELAY_OFF_V_BAD: 1 << 15,
        RELAY_OFF_DIFF_BAD: 1 << 16,
        RELAY_OFF_LIM_TARIFF_0: 1 << 17,
        RELAY_OFF_LIM_TARIFF_1: 1 << 18,
        RELAY_OFF_LIM_TARIFF_2: 1 << 19,
        RELAY_OFF_LIM_TARIFF_3: 1 << 20,
        RELAY_OFF_LIM_VAR_TARIFF_0: 1 << 21,
        RELAY_OFF_LIM_VAR_TARIFF_1: 1 << 22,
        RELAY_OFF_LIM_VAR_TARIFF_2: 1 << 23,
        RELAY_OFF_LIM_VAR_TARIFF_3: 1 << 24,
        RELAY_ON_PF_MIN: 1 << 25,
        RELAY_OFF_PF_MIN: 1 << 26,
        RELAY_ON_TIMEOUT: 1 << 27,
        RELAY_ON_SALDO: 1 << 28,
        RELAY_OFF_SALDO: 1 << 29,
        RELAY_OFF_SALDO_SOFT: 1 << 30
    };
    const typeMeterMask = {
        TRANSFORMATION_RATIO: 1 << 0,
        METER_TYPE_R: 1 << 4,
        ACCUMULATE_BY_R_PLUS_MINUS: 1 << 7
    };
    const define1Mask = {
        RESET_DAY_MAX_POWER_KEY: 1 << 0,
        RESET_MONTH_MAX_POWER_KEY: 1 << 1,
        BLOCK_KEY_OPTOPORT: 1 << 2,
        MAGNET_SCREEN_CONST: 1 << 5,
        ALLOW_BROWNOUT_INDICATION: 1 << 7
    };
    const displaySet24Mask = {
        ...displaySet4BaseMask,
        OPTOPORT_SPEED: 1 << 26,
        MAGNET_INDUCTION: 1 << 27
    };
    const relaySetExtMask = {
        RELAY_OFF_MAGNET: 1 << 0,
        RELAY_ON_MAGNET_TIMEOUT: 1 << 1,
        RELAY_ON_MAGNET_AUTO: 1 << 2
    };
    const getSpeedOptoPort = (value) => ({
        plc: valueToRate.plc[extractBits(value, 4, 1)],
        optoport: valueToRate.optoport[extractBits(value, 4, 5)]
    });
    const setSpeedOptoPort = (speedOptoPort) => {
        let result = 0;
        result = fillBits(result, 4, 1, Number(rateToValue.plc[speedOptoPort.plc]));
        result = fillBits(result, 4, 5, Number(rateToValue.optoport[speedOptoPort.optoport]));
        return result;
    };
    function getPackedEnergies(buffer, energyType, tariffMapByte) {
        const byte = tariffMapByte >> ENERGY_TYPE_BITS;
        const wh = [];
        const vari = [];
        const vare = [];
        for (let index = 0; index < TARIFF_NUMBER$1; index++) {
            const isTariffExists = !!extractBits(byte, 1, index + 1);
            if (isTariffExists) {
                wh.push(buffer.getInt32());
                vari.push(buffer.getInt32());
                vare.push(buffer.getInt32());
            }
            else {
                wh.push(null);
                vari.push(null);
                vare.push(null);
            }
        }
        return { wh, vari, vare };
    }
    function getPackedEnergyType(energyType, energies) {
        const { wh, vari, vare } = energies;
        const indexShift = 1 + ENERGY_TYPE_BITS;
        let tariffsByte = energyType;
        for (let index = 0; index < TARIFF_NUMBER$1; index++) {
            tariffsByte = fillBits(tariffsByte, 1, index + indexShift, Number(!!wh[index] && !!vari[index] && !!vare[index]));
        }
        return tariffsByte;
    }
    function CommandBinaryBuffer(dataOrLength, isLittleEndian = false) {
        CommandBinaryBuffer$2.call(this, dataOrLength, isLittleEndian);
    }
    CommandBinaryBuffer.prototype = Object.create(CommandBinaryBuffer$2.prototype);
    CommandBinaryBuffer.prototype.constructor = CommandBinaryBuffer;
    CommandBinaryBuffer.getDefaultOperatorParameters = () => ({
        vpThreshold: 265000,
        vThreshold: 156000,
        ipThreshold: 120000,
        pmaxThreshold0: 31800,
        pmaxThreshold1: 31800,
        pmaxThreshold2: 31800,
        pmaxThreshold3: 31800,
        rmaxThreshold0: 31800,
        rmaxThreshold1: 31800,
        rmaxThreshold2: 31800,
        rmaxThreshold3: 31800,
        tint: 30,
        calcPeriodDate: 1,
        timeoutDisplay: 127,
        timeoutScreen: 7,
        displaySet1: toObject(displaySet1Mask, 4229),
        displaySet2: toObject(displaySet2Mask, 139776),
        displaySet3: toObject(displaySet3Mask, 0),
        relaySet: toObject(relaySetMask, 771),
        speedOptoPort: getSpeedOptoPort(64),
        ten: 30,
        tu: 30,
        timeIntervalPowerOff: 3,
        reserved: 0,
        timeoutBadVAVB: 5,
        freqMax: 55,
        freqMin: 45,
        year: 0,
        month: 0,
        date: 0,
        energyDecimalPoint: 2,
        voltageTransformationRatioNumerator: 1,
        voltageTransformationRatioDenominator: 1,
        currentTransformationRatioNumerator: 1,
        currentTransformationRatioDenominator: 1,
        typeMeter: toObject(typeMeterMask, 0),
        phMin: 0,
        timeoutIMax: 5,
        timeoutPMax: 5,
        timeoutCos: 5,
        pMaxDef: 1,
        displaySet4: toObject(displaySet4Mask, 2147876864)
    });
    CommandBinaryBuffer.prototype.getOperatorParameters = function () {
        return {
            vpThreshold: this.getUint32(),
            vThreshold: this.getUint32(),
            ipThreshold: this.getUint32(),
            pmaxThreshold0: this.getUint32(),
            pmaxThreshold1: this.getUint32(),
            pmaxThreshold2: this.getUint32(),
            pmaxThreshold3: this.getUint32(),
            rmaxThreshold0: this.getUint32(),
            rmaxThreshold1: this.getUint32(),
            rmaxThreshold2: this.getUint32(),
            rmaxThreshold3: this.getUint32(),
            tint: this.getUint8(),
            calcPeriodDate: this.getUint8(),
            timeoutDisplay: this.getUint8(),
            timeoutScreen: this.getUint8(),
            displaySet1: toObject(displaySet1Mask, this.getUint32()),
            displaySet2: toObject(displaySet2Mask, this.getUint32()),
            displaySet3: toObject(displaySet3Mask, this.getUint32()),
            relaySet: toObject(relaySetMask, this.getUint32()),
            speedOptoPort: getSpeedOptoPort(this.getUint8()),
            ten: this.getUint8(),
            tu: this.getUint8(),
            timeIntervalPowerOff: this.getUint8(),
            reserved: this.getUint8(),
            timeoutBadVAVB: this.getUint8(),
            freqMax: this.getUint8(),
            freqMin: this.getUint8(),
            year: this.getUint8(),
            month: this.getUint8(),
            date: this.getUint8(),
            energyDecimalPoint: this.getUint8(),
            voltageTransformationRatioNumerator: this.getUint16(),
            voltageTransformationRatioDenominator: this.getUint16(),
            currentTransformationRatioNumerator: this.getUint16(),
            currentTransformationRatioDenominator: this.getUint16(),
            typeMeter: toObject(typeMeterMask, this.getUint8()),
            phMin: this.getUint16(),
            timeoutIMax: this.getUint8(),
            timeoutPMax: this.getUint8(),
            timeoutCos: this.getUint8(),
            pMaxDef: this.getUint8(),
            displaySet4: toObject(displaySet4Mask, this.getUint32())
        };
    };
    CommandBinaryBuffer.prototype.setOperatorParameters = function (operatorParameters) {
        this.setUint32(operatorParameters.vpThreshold);
        this.setUint32(operatorParameters.vThreshold);
        this.setUint32(operatorParameters.ipThreshold);
        this.setUint32(operatorParameters.pmaxThreshold0);
        this.setUint32(operatorParameters.pmaxThreshold1);
        this.setUint32(operatorParameters.pmaxThreshold2);
        this.setUint32(operatorParameters.pmaxThreshold3);
        this.setUint32(operatorParameters.rmaxThreshold0);
        this.setUint32(operatorParameters.rmaxThreshold1);
        this.setUint32(operatorParameters.rmaxThreshold2);
        this.setUint32(operatorParameters.rmaxThreshold3);
        this.setUint8(operatorParameters.tint);
        this.setUint8(operatorParameters.calcPeriodDate);
        this.setUint8(operatorParameters.timeoutDisplay);
        this.setUint8(operatorParameters.timeoutScreen);
        this.setUint32(fromObject(displaySet1Mask, operatorParameters.displaySet1));
        this.setUint32(fromObject(displaySet2Mask, operatorParameters.displaySet2));
        this.setUint32(fromObject(displaySet3Mask, operatorParameters.displaySet3));
        this.setUint32(fromObject(relaySetMask, operatorParameters.relaySet));
        this.setUint8(setSpeedOptoPort(operatorParameters.speedOptoPort));
        this.setUint8(operatorParameters.ten);
        this.setUint8(operatorParameters.tu);
        this.setUint8(operatorParameters.timeIntervalPowerOff);
        this.setUint8(operatorParameters.reserved);
        this.setUint8(operatorParameters.timeoutBadVAVB);
        this.setUint8(operatorParameters.freqMax);
        this.setUint8(operatorParameters.freqMin);
        this.setUint8(operatorParameters.year);
        this.setUint8(operatorParameters.month);
        this.setUint8(operatorParameters.date);
        this.setUint8(operatorParameters.energyDecimalPoint);
        this.setUint16(operatorParameters.voltageTransformationRatioNumerator);
        this.setUint16(operatorParameters.voltageTransformationRatioDenominator);
        this.setUint16(operatorParameters.currentTransformationRatioNumerator);
        this.setUint16(operatorParameters.currentTransformationRatioDenominator);
        this.setUint8(fromObject(typeMeterMask, operatorParameters.typeMeter));
        this.setUint16(operatorParameters.phMin);
        this.setUint8(operatorParameters.timeoutIMax);
        this.setUint8(operatorParameters.timeoutPMax);
        this.setUint8(operatorParameters.timeoutCos);
        this.setUint8(operatorParameters.pMaxDef);
        this.setUint32(fromObject(displaySet4Mask, operatorParameters.displaySet4));
    };
    CommandBinaryBuffer.prototype.getOperatorParametersExtended = function () {
        return {
            timeoutRelayOn: this.getUint8(),
            define1: toObject(define1Mask, this.getUint8()),
            timeoutRelayKey: this.getUint8(),
            timeoutRelayAuto: this.getUint8()
        };
    };
    CommandBinaryBuffer.prototype.setOperatorParametersExtended = function (operatorParametersExtended) {
        this.setUint8(operatorParametersExtended.timeoutRelayOn);
        this.setUint8(fromObject(define1Mask, operatorParametersExtended.define1));
        this.setUint8(operatorParametersExtended.timeoutRelayKey);
        this.setUint8(operatorParametersExtended.timeoutRelayAuto);
        this.setUint32(0);
        this.setUint8(0);
    };
    CommandBinaryBuffer.prototype.getEnergies = function () {
        const wh = [];
        const vari = [];
        const vare = [];
        for (let index = 0; index < TARIFF_NUMBER$1; index++) {
            wh.push(this.getInt32());
            vari.push(this.getInt32());
            vare.push(this.getInt32());
        }
        return { wh, vari, vare };
    };
    CommandBinaryBuffer.prototype.setEnergies = function (parameters) {
        for (let index = 0; index < TARIFF_NUMBER$1; index++) {
            this.setInt32(parameters.wh[index]);
            this.setInt32(parameters.vari[index]);
            this.setInt32(parameters.vare[index]);
        }
    };
    CommandBinaryBuffer.prototype.getPackedEnergyWithType = function () {
        const byte = this.getUint8();
        const energyType = extractBits(byte, ENERGY_TYPE_BITS, 1);
        const energies = getPackedEnergies(this, energyType, byte);
        return {
            energyType,
            energies
        };
    };
    CommandBinaryBuffer.prototype.setPackedEnergyWithType = function ({ energyType, energies }) {
        if (energyType) {
            const energyTypeByte = getPackedEnergyType(energyType, energies);
            const tariffsByte = energyTypeByte >> ENERGY_TYPE_BITS;
            this.setUint8(energyTypeByte);
            for (let index = 0; index < TARIFF_NUMBER$1; index++) {
                const isTariffExists = !!extractBits(tariffsByte, 1, index + 1);
                if (isTariffExists) {
                    this.setInt32(energies.wh[index]);
                    this.setInt32(energies.vari[index]);
                    this.setInt32(energies.vare[index]);
                }
            }
            return;
        }
        for (let index = 0; index < TARIFF_NUMBER$1; index++) {
            this.setInt32(energies.wh[index]);
            this.setInt32(energies.vari[index]);
            this.setInt32(energies.vare[index]);
        }
    };
    CommandBinaryBuffer.prototype.getEnergyPeriods = function (energiesNumber) {
        return new Array(energiesNumber).fill(0).map(() => {
            const energy = this.getUint16();
            return energy === 0xffff ? undefined : energy;
        });
    };
    CommandBinaryBuffer.prototype.setEnergyPeriods = function (energies) {
        energies.forEach(energy => this.setUint16(energy === undefined ? 0xffff : energy));
    };
    CommandBinaryBuffer.prototype.getMaxDemand = function () {
        return {
            hourPmax: this.getUint8(),
            minPmax: this.getUint8(),
            pmax: this.getInt32(),
            hourVariMax: this.getUint8(),
            minVariMax: this.getUint8(),
            variMax: this.getInt32(),
            hourVareMax: this.getUint8(),
            minVareMax: this.getUint8(),
            vareMax: this.getInt32()
        };
    };
    CommandBinaryBuffer.prototype.setMaxDemand = function (maxDemand) {
        this.setUint8(maxDemand.hourPmax);
        this.setUint8(maxDemand.minPmax);
        this.setInt32(maxDemand.pmax);
        this.setUint8(maxDemand.hourVariMax);
        this.setUint8(maxDemand.minVariMax);
        this.setInt32(maxDemand.variMax);
        this.setUint8(maxDemand.hourVareMax);
        this.setUint8(maxDemand.minVareMax);
        this.setInt32(maxDemand.vareMax);
    };
    CommandBinaryBuffer.prototype.getDayMaxDemandResponse = function () {
        const date = this.getDate();
        const maxDemands = new Array(TARIFF_NUMBER$1).fill(0).map(() => this.getMaxDemand());
        return { date, maxDemands };
    };
    CommandBinaryBuffer.prototype.setDayMaxDemandResponse = function (parameters) {
        this.setDate(parameters.date);
        parameters.maxDemands.forEach(value => this.setMaxDemand(value));
    };
    CommandBinaryBuffer.prototype.getMonthMaxDemandResponse = function () {
        const date = {
            year: this.getUint8(),
            month: this.getUint8()
        };
        const maxDemands = new Array(TARIFF_NUMBER$1).fill(0).map(() => this.getMaxDemand());
        return { date, maxDemands };
    };
    CommandBinaryBuffer.prototype.setMonthMaxDemandResponse = function (parameters) {
        this.setUint8(parameters.date.year);
        this.setUint8(parameters.date.month);
        parameters.maxDemands.forEach(value => this.setMaxDemand(value));
    };
    CommandBinaryBuffer.prototype.getEvent = function () {
        const data = {
            hours: this.getUint8(),
            minutes: this.getUint8(),
            seconds: this.getUint8(),
            event: this.getUint8()
        };
        const { event } = data;
        const { bytesLeft } = this;
        data.eventName = eventNames[event];
        switch (event) {
            case POWER_OVER_RELAY_OFF:
                if (bytesLeft < 4) {
                    return data;
                }
                data.power = [this.getUint8(), this.getUint8(), this.getUint8(), this.getUint8()];
                break;
            case CMD_CHANGE_TIME:
            case TIME_CORRECT:
                if (bytesLeft < 8) {
                    return data;
                }
                data.newDate = this.getDateTime();
                break;
        }
        return data;
    };
    CommandBinaryBuffer.prototype.setEvent = function (event) {
        this.setUint8(event.hours);
        this.setUint8(event.minutes);
        this.setUint8(event.seconds);
        this.setUint8(event.event);
        switch (event.event) {
            case POWER_OVER_RELAY_OFF:
                for (const item of event.power) {
                    this.setUint8(item);
                }
                break;
            case CMD_CHANGE_TIME:
            case TIME_CORRECT:
                this.setDateTime(event.newDate);
                break;
        }
    };
    CommandBinaryBuffer.prototype.getDemand = function () {
        const date0 = this.getUint8();
        const date1 = this.getUint8();
        return {
            date: {
                year: date0 >> 1,
                month: ((date0 << 3) & 0x0f) | (date1 >> 5),
                date: date1 & 0x1f
            },
            demandParam: this.getUint8(),
            firstIndex: this.getUint16(),
            count: this.getUint8(),
            period: this.getUint8()
        };
    };
    CommandBinaryBuffer.prototype.setDemand = function (parameters) {
        const date0 = (parameters.date.year << 1) | ((parameters.date.month >> 3) & 0x01);
        const date1 = ((parameters.date.month << 5) & 0xe0) | (parameters.date.date & 0x1f);
        this.setUint8(date0);
        this.setUint8(date1);
        this.setUint8(parameters.demandParam);
        this.setUint16(parameters.firstIndex);
        this.setUint8(parameters.count);
        this.setUint8(parameters.period);
    };
    CommandBinaryBuffer.prototype.getOperatorParametersExtended2 = function () {
        const operatorParametersExtended2 = {
            deltaCorMin: this.getUint8(),
            timeoutMagnetOff: this.getUint8(),
            relaySetExt: toObject(relaySetExtMask, this.getUint8()),
            timeoutMagnetOn: this.getUint8(),
            phaseDefault: this.getUint8(),
            displaySet21: toObject(displaySet1Mask, this.getUint32()),
            displaySet22: toObject(displaySet2Mask, this.getUint32()),
            displaySet23: toObject(displaySet3Mask, this.getUint32()),
            displaySet24: toObject(displaySet24Mask, this.getUint32()),
            channel1: this.getUint8(),
            channel2: this.getUint8(),
            channel3: this.getUint8(),
            channel4: this.getUint8(),
            channel5: this.getUint8(),
            channel6: this.getUint8(),
            timeCorrectPeriod: 0,
            timeCorrectPassHalfhour: false
        };
        const timeCorrectPeriod = this.getUint8();
        operatorParametersExtended2.timeCorrectPeriod = timeCorrectPeriod & 0x7f;
        operatorParametersExtended2.timeCorrectPassHalfhour = !!(timeCorrectPeriod & 0x80);
        return operatorParametersExtended2;
    };
    CommandBinaryBuffer.prototype.setOperatorParametersExtended2 = function (operatorParametersExtended2) {
        const timeCorrectPeriod = operatorParametersExtended2.timeCorrectPeriod
            | (operatorParametersExtended2.timeCorrectPassHalfhour ? 0x80 : 0);
        this.setUint8(operatorParametersExtended2.deltaCorMin);
        this.setUint8(operatorParametersExtended2.timeoutMagnetOff);
        this.setUint8(fromObject(relaySetExtMask, operatorParametersExtended2.relaySetExt));
        this.setUint8(operatorParametersExtended2.timeoutMagnetOn);
        this.setUint8(operatorParametersExtended2.phaseDefault);
        this.setUint32(fromObject(displaySet1Mask, operatorParametersExtended2.displaySet21));
        this.setUint32(fromObject(displaySet2Mask, operatorParametersExtended2.displaySet22));
        this.setUint32(fromObject(displaySet3Mask, operatorParametersExtended2.displaySet23));
        this.setUint32(fromObject(displaySet24Mask, operatorParametersExtended2.displaySet24));
        this.setUint8(operatorParametersExtended2.channel1);
        this.setUint8(operatorParametersExtended2.channel2);
        this.setUint8(operatorParametersExtended2.channel3);
        this.setUint8(operatorParametersExtended2.channel4);
        this.setUint8(operatorParametersExtended2.channel5);
        this.setUint8(operatorParametersExtended2.channel6);
        this.setUint8(timeCorrectPeriod);
    };
    CommandBinaryBuffer.prototype.getOperatorParametersExtended4 = function () {
        return {
            displaySet5: toObject(displaySet5Mask, this.getUint32()),
            displaySet25: toObject(displaySet5Mask, this.getUint32()),
            displaySet31: toObject(displaySet1Mask, this.getUint32()),
            displaySet32: toObject(displaySet1Mask, this.getUint32()),
            displaySet33: toObject(displaySet1Mask, this.getUint32()),
            displaySet34: toObject(displaySet1Mask, this.getUint32()),
            displaySet35: toObject(displaySet5Mask, this.getUint32())
        };
    };
    CommandBinaryBuffer.prototype.setOperatorParametersExtended4 = function (operatorParametersExtended) {
        this.setUint32(fromObject(displaySet5Mask, operatorParametersExtended.displaySet5));
        this.setUint32(fromObject(displaySet5Mask, operatorParametersExtended.displaySet25));
        this.setUint32(fromObject(displaySet1Mask, operatorParametersExtended.displaySet31));
        this.setUint32(fromObject(displaySet1Mask, operatorParametersExtended.displaySet32));
        this.setUint32(fromObject(displaySet1Mask, operatorParametersExtended.displaySet33));
        this.setUint32(fromObject(displaySet1Mask, operatorParametersExtended.displaySet34));
        this.setUint32(fromObject(displaySet5Mask, operatorParametersExtended.displaySet35));
    };
    const getPackedEnergiesWithDateSize = (parameters) => {
        const { wh, vari, vare } = parameters.energies;
        if (parameters?.energyType) {
            const energiesNumber = [...wh, ...vari, ...vare].filter(energy => energy !== null).length;
            return DATE_SIZE$1 + PACKED_ENERGY_TYPE_SIZE + (energiesNumber * ENERGY_SIZE);
        }
        return DATE_SIZE$1 + ENERGY_SIZE * TARIFF_NUMBER$1;
    };

    const MIN_COMMAND_SIZE$2 = 3;
    const MAX_COMMAND_SIZE$2 = 4;
    const id$1r = getDayDemand;
    downlinkNames[getDayDemand];
    const fromBytes$1t = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        if (bytes.length === MAX_COMMAND_SIZE$2) {
            return {
                date: buffer.getDate(),
                energyType: buffer.getUint8()
            };
        }
        return { date: buffer.getDate() };
    };
    const toBytes$1t = (parameters) => {
        const buffer = new CommandBinaryBuffer(parameters?.energyType ? MAX_COMMAND_SIZE$2 : MIN_COMMAND_SIZE$2);
        buffer.setDate(parameters?.date);
        if (parameters?.energyType) {
            buffer.setUint8(parameters.energyType);
        }
        return toBytes$2g(id$1r, buffer.data);
    };

    const id$1q = getDayDemandExport;
    downlinkNames[getDayDemandExport];
    const maxSize$19 = 3;
    const fromBytes$1s = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return { date: buffer.getDate() };
    };
    const toBytes$1s = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$19);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$1q, buffer.data);
    };

    const id$1p = getDemand;
    downlinkNames[getDemand];
    const maxSize$18 = 7;
    const fromBytes$1r = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getDemand();
    };
    const toBytes$1r = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$18);
        buffer.setDemand(parameters);
        return toBytes$2g(id$1p, buffer.data);
    };

    const id$1o = getDisplayParam;
    downlinkNames[getDisplayParam];
    const maxSize$17 = 1;
    const fromBytes$1q = ([displayMode]) => ({ displayMode });
    const toBytes$1q = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$17);
        buffer.setUint8(parameters.displayMode);
        return toBytes$2g(id$1o, buffer.data);
    };

    const id$1n = getEnergy;
    downlinkNames[getEnergy];
    const maxSize$16 = 0;
    const fromBytes$1p = (bytes) => {
        if (bytes.length !== maxSize$16) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1p = () => toBytes$2g(id$1n);

    const MIN_COMMAND_SIZE$1 = 0;
    const MAX_COMMAND_SIZE$1 = 1;
    const id$1m = getEnergyDayPrevious;
    downlinkNames[getEnergyDayPrevious];
    const fromBytes$1o = (bytes) => {
        const { length } = bytes;
        if (length !== MAX_COMMAND_SIZE$1 && length !== MIN_COMMAND_SIZE$1) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        if (length === MAX_COMMAND_SIZE$1) {
            return { energyType: bytes[0] };
        }
        return {};
    };
    const toBytes$1o = (parameters) => {
        if (parameters.energyType) {
            return toBytes$2g(id$1m, [parameters.energyType]);
        }
        return toBytes$2g(id$1m);
    };

    const id$1l = getEnergyExport;
    downlinkNames[getEnergyExport];
    const maxSize$15 = 0;
    const fromBytes$1n = (bytes) => {
        if (bytes.length !== maxSize$15) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1n = () => toBytes$2g(id$1l);

    const id$1k = getEnergyExportDayPrevious;
    downlinkNames[getEnergyExportDayPrevious];
    const maxSize$14 = 0;
    const fromBytes$1m = (bytes) => {
        if (bytes.length !== maxSize$14) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1m = () => toBytes$2g(id$1k);

    const id$1j = getHalfHourDemandChannel;
    downlinkNames[getHalfHourDemandChannel];
    const maxSize$13 = 5;
    const fromBytes$1l = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return {
            channel: buffer.getUint8(),
            channelParameter: buffer.getUint8(),
            date: buffer.getDate()
        };
    };
    const toBytes$1l = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$13);
        buffer.setUint8(parameters.channel);
        buffer.setUint8(parameters.channelParameter);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$1j, buffer.data);
    };

    const id$1i = getHalfHourDemandVare;
    downlinkNames[getHalfHourDemandVare];
    const maxSize$12 = 3;
    const fromBytes$1k = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return { date: buffer.getDate() };
    };
    const toBytes$1k = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$12);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$1i, buffer.data);
    };

    const id$1h = getHalfHourDemandVareExport;
    downlinkNames[getHalfHourDemandVareExport];
    const maxSize$11 = 3;
    const fromBytes$1j = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return { date: buffer.getDate() };
    };
    const toBytes$1j = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$11);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$1h, buffer.data);
    };

    const id$1g = getHalfHourDemandVari;
    downlinkNames[getHalfHourDemandVari];
    const maxSize$10 = 3;
    const fromBytes$1i = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return { date: buffer.getDate() };
    };
    const toBytes$1i = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$10);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$1g, buffer.data);
    };

    const id$1f = getHalfHourDemandVariExport;
    downlinkNames[getHalfHourDemandVariExport];
    const maxSize$ = 3;
    const fromBytes$1h = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return { date: buffer.getDate() };
    };
    const toBytes$1h = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$);
        buffer.setDate(parameters.date);
        return toBytes$2g(id$1f, buffer.data);
    };

    const id$1e = getOperatorParametersExtended;
    downlinkNames[getOperatorParametersExtended];
    const maxSize$_ = 0;
    const fromBytes$1g = (bytes) => {
        if (bytes.length !== maxSize$_) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1g = () => toBytes$2g(id$1e);

    const id$1d = getOperatorParametersExtended2;
    downlinkNames[getOperatorParametersExtended2];
    const maxSize$Z = 0;
    const fromBytes$1f = (bytes) => {
        if (bytes.length !== maxSize$Z) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1f = () => toBytes$2g(id$1d);

    const id$1c = setDisplayParam;
    downlinkNames[setDisplayParam];
    const maxSize$Y = 65;
    const fromBytes$1e = (bytes) => {
        if (bytes.length < 1 || bytes.length > maxSize$Y) {
            throw new Error('Invalid SetDisplayParam data size.');
        }
        const [displayMode, ...order] = bytes;
        return { displayMode, order };
    };
    const toBytes$1e = (parameters) => (toBytes$2g(id$1c, [
        parameters.displayMode,
        ...parameters.order
    ]));

    const id$1b = setOperatorParameters;
    downlinkNames[setOperatorParameters];
    const maxSize$X = OPERATOR_PARAMETERS_SIZE;
    const fromBytes$1d = (bytes) => {
        if (bytes.length !== maxSize$X) {
            throw new Error('Invalid SetOpParams data size.');
        }
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getOperatorParameters();
    };
    const toBytes$1d = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$X);
        buffer.setOperatorParameters(parameters);
        return toBytes$2g(id$1b, buffer.data);
    };

    const id$1a = setOperatorParametersExtended;
    downlinkNames[setOperatorParametersExtended];
    const maxSize$W = OPERATOR_PARAMETERS_EXTENDED_SIZE;
    const fromBytes$1c = (bytes) => {
        if (bytes.length !== maxSize$W) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getOperatorParametersExtended();
    };
    const toBytes$1c = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$W);
        buffer.setOperatorParametersExtended(parameters);
        return toBytes$2g(id$1a, buffer.data);
    };

    const id$19 = setOperatorParametersExtended2;
    downlinkNames[setOperatorParametersExtended2];
    const maxSize$V = OPERATOR_PARAMETERS_EXTENDED2_SIZE;
    const fromBytes$1b = (bytes) => {
        if (bytes.length !== maxSize$V) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getOperatorParametersExtended2();
    };
    const toBytes$1b = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$V);
        buffer.setOperatorParametersExtended2(parameters);
        return toBytes$2g(id$19, buffer.data);
    };

    const id$18 = setOperatorParametersExtended4;
    downlinkNames[setOperatorParametersExtended4];
    const maxSize$U = OPERATOR_PARAMETERS_EXTENDED4_SIZE;
    const fromBytes$1a = (bytes) => {
        if (bytes.length !== maxSize$U) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getOperatorParametersExtended4();
    };
    const toBytes$1a = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$U);
        buffer.setOperatorParametersExtended4(parameters);
        return toBytes$2g(id$18, buffer.data);
    };

    const toBytesMap$1 = {};
    const fromBytesMap$1 = {};
    const toBytes$19 = getToBytes$1(toBytesMap$1);
    toBytesMap$1[id$2d] = toBytes$2f;
    toBytesMap$1[id$2c] = toBytes$2e;
    toBytesMap$1[id$2b] = toBytes$2d;
    toBytesMap$1[id$2a] = toBytes$2c;
    toBytesMap$1[id$29] = toBytes$2b;
    toBytesMap$1[id$28] = toBytes$2a;
    toBytesMap$1[id$28] = toBytes$2a;
    toBytesMap$1[id$27] = toBytes$29;
    toBytesMap$1[id$26] = toBytes$28;
    toBytesMap$1[id$25] = toBytes$27;
    toBytesMap$1[id$24] = toBytes$26;
    toBytesMap$1[id$23] = toBytes$25;
    toBytesMap$1[id$22] = toBytes$24;
    toBytesMap$1[id$21] = toBytes$23;
    toBytesMap$1[id$20] = toBytes$22;
    toBytesMap$1[id$1$] = toBytes$21;
    toBytesMap$1[id$1_] = toBytes$20;
    toBytesMap$1[id$1Z] = toBytes$1$;
    toBytesMap$1[id$1Y] = toBytes$1_;
    toBytesMap$1[id$1X] = toBytes$1Z;
    toBytesMap$1[id$1W] = toBytes$1Y;
    toBytesMap$1[id$1V] = toBytes$1X;
    toBytesMap$1[id$1U] = toBytes$1W;
    toBytesMap$1[id$1T] = toBytes$1V;
    toBytesMap$1[id$1S] = toBytes$1U;
    toBytesMap$1[id$1Q] = toBytes$1S;
    toBytesMap$1[id$1R] = toBytes$1T;
    toBytesMap$1[id$1P] = toBytes$1R;
    toBytesMap$1[id$1O] = toBytes$1Q;
    toBytesMap$1[id$1N] = toBytes$1P;
    toBytesMap$1[id$1M] = toBytes$1O;
    toBytesMap$1[id$1L] = toBytes$1N;
    toBytesMap$1[id$1K] = toBytes$1M;
    toBytesMap$1[id$1J] = toBytes$1L;
    toBytesMap$1[id$1I] = toBytes$1K;
    toBytesMap$1[id$1H] = toBytes$1J;
    toBytesMap$1[id$1G] = toBytes$1I;
    toBytesMap$1[id$1F] = toBytes$1H;
    toBytesMap$1[id$1E] = toBytes$1G;
    toBytesMap$1[id$1D] = toBytes$1F;
    toBytesMap$1[id$1C] = toBytes$1E;
    toBytesMap$1[id$1B] = toBytes$1D;
    toBytesMap$1[id$1A] = toBytes$1C;
    toBytesMap$1[id$1z] = toBytes$1B;
    toBytesMap$1[id$1y] = toBytes$1A;
    toBytesMap$1[id$1x] = toBytes$1z;
    toBytesMap$1[id$1w] = toBytes$1y;
    toBytesMap$1[id$1v] = toBytes$1x;
    toBytesMap$1[id$1u] = toBytes$1w;
    toBytesMap$1[id$1t] = toBytes$1v;
    toBytesMap$1[id$1s] = toBytes$1u;
    toBytesMap$1[id$1r] = toBytes$1t;
    toBytesMap$1[id$1q] = toBytes$1s;
    toBytesMap$1[id$1p] = toBytes$1r;
    toBytesMap$1[id$1o] = toBytes$1q;
    toBytesMap$1[id$1n] = toBytes$1p;
    toBytesMap$1[id$1m] = toBytes$1o;
    toBytesMap$1[id$1l] = toBytes$1n;
    toBytesMap$1[id$1k] = toBytes$1m;
    toBytesMap$1[id$1j] = toBytes$1l;
    toBytesMap$1[id$1i] = toBytes$1k;
    toBytesMap$1[id$1h] = toBytes$1j;
    toBytesMap$1[id$1g] = toBytes$1i;
    toBytesMap$1[id$1f] = toBytes$1h;
    toBytesMap$1[id$1e] = toBytes$1g;
    toBytesMap$1[id$1d] = toBytes$1f;
    toBytesMap$1[id$1c] = toBytes$1e;
    toBytesMap$1[id$1b] = toBytes$1d;
    toBytesMap$1[id$1a] = toBytes$1c;
    toBytesMap$1[id$19] = toBytes$1b;
    toBytesMap$1[id$18] = toBytes$1a;
    fromBytesMap$1[id$2d] = fromBytes$2f;
    fromBytesMap$1[id$2c] = fromBytes$2e;
    fromBytesMap$1[id$2b] = fromBytes$2d;
    fromBytesMap$1[id$2a] = fromBytes$2c;
    fromBytesMap$1[id$29] = fromBytes$2b;
    fromBytesMap$1[id$28] = fromBytes$2a;
    fromBytesMap$1[id$27] = fromBytes$29;
    fromBytesMap$1[id$26] = fromBytes$28;
    fromBytesMap$1[id$25] = fromBytes$27;
    fromBytesMap$1[id$24] = fromBytes$26;
    fromBytesMap$1[id$23] = fromBytes$25;
    fromBytesMap$1[id$22] = fromBytes$24;
    fromBytesMap$1[id$21] = fromBytes$23;
    fromBytesMap$1[id$20] = fromBytes$22;
    fromBytesMap$1[id$1$] = fromBytes$21;
    fromBytesMap$1[id$1_] = fromBytes$20;
    fromBytesMap$1[id$1Z] = fromBytes$1$;
    fromBytesMap$1[id$1Y] = fromBytes$1_;
    fromBytesMap$1[id$1X] = fromBytes$1Z;
    fromBytesMap$1[id$1W] = fromBytes$1Y;
    fromBytesMap$1[id$1V] = fromBytes$1X;
    fromBytesMap$1[id$1U] = fromBytes$1W;
    fromBytesMap$1[id$1T] = fromBytes$1V;
    fromBytesMap$1[id$1S] = fromBytes$1U;
    fromBytesMap$1[id$1Q] = fromBytes$1S;
    fromBytesMap$1[id$1R] = fromBytes$1T;
    fromBytesMap$1[id$1P] = fromBytes$1R;
    fromBytesMap$1[id$1O] = fromBytes$1Q;
    fromBytesMap$1[id$1N] = fromBytes$1P;
    fromBytesMap$1[id$1M] = fromBytes$1O;
    fromBytesMap$1[id$1L] = fromBytes$1N;
    fromBytesMap$1[id$1K] = fromBytes$1M;
    fromBytesMap$1[id$1J] = fromBytes$1L;
    fromBytesMap$1[id$1I] = fromBytes$1K;
    fromBytesMap$1[id$1H] = fromBytes$1J;
    fromBytesMap$1[id$1G] = fromBytes$1I;
    fromBytesMap$1[id$1F] = fromBytes$1H;
    fromBytesMap$1[id$1E] = fromBytes$1G;
    fromBytesMap$1[id$1D] = fromBytes$1F;
    fromBytesMap$1[id$1C] = fromBytes$1E;
    fromBytesMap$1[id$1B] = fromBytes$1D;
    fromBytesMap$1[id$1A] = fromBytes$1C;
    fromBytesMap$1[id$1z] = fromBytes$1B;
    fromBytesMap$1[id$1y] = fromBytes$1A;
    fromBytesMap$1[id$1x] = fromBytes$1z;
    fromBytesMap$1[id$1w] = fromBytes$1y;
    fromBytesMap$1[id$1v] = fromBytes$1x;
    fromBytesMap$1[id$1u] = fromBytes$1w;
    fromBytesMap$1[id$1t] = fromBytes$1v;
    fromBytesMap$1[id$1s] = fromBytes$1u;
    fromBytesMap$1[id$1r] = fromBytes$1t;
    fromBytesMap$1[id$1q] = fromBytes$1s;
    fromBytesMap$1[id$1p] = fromBytes$1r;
    fromBytesMap$1[id$1o] = fromBytes$1q;
    fromBytesMap$1[id$1n] = fromBytes$1p;
    fromBytesMap$1[id$1m] = fromBytes$1o;
    fromBytesMap$1[id$1l] = fromBytes$1n;
    fromBytesMap$1[id$1k] = fromBytes$1m;
    fromBytesMap$1[id$1j] = fromBytes$1l;
    fromBytesMap$1[id$1i] = fromBytes$1k;
    fromBytesMap$1[id$1h] = fromBytes$1j;
    fromBytesMap$1[id$1g] = fromBytes$1i;
    fromBytesMap$1[id$1f] = fromBytes$1h;
    fromBytesMap$1[id$1e] = fromBytes$1g;
    fromBytesMap$1[id$1d] = fromBytes$1f;
    fromBytesMap$1[id$1c] = fromBytes$1e;
    fromBytesMap$1[id$1b] = fromBytes$1d;
    fromBytesMap$1[id$1a] = fromBytes$1c;
    fromBytesMap$1[id$19] = fromBytes$1b;
    fromBytesMap$1[id$18] = fromBytes$1a;

    const id$17 = activateRatePlan$1;
    commandNames[activateRatePlan$1];
    const maxSize$T = 0;
    const fromBytes$19 = (bytes) => {
        if (bytes.length !== maxSize$T) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$18 = () => toBytes$2g(id$17);

    const id$16 = errorResponse$1;
    const name = commandNames[errorResponse$1];
    const headerSize = 2;
    const accessLevel = READ_ONLY;
    const maxSize$S = 2;
    const isLoraOnly = false;
    const examples = {
        'ACCESS_DENIED on TurnRelayOn command': {
            id: id$16,
            name,
            headerSize,
            maxSize: maxSize$S,
            accessLevel,
            parameters: {
                commandId: 0x18,
                commandName: 'turnRelayOn',
                errorCode: ACCESS_DENIED,
                errorName: 'ACCESS_DENIED'
            },
            bytes: [
                0xfe, 0x02,
                0x18, 0x93
            ]
        }
    };
    const getFromBytes$1 = (commandNamesParameter) => ((bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        const errorCommandId = buffer.getUint8();
        const errorCode = buffer.getUint8();
        return {
            commandId: errorCommandId,
            commandName: commandNamesParameter[errorCommandId],
            errorCode,
            errorName: resultNames[errorCode]
        };
    });
    const fromBytes$18 = getFromBytes$1(commandNames);
    const toBytes$17 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$S);
        buffer.setUint8(parameters.commandId);
        buffer.setUint8(parameters.errorCode);
        return toBytes$2g(id$16, buffer.data);
    };

    var mtx1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        accessLevel: accessLevel,
        examples: examples,
        fromBytes: fromBytes$18,
        getFromBytes: getFromBytes$1,
        headerSize: headerSize,
        id: id$16,
        isLoraOnly: isLoraOnly,
        maxSize: maxSize$S,
        name: name,
        toBytes: toBytes$17
    });

    const id$15 = getBuildVersion$1;
    commandNames[getBuildVersion$1];
    const maxSize$R = 6;
    const fromBytes$17 = (bytes) => {
        if (bytes.length !== maxSize$R) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const [date, month, year, n3, n2, n1] = bytes;
        return {
            date: {
                date,
                month,
                year
            },
            version: `${n3}.${n2}.${n1}`
        };
    };
    const toBytes$16 = (parameters) => {
        const { date, version } = parameters;
        const versionParts = version.split('.').map(part => parseInt(part, 10));
        return toBytes$2g(id$15, [date.date, date.month, date.year, ...versionParts]);
    };

    const id$14 = getCorrectTime$1;
    commandNames[getCorrectTime$1];
    const maxSize$Q = 9;
    const fromBytes$16 = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getTimeCorrectionParameters();
    };
    const toBytes$15 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$Q);
        buffer.setTimeCorrectionParameters(parameters);
        return toBytes$2g(id$14, buffer.data);
    };

    commandNames[getCriticalEvent$1];

    commandNames[getCurrentStatusMeter$1];

    commandNames[getCurrentValues$1];

    const id$13 = getDateTime$1;
    commandNames[getDateTime$1];
    const maxSize$P = 8;
    const fromBytes$15 = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getDateTime();
    };
    const toBytes$14 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$P);
        buffer.setDateTime(parameters);
        return toBytes$2g(id$13, buffer.data);
    };

    commandNames[getDayDemand$1];

    commandNames[getDayDemandExport$1];

    commandNames[getDayEnergies];

    commandNames[getDayMaxDemand$1];

    commandNames[getDayMaxDemandExport$1];

    commandNames[getDayMaxDemandPrevious];

    commandNames[getDayMaxPower];

    const MAX_PERIODS_NUMBER = 8;
    const PERIODS_FINAL_BYTE = 0xff;
    const id$12 = getDayProfile$1;
    commandNames[getDayProfile$1];
    const fromBytes$14 = (bytes) => {
        const finalByteIndex = bytes.indexOf(PERIODS_FINAL_BYTE);
        const cleanData = finalByteIndex === -1 ? bytes : bytes.slice(0, finalByteIndex);
        return {
            periods: [...cleanData].map(CommandBinaryBuffer$2.getDayProfileFromByte)
        };
    };
    const toBytes$13 = (parameters) => {
        const hasPeriodsFinalByte = parameters.periods.length < MAX_PERIODS_NUMBER;
        const size = parameters.periods.length + +hasPeriodsFinalByte;
        const buffer = new CommandBinaryBuffer$2(size);
        parameters.periods.forEach(period => {
            buffer.setDayProfile(period);
        });
        if (hasPeriodsFinalByte) {
            buffer.setUint8(PERIODS_FINAL_BYTE);
        }
        return toBytes$2g(id$12, buffer.data);
    };

    commandNames[getDemand$1];

    const id$11 = getDeviceId$1;
    commandNames[getDeviceId$1];
    const maxSize$O = 8;
    const fromBytes$13 = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getDeviceId();
    };
    const toBytes$12 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$O);
        buffer.setDeviceId(parameters);
        return toBytes$2g(id$11, buffer.data);
    };

    const id$10 = getDeviceType$1;
    commandNames[getDeviceType$1];
    const maxSize$N = 9;
    const fromBytes$12 = (data) => {
        const buffer = new CommandBinaryBuffer$2(data);
        return buffer.getDeviceType();
    };
    const toBytes$11 = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$N);
        buffer.setDeviceType(parameters);
        return toBytes$2g(id$10, buffer.data);
    };

    commandNames[getDisplayParam$1];

    commandNames[getEnergy$1];

    commandNames[getEnergyDayPrevious$1];

    commandNames[getEnergyExport$1];

    commandNames[getEnergyExportDayPrevious$1];

    const BODY_WITHOUT_EVENTS_SIZE = 3 + 1;
    const EVENT_SIZE = 4;
    const id$ = getEvents$1;
    commandNames[getEvents$1];
    const maxSize$M = BODY_WITHOUT_EVENTS_SIZE + 255 * EVENT_SIZE;
    const getFromBytes = BinaryBufferConstructor => ((bytes) => {
        if (bytes.length > maxSize$M) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new BinaryBufferConstructor(bytes);
        const date = buffer.getDate();
        const eventsNumber = buffer.getUint8();
        const events = [];
        while (!buffer.isEmpty) {
            events.push(buffer.getEvent());
        }
        return { date, eventsNumber, events };
    });
    const getToBytes = BinaryBufferConstructor => ((parameters) => {
        const buffer = new BinaryBufferConstructor(maxSize$M);
        buffer.setDate(parameters.date);
        buffer.setUint8(parameters.eventsNumber);
        for (const event of parameters.events) {
            buffer.setEvent(event);
        }
        return toBytes$2g(id$, buffer.getBytesToOffset());
    });
    const fromBytes$11 = getFromBytes(CommandBinaryBuffer$2);
    const toBytes$10 = getToBytes(CommandBinaryBuffer$2);

    const COMMAND_BODY_SIZE = 14;
    const OLD_COMMAND_BODY_SIZE = 20;
    const id$_ = getEventsCounters$1;
    commandNames[getEventsCounters$1];
    const fromBytes$10 = (bytes) => {
        if ((bytes.length !== COMMAND_BODY_SIZE && bytes.length !== OLD_COMMAND_BODY_SIZE)) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const buffer = new CommandBinaryBuffer$2(bytes);
        const restart = buffer.getUint16();
        const powerOff = buffer.getUint16();
        const localParametersChange = buffer.getUint16();
        const remoteParametersChange = buffer.getUint16();
        const accessError = buffer.getUint16();
        const accessClosed = buffer.getUint16();
        const setClock = buffer.getUint16();
        return {
            accessClosed, accessError, localParametersChange, remoteParametersChange, powerOff, restart, setClock
        };
    };
    const toBytes$ = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(COMMAND_BODY_SIZE);
        buffer.setUint16(parameters.restart);
        buffer.setUint16(parameters.powerOff);
        buffer.setUint16(parameters.localParametersChange);
        buffer.setUint16(parameters.remoteParametersChange);
        buffer.setUint16(parameters.accessError);
        buffer.setUint16(parameters.accessClosed);
        buffer.setUint16(parameters.setClock);
        return toBytes$2g(id$_, buffer.data);
    };

    const id$Z = getEventStatus$1;
    commandNames[getEventStatus$1];
    const maxSize$L = 2;
    const fromBytes$ = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes, true);
        return buffer.getEventStatus();
    };
    const toBytes$_ = (eventStatus) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$L, true);
        buffer.setEventStatus(eventStatus);
        return toBytes$2g(id$Z, buffer.data);
    };

    commandNames[getExtendedCurrentValues$1];

    commandNames[getExtendedCurrentValues2];

    commandNames[getHalfHourDemand$1];

    commandNames[getHalfHourDemandExport$1];

    commandNames[getHalfHourDemandPrevious];

    const DATE_SIZE = 2;
    const ENERGY_FLAGS_SIZE = 1;
    const START_HALFHOUR_SIZE = 1;
    const HALFHOURS_NUMBER_SIZE = 1;
    const MAX_HALFHOURS_ENERGY_SIZE = 247;
    const id$Y = getHalfhoursEnergies$1;
    commandNames[getHalfhoursEnergies$1];
    const maxSize$K = DATE_SIZE + ENERGY_FLAGS_SIZE + START_HALFHOUR_SIZE + HALFHOURS_NUMBER_SIZE + MAX_HALFHOURS_ENERGY_SIZE;
    const fromBytes$_ = (bytes) => {
        const buffer = new CommandBinaryBuffer$1(bytes);
        const date = buffer.getDate();
        const energiesFlags = buffer.getEnergiesFlags();
        const firstHalfhour = buffer.getUint8();
        const halfhoursNumber = buffer.getUint8();
        return {
            date,
            firstHalfhour,
            halfhoursNumber,
            energies: buffer.getHalfhoursEnergies(energiesFlags, halfhoursNumber)
        };
    };
    const toBytes$Z = (parameters) => {
        const buffer = new CommandBinaryBuffer$1(maxSize$K);
        const { date, firstHalfhour, halfhoursNumber, energies } = parameters;
        buffer.setDate(date);
        buffer.setEnergiesFlags(energies);
        buffer.setUint8(firstHalfhour);
        buffer.setUint8(halfhoursNumber);
        buffer.setHalfhoursEnergies(energies);
        return toBytes$2g(id$Y, buffer.getBytesToOffset());
    };

    const id$X = getMagneticFieldThreshold$1;
    commandNames[getMagneticFieldThreshold$1];
    const maxSize$J = 10;
    const fromBytes$Z = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            induction: buffer.getUint16(),
            threshold: buffer.getUint16(),
            inductionCoefficient: buffer.getUint16() / 100,
            reserved: buffer.getUint32()
        };
    };
    const toBytes$Y = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$J);
        buffer.setUint16(parameters.induction);
        buffer.setUint16(parameters.threshold);
        buffer.setUint16(parameters.inductionCoefficient * 100);
        buffer.setUint32(parameters.reserved);
        return toBytes$2g(id$X, buffer.data);
    };

    const id$W = getMeterInfo$1;
    commandNames[getMeterInfo$1];
    const fromBytes$Y = ([ten]) => ({ ten });
    const toBytes$X = ({ ten }) => toBytes$2g(id$W, [ten]);

    commandNames[getMonthDemand$1];

    commandNames[getMonthDemandExport$1];

    commandNames[getMonthMaxDemand$1];

    commandNames[getMonthMaxDemandExport$1];

    const id$V = getOperatorParametersExtended3$1;
    commandNames[getOperatorParametersExtended3$1];
    const maxSize$I = 17;
    const fromBytes$X = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getOperatorParametersExtended3();
    };
    const toBytes$W = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$I);
        buffer.setOperatorParametersExtended3(parameters);
        return toBytes$2g(id$V, buffer.data);
    };

    commandNames[getOperatorParameters$1];

    const id$U = getRatePlanInfo$1;
    commandNames[getRatePlanInfo$1];
    const maxSize$H = 1 + TARIFF_PLAN_SIZE * 2;
    const fromBytes$W = (bytes) => {
        if (bytes.length !== maxSize$H) {
            throw new Error('Invalid getRatePlanInfo data size.');
        }
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            tariffTable: buffer.getUint8(),
            activePlan: buffer.getTariffPlan(),
            passivePlan: buffer.getTariffPlan()
        };
    };
    const toBytes$V = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$H);
        buffer.setUint8(parameters.tariffTable);
        buffer.setTariffPlan(parameters.activePlan);
        buffer.setTariffPlan(parameters.passivePlan);
        return toBytes$2g(id$U, buffer.data);
    };

    const id$T = getSaldo$1;
    commandNames[getSaldo$1];
    const maxSize$G = 29;
    const fromBytes$V = (bytes) => {
        if (bytes.length !== maxSize$G) {
            throw new Error('Invalid getSaldo data size.');
        }
        const buffer = new CommandBinaryBuffer$2(bytes);
        return {
            currentSaldo: buffer.getInt32(),
            count: buffer.getUint8(),
            energy: new Array(4).fill(0).map(() => buffer.getInt32()),
            beginSaldoOfPeriod: buffer.getInt32(),
            date: {
                month: buffer.getUint8(),
                date: buffer.getUint8(),
                hours: buffer.getUint8(),
                minutes: buffer.getUint8()
            }
        };
    };
    const toBytes$U = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$G);
        buffer.setInt32(parameters.currentSaldo);
        buffer.setUint8(parameters.count);
        parameters.energy.forEach(value => buffer.setInt32(value));
        buffer.setInt32(parameters.beginSaldoOfPeriod);
        buffer.setUint8(parameters.date.month);
        buffer.setUint8(parameters.date.date);
        buffer.setUint8(parameters.date.hours);
        buffer.setUint8(parameters.date.minutes);
        return toBytes$2g(id$T, buffer.data);
    };

    const id$S = getSaldoParameters$1;
    commandNames[getSaldoParameters$1];
    const maxSize$F = 37;
    const fromBytes$U = (bytes) => {
        if (bytes.length !== maxSize$F) {
            throw new Error('Invalid getSaldoParameters data size.');
        }
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getSaldoParameters();
    };
    const toBytes$T = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$F);
        buffer.setSaldoParameters(parameters);
        return toBytes$2g(id$S, buffer.data);
    };

    const id$R = getSeasonProfile$1;
    commandNames[getSeasonProfile$1];
    const maxSize$E = 9;
    const fromBytes$T = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getSeasonProfile();
    };
    const toBytes$S = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$E);
        buffer.setSeasonProfile(parameters);
        return toBytes$2g(id$R, buffer.data);
    };

    const id$Q = getSpecialDay$1;
    commandNames[getSpecialDay$1];
    const maxSize$D = 4;
    const fromBytes$S = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        return buffer.getSpecialDay();
    };
    const toBytes$R = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$D);
        buffer.setSpecialDay(parameters);
        return toBytes$2g(id$Q, buffer.data);
    };

    const id$P = getVersion$1;
    commandNames[getVersion$1];
    const fromBytes$R = (bytes) => ({ version: String.fromCharCode.apply(null, [...bytes]) });
    const toBytes$Q = (parameters) => {
        const version = parameters.version.split('').map(char => char.charCodeAt(0));
        return toBytes$2g(id$P, version);
    };

    const id$O = prepareRatePlan$1;
    commandNames[prepareRatePlan$1];
    const maxSize$C = 0;
    const fromBytes$Q = (bytes) => {
        if (bytes.length !== maxSize$C) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$P = () => toBytes$2g(id$O);

    const id$N = resetPowerMaxDay$1;
    commandNames[resetPowerMaxDay$1];
    const maxSize$B = 0;
    const fromBytes$P = (bytes) => {
        if (bytes.length !== maxSize$B) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$O = () => toBytes$2g(id$N);

    const id$M = resetPowerMaxMonth$1;
    commandNames[resetPowerMaxMonth$1];
    const maxSize$A = 0;
    const fromBytes$O = (bytes) => {
        if (bytes.length !== maxSize$A) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$N = () => toBytes$2g(id$M);

    const id$L = runTariffPlan$1;
    commandNames[runTariffPlan$1];
    const maxSize$z = 0;
    const fromBytes$N = (bytes) => {
        if (bytes.length !== maxSize$z) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$M = () => toBytes$2g(id$L);

    const id$K = setAccessKey$1;
    commandNames[setAccessKey$1];
    const maxSize$y = 0;
    const fromBytes$M = (bytes) => {
        if (bytes.length !== maxSize$y) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$L = () => toBytes$2g(id$K);

    const id$J = setCorrectDateTime$1;
    commandNames[setCorrectDateTime$1];
    const maxSize$x = 0;
    const fromBytes$L = (bytes) => {
        if (bytes.length !== maxSize$x) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$K = () => toBytes$2g(id$J);

    const id$I = setCorrectTime$1;
    commandNames[setCorrectTime$1];
    const maxSize$w = 0;
    const fromBytes$K = (bytes) => {
        if (bytes.length !== maxSize$w) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$J = () => toBytes$2g(id$I);

    const id$H = setDateTime$1;
    commandNames[setDateTime$1];
    const maxSize$v = 0;
    const fromBytes$J = (bytes) => {
        if (bytes.length !== maxSize$v) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$I = () => toBytes$2g(id$H);

    const id$G = setDayProfile$1;
    commandNames[setDayProfile$1];
    const maxSize$u = 0;
    const fromBytes$I = (bytes) => {
        if (bytes.length !== maxSize$u) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$H = () => toBytes$2g(id$G);

    const id$F = setDisplayParam$1;
    commandNames[setDisplayParam$1];
    const maxSize$t = 0;
    const fromBytes$H = (bytes) => {
        if (bytes.length !== maxSize$t) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$G = () => toBytes$2g(id$F);

    const id$E = setOperatorParametersExtended3$1;
    commandNames[setOperatorParametersExtended3$1];
    const maxSize$s = 0;
    const fromBytes$G = (bytes) => {
        if (bytes.length !== maxSize$s) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$F = () => toBytes$2g(id$E);

    const id$D = setOperatorParameters$1;
    commandNames[setOperatorParameters$1];
    const maxSize$r = 0;
    const fromBytes$F = (bytes) => {
        if (bytes.length !== maxSize$r) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$E = () => toBytes$2g(id$D);

    const id$C = setSaldo$1;
    commandNames[setSaldo$1];
    const maxSize$q = 0;
    const fromBytes$E = (bytes) => {
        if (bytes.length !== maxSize$q) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$D = () => toBytes$2g(id$C);

    const id$B = setSaldoParameters$1;
    commandNames[setSaldoParameters$1];
    const maxSize$p = 0;
    const fromBytes$D = (bytes) => {
        if (bytes.length !== maxSize$p) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$C = () => toBytes$2g(id$B);

    const id$A = setSeasonProfile$1;
    commandNames[setSeasonProfile$1];
    const maxSize$o = 0;
    const fromBytes$C = (bytes) => {
        if (bytes.length !== maxSize$o) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$B = () => toBytes$2g(id$A);

    const id$z = setSpecialDay$1;
    commandNames[setSpecialDay$1];
    const maxSize$n = 0;
    const fromBytes$B = (bytes) => {
        if (bytes.length !== maxSize$n) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$A = () => toBytes$2g(id$z);

    const id$y = setSpecialOperation$1;
    commandNames[setSpecialOperation$1];
    const maxSize$m = 1;
    const fromBytes$A = (bytes) => {
        const buffer = new CommandBinaryBuffer$2(bytes);
        const flags = buffer.getUint8();
        const electroMagneticIndication = !!(flags & 1);
        const magneticIndication = !!(flags & 2);
        return {
            electroMagneticIndication,
            magneticIndication
        };
    };
    const toBytes$z = (parameters) => {
        const buffer = new CommandBinaryBuffer$2(maxSize$m);
        let flags = 0;
        if (parameters.electroMagneticIndication) {
            flags |= 1;
        }
        if (parameters.magneticIndication) {
            flags |= 2;
        }
        buffer.setUint8(flags);
        return toBytes$2g(id$y, buffer.data);
    };

    const id$x = turnRelayOff$1;
    commandNames[turnRelayOff$1];
    const maxSize$l = 0;
    const fromBytes$z = (bytes) => {
        if (bytes.length !== maxSize$l) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$y = () => toBytes$2g(id$x);

    const id$w = turnRelayOn$1;
    commandNames[turnRelayOn$1];
    const maxSize$k = 0;
    const fromBytes$y = (bytes) => {
        if (bytes.length !== maxSize$k) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$x = () => toBytes$2g(id$w);

    const { id: id$v, toBytes: toBytes$w } = mtx1;
    const fromBytes$x = getFromBytes$1(uplinkNames);

    const id$u = getCriticalEvent;
    uplinkNames[getCriticalEvent];
    const maxSize$j = 9;
    const fromBytes$w = (bytes) => {
        if (bytes.length !== maxSize$j) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        const [event, index, year, month, date, hours, minutes, seconds, count] = bytes;
        return {
            event,
            index,
            date: {
                year,
                month,
                date,
                hours,
                minutes,
                seconds
            },
            count
        };
    };
    const toBytes$v = (parameters) => {
        const { event, index, date, count } = parameters;
        return toBytes$2g(id$u, [
            event,
            index,
            date.year,
            date.month,
            date.date,
            date.hours,
            date.minutes,
            date.seconds,
            count
        ]);
    };

    const id$t = getCurrentStatusMeter;
    uplinkNames[getCurrentStatusMeter];
    const maxSize$i = 41;
    const fromBytes$v = (data) => {
        const buffer = new CommandBinaryBuffer(data);
        const operatingSeconds = buffer.getUint32();
        const tbadVAAll = buffer.getUint32();
        const tbadVBAll = buffer.getUint32();
        const tbadVCAll = buffer.getUint32();
        const tbadIMAXAll = buffer.getUint32();
        const tbadPMAXAll = buffer.getUint32();
        buffer.getUint32();
        const tbadFREQ = buffer.getUint32();
        const relayStatus = !!(buffer.getUint8() & 1);
        const statusEvent1 = buffer.getUint8();
        const centerAlert = !!(buffer.getUint8() & 1);
        const calEnableFlag = !!(buffer.getUint8() & 1);
        const currentTariffs = {
            'A+': buffer.getUint8(),
            maximumPowers: buffer.getUint8(),
            'A-': buffer.getUint8()
        };
        const statusEvent2 = buffer.getUint8();
        const isSummerTime = !!(buffer.getUint8() & 1);
        const statusEventValue = statusEvent1 | (statusEvent2 << 8);
        return {
            operatingSeconds,
            tbadVAAll,
            tbadVBAll,
            tbadVCAll,
            tbadIMAXAll,
            tbadPMAXAll,
            tbadFREQ,
            relayStatus,
            statusEvent: toObject(eventStatusMask, statusEventValue),
            centerAlert,
            calEnableFlag,
            currentTariffs,
            isSummerTime
        };
    };
    const toBytes$u = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$i);
        const statusEventValue = fromObject(eventStatusMask, parameters.statusEvent);
        buffer.setUint32(parameters.operatingSeconds);
        buffer.setUint32(parameters.tbadVAAll);
        buffer.setUint32(parameters.tbadVBAll);
        buffer.setUint32(parameters.tbadVCAll);
        buffer.setUint32(parameters.tbadIMAXAll);
        buffer.setUint32(parameters.tbadPMAXAll);
        buffer.setUint32(0);
        buffer.setUint32(parameters.tbadFREQ);
        buffer.setUint8(parameters.relayStatus ? 1 : 0);
        buffer.setUint8(statusEventValue & 0xff);
        buffer.setUint8(parameters.centerAlert ? 1 : 0);
        buffer.setUint8(parameters.calEnableFlag ? 1 : 0);
        buffer.setUint8(parameters.currentTariffs['A+']);
        buffer.setUint8(parameters.currentTariffs.maximumPowers);
        buffer.setUint8(parameters.currentTariffs['A-']);
        buffer.setUint8((statusEventValue >> 8) & 0xff);
        buffer.setUint8(parameters.isSummerTime ? 1 : 0);
        return toBytes$2g(id$t, buffer.data);
    };

    const id$s = getCurrentValues;
    uplinkNames[getCurrentValues];
    const maxSize$h = 52;
    const fromBytes$u = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return {
            vaRms: buffer.getInt32(),
            vbRms: buffer.getInt32(),
            vcRms: buffer.getInt32(),
            iaRms: buffer.getInt32(),
            ibRms: buffer.getInt32(),
            icRms: buffer.getInt32(),
            powerA: buffer.getInt32(),
            powerB: buffer.getInt32(),
            powerC: buffer.getInt32(),
            varA: buffer.getInt32(),
            varB: buffer.getInt32(),
            varC: buffer.getInt32(),
            iNeutral: buffer.getInt32()
        };
    };
    const toBytes$t = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$h);
        buffer.setInt32(parameters.vaRms);
        buffer.setInt32(parameters.vbRms);
        buffer.setInt32(parameters.vcRms);
        buffer.setInt32(parameters.iaRms);
        buffer.setInt32(parameters.ibRms);
        buffer.setInt32(parameters.icRms);
        buffer.setInt32(parameters.powerA);
        buffer.setInt32(parameters.powerB);
        buffer.setInt32(parameters.powerC);
        buffer.setInt32(parameters.varA);
        buffer.setInt32(parameters.varB);
        buffer.setInt32(parameters.varC);
        buffer.setInt32(parameters.iNeutral);
        return toBytes$2g(id$s, buffer.data);
    };

    const COMMAND_SIZE$1 = 51;
    const id$r = getDayDemand;
    uplinkNames[getDayDemand];
    const fromBytes$t = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        let parameters;
        if (bytes.length === COMMAND_SIZE$1) {
            parameters = {
                date: buffer.getDate(),
                energies: buffer.getEnergies()
            };
        }
        else {
            parameters = {
                date: buffer.getDate(),
                ...buffer.getPackedEnergyWithType()
            };
        }
        return parameters;
    };
    const toBytes$s = (parameters) => {
        const buffer = new CommandBinaryBuffer(getPackedEnergiesWithDateSize(parameters));
        buffer.setDate(parameters.date);
        buffer.setPackedEnergyWithType(parameters);
        return toBytes$2g(id$r, buffer.data);
    };

    const id$q = getDayDemandExport;
    uplinkNames[getDayDemandExport];
    const maxSize$g = 51;
    const fromBytes$s = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return {
            date: buffer.getDate(),
            energies: buffer.getEnergies()
        };
    };
    const toBytes$r = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$g);
        buffer.setDate(parameters.date);
        buffer.setEnergies(parameters.energies);
        return toBytes$2g(id$q, buffer.data);
    };

    const id$p = getDayMaxDemand;
    uplinkNames[getDayMaxDemand];
    const maxSize$f = 75;
    const fromBytes$r = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getDayMaxDemandResponse();
    };
    const toBytes$q = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$f);
        buffer.setDayMaxDemandResponse(parameters);
        return toBytes$2g(id$p, buffer.getBytesToOffset());
    };

    const id$o = getDayMaxDemandExport;
    uplinkNames[getDayMaxDemandExport];
    const maxSize$e = 75;
    const fromBytes$q = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getDayMaxDemandResponse();
    };
    const toBytes$p = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$e);
        buffer.setDayMaxDemandResponse(parameters);
        return toBytes$2g(id$o, buffer.getBytesToOffset());
    };

    const id$n = getDemand;
    uplinkNames[getDemand];
    const fromBytes$p = (bytes) => {
        if (!bytes || bytes.length < maxSize$18) {
            throw new Error('Invalid uplink GetDemand byte length.');
        }
        const buffer = new CommandBinaryBuffer(bytes);
        const parameters = buffer.getDemand();
        if (bytes.length !== maxSize$18 + (2 * parameters.count)) {
            throw new Error('Invalid uplink GetDemand demands byte length.');
        }
        const demands = new Array(parameters.count).fill(0).map(() => buffer.getUint16());
        return {
            ...parameters,
            demands
        };
    };
    const toBytes$o = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$18 + parameters.count * 2);
        buffer.setDemand(parameters);
        parameters.demands.forEach(value => buffer.setUint16(value));
        return toBytes$2g(id$n, buffer.data);
    };

    const id$m = getDisplayParam;
    uplinkNames[getDisplayParam];
    const fromBytes$o = (bytes) => {
        const [displayMode, ...order] = bytes;
        return { displayMode, order };
    };
    const toBytes$n = (parameters) => (toBytes$2g(id$m, [parameters.displayMode, ...parameters.order]));

    const id$l = getEnergy;
    uplinkNames[getEnergy];
    const maxSize$d = 48;
    const fromBytes$n = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getEnergies();
    };
    const toBytes$m = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$d);
        buffer.setEnergies(parameters);
        return toBytes$2g(id$l, buffer.data);
    };

    const COMMAND_SIZE = 51;
    const id$k = getEnergyDayPrevious;
    uplinkNames[getEnergyDayPrevious];
    const fromBytes$m = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        let parameters;
        if (bytes.length === COMMAND_SIZE) {
            parameters = {
                date: buffer.getDate(),
                energies: buffer.getEnergies()
            };
        }
        else {
            parameters = {
                date: buffer.getDate(),
                ...buffer.getPackedEnergyWithType()
            };
        }
        return parameters;
    };
    const toBytes$l = (parameters) => {
        const buffer = new CommandBinaryBuffer(getPackedEnergiesWithDateSize(parameters));
        buffer.setDate(parameters.date);
        buffer.setPackedEnergyWithType(parameters);
        return toBytes$2g(id$k, buffer.data);
    };

    const id$j = getEnergyExport;
    uplinkNames[getEnergyExport];
    const maxSize$c = 48;
    const fromBytes$l = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getEnergies();
    };
    const toBytes$k = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$c);
        buffer.setEnergies(parameters);
        return toBytes$2g(id$j, buffer.data);
    };

    const id$i = getEnergyExportDayPrevious;
    uplinkNames[getEnergyExportDayPrevious];
    const maxSize$b = 48;
    const fromBytes$k = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getEnergies();
    };
    const toBytes$j = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$b);
        buffer.setEnergies(parameters);
        return toBytes$2g(id$i, buffer.data);
    };

    const id$h = getExtendedCurrentValues;
    uplinkNames[getExtendedCurrentValues];
    const maxSize$a = 38;
    const fromBytes$j = (data) => {
        const buffer = new CommandBinaryBuffer(data);
        return {
            temperature: buffer.getInt16(),
            frequency: buffer.getUint16(),
            vPhaseAB: buffer.getInt32(),
            vPhaseAC: buffer.getInt32(),
            pfA: buffer.getInt16() / 1000,
            pfB: buffer.getInt16() / 1000,
            pfC: buffer.getInt16() / 1000,
            pf: buffer.getInt16() / 1000,
            vaA: buffer.getInt32(),
            vaB: buffer.getInt32(),
            vaC: buffer.getInt32(),
            vaSum: buffer.getInt32(),
            uBatteryRtc: buffer.getInt16()
        };
    };
    const toBytes$i = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$a);
        buffer.setInt16(parameters.temperature);
        buffer.setUint16(parameters.frequency);
        buffer.setInt32(parameters.vPhaseAB);
        buffer.setInt32(parameters.vPhaseAC);
        buffer.setInt16(parameters.pfA * 1000);
        buffer.setInt16(parameters.pfB * 1000);
        buffer.setInt16(parameters.pfC * 1000);
        buffer.setInt16(parameters.pf * 1000);
        buffer.setInt32(parameters.vaA);
        buffer.setInt32(parameters.vaB);
        buffer.setInt32(parameters.vaC);
        buffer.setInt32(parameters.vaSum);
        buffer.setInt16(parameters.uBatteryRtc);
        return toBytes$2g(id$h, buffer.data);
    };

    const id$g = getHalfHourDemand;
    uplinkNames[getHalfHourDemand];
    const fromBytes$i = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        const hasDst = bytes.length > MIN_HALF_HOUR_COMMAND_SIZE;
        const date = buffer.getDate();
        const energies = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
        if (hasDst) {
            return {
                date,
                energies,
                dstHour: buffer.getUint8()
            };
        }
        return { date, energies };
    };
    const toBytes$h = (parameters) => {
        const size = parameters.energies.length > MIN_HALF_HOUR_PERIODS ? MAX_HALF_HOUR_COMMAND_SIZE : MIN_HALF_HOUR_COMMAND_SIZE;
        const buffer = new CommandBinaryBuffer(size);
        buffer.setDate(parameters.date);
        buffer.setEnergyPeriods(parameters.energies);
        if (parameters.dstHour) {
            buffer.setUint8(parameters.dstHour);
        }
        return toBytes$2g(id$g, buffer.data);
    };

    const MIN_COMMAND_SIZE = MIN_HALF_HOUR_COMMAND_SIZE + 2;
    const MAX_COMMAND_SIZE = MAX_HALF_HOUR_COMMAND_SIZE + 2;
    const id$f = getHalfHourDemandChannel;
    uplinkNames[getHalfHourDemandChannel];
    const fromBytes$h = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        const hasDst = bytes.length > MIN_COMMAND_SIZE;
        const channel = buffer.getUint8();
        const channelParameter = buffer.getUint8();
        const date = buffer.getDate();
        const energies = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
        if (hasDst) {
            return {
                channel,
                channelParameter,
                date,
                energies,
                dstHour: buffer.getUint8()
            };
        }
        return {
            channel,
            channelParameter,
            date,
            energies
        };
    };
    const toBytes$g = (parameters) => {
        const size = parameters.energies.length > MIN_HALF_HOUR_PERIODS ? MAX_COMMAND_SIZE : MIN_COMMAND_SIZE;
        const buffer = new CommandBinaryBuffer(size);
        buffer.setUint8(parameters.channel);
        buffer.setUint8(parameters.channelParameter);
        buffer.setDate(parameters.date);
        buffer.setEnergyPeriods(parameters.energies);
        if (parameters.dstHour) {
            buffer.setUint8(parameters.dstHour);
        }
        return toBytes$2g(id$f, buffer.data);
    };

    const id$e = getHalfHourDemandExport;
    uplinkNames[getHalfHourDemandExport];
    const fromBytes$g = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        const hasDst = bytes.length > MIN_HALF_HOUR_COMMAND_SIZE;
        const date = buffer.getDate();
        const energies = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
        if (hasDst) {
            return {
                date,
                energies,
                dstHour: buffer.getUint8()
            };
        }
        return { date, energies };
    };
    const toBytes$f = (parameters) => {
        const size = parameters.energies.length > MIN_HALF_HOUR_PERIODS ? MAX_HALF_HOUR_COMMAND_SIZE : MIN_HALF_HOUR_COMMAND_SIZE;
        const buffer = new CommandBinaryBuffer(size);
        buffer.setDate(parameters.date);
        buffer.setEnergyPeriods(parameters.energies);
        if (parameters.dstHour) {
            buffer.setUint8(parameters.dstHour);
        }
        return toBytes$2g(id$e, buffer.data);
    };

    const id$d = getHalfHourDemandVare;
    uplinkNames[getHalfHourDemandVare];
    const fromBytes$f = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        const hasDst = bytes.length > MIN_HALF_HOUR_COMMAND_SIZE;
        const date = buffer.getDate();
        const energies = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
        if (hasDst) {
            return {
                date,
                energies,
                dstHour: buffer.getUint8()
            };
        }
        return { date, energies };
    };
    const toBytes$e = (parameters) => {
        const size = parameters.energies.length > MIN_HALF_HOUR_PERIODS ? MAX_HALF_HOUR_COMMAND_SIZE : MIN_HALF_HOUR_COMMAND_SIZE;
        const buffer = new CommandBinaryBuffer(size);
        buffer.setDate(parameters.date);
        buffer.setEnergyPeriods(parameters.energies);
        if (parameters.dstHour) {
            buffer.setUint8(parameters.dstHour);
        }
        return toBytes$2g(id$d, buffer.data);
    };

    const id$c = getHalfHourDemandVareExport;
    uplinkNames[getHalfHourDemandVareExport];
    const fromBytes$e = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        const hasDst = bytes.length > MIN_HALF_HOUR_COMMAND_SIZE;
        const date = buffer.getDate();
        const energies = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
        if (hasDst) {
            return {
                date,
                energies,
                dstHour: buffer.getUint8()
            };
        }
        return { date, energies };
    };
    const toBytes$d = (parameters) => {
        const size = parameters.energies.length > MIN_HALF_HOUR_PERIODS ? MAX_HALF_HOUR_COMMAND_SIZE : MIN_HALF_HOUR_COMMAND_SIZE;
        const buffer = new CommandBinaryBuffer(size);
        buffer.setDate(parameters.date);
        buffer.setEnergyPeriods(parameters.energies);
        if (parameters.dstHour) {
            buffer.setUint8(parameters.dstHour);
        }
        return toBytes$2g(id$c, buffer.data);
    };

    const id$b = getHalfHourDemandVari;
    uplinkNames[getHalfHourDemandVari];
    const fromBytes$d = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        const hasDst = bytes.length > MIN_HALF_HOUR_COMMAND_SIZE;
        const date = buffer.getDate();
        const energies = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
        if (hasDst) {
            return {
                date,
                energies,
                dstHour: buffer.getUint8()
            };
        }
        return { date, energies };
    };
    const toBytes$c = (parameters) => {
        const size = parameters.energies.length > MIN_HALF_HOUR_PERIODS ? MAX_HALF_HOUR_COMMAND_SIZE : MIN_HALF_HOUR_COMMAND_SIZE;
        const buffer = new CommandBinaryBuffer(size);
        buffer.setDate(parameters.date);
        buffer.setEnergyPeriods(parameters.energies);
        if (parameters.dstHour) {
            buffer.setUint8(parameters.dstHour);
        }
        return toBytes$2g(id$b, buffer.data);
    };

    const id$a = getHalfHourDemandVariExport;
    uplinkNames[getHalfHourDemandVariExport];
    const fromBytes$c = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        const hasDst = bytes.length > MIN_HALF_HOUR_COMMAND_SIZE;
        const date = buffer.getDate();
        const energies = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
        if (hasDst) {
            return {
                date,
                energies,
                dstHour: buffer.getUint8()
            };
        }
        return { date, energies };
    };
    const toBytes$b = (parameters) => {
        const size = parameters.energies.length > MIN_HALF_HOUR_PERIODS ? MAX_HALF_HOUR_COMMAND_SIZE : MIN_HALF_HOUR_COMMAND_SIZE;
        const buffer = new CommandBinaryBuffer(size);
        buffer.setDate(parameters.date);
        buffer.setEnergyPeriods(parameters.energies);
        if (parameters.dstHour) {
            buffer.setUint8(parameters.dstHour);
        }
        return toBytes$2g(id$a, buffer.data);
    };

    const id$9 = getMonthDemand;
    uplinkNames[getMonthDemand];
    const maxSize$9 = 50;
    const fromBytes$b = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return {
            year: buffer.getUint8(),
            month: buffer.getUint8(),
            energies: buffer.getEnergies()
        };
    };
    const toBytes$a = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$9);
        buffer.setUint8(parameters.year);
        buffer.setUint8(parameters.month);
        buffer.setEnergies(parameters.energies);
        return toBytes$2g(id$9, buffer.data);
    };

    const id$8 = getMonthDemandExport;
    uplinkNames[getMonthDemandExport];
    const maxSize$8 = 50;
    const fromBytes$a = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return {
            year: buffer.getUint8(),
            month: buffer.getUint8(),
            energies: buffer.getEnergies()
        };
    };
    const toBytes$9 = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$8);
        buffer.setUint8(parameters.year);
        buffer.setUint8(parameters.month);
        buffer.setEnergies(parameters.energies);
        return toBytes$2g(id$8, buffer.data);
    };

    const id$7 = getMonthMaxDemand;
    uplinkNames[getMonthMaxDemand];
    const maxSize$7 = 74;
    const fromBytes$9 = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getMonthMaxDemandResponse();
    };
    const toBytes$8 = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$7);
        buffer.setMonthMaxDemandResponse(parameters);
        return toBytes$2g(id$7, buffer.getBytesToOffset());
    };

    const id$6 = getMonthMaxDemandExport;
    uplinkNames[getMonthMaxDemandExport];
    const maxSize$6 = 74;
    const fromBytes$8 = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getMonthMaxDemandResponse();
    };
    const toBytes$7 = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$6);
        buffer.setMonthMaxDemandResponse(parameters);
        return toBytes$2g(id$6, buffer.getBytesToOffset());
    };

    const id$5 = getOperatorParameters;
    uplinkNames[getOperatorParameters];
    const maxSize$5 = OPERATOR_PARAMETERS_SIZE;
    const fromBytes$7 = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getOperatorParameters();
    };
    const toBytes$6 = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$5);
        buffer.setOperatorParameters(parameters);
        return toBytes$2g(id$5, buffer.data);
    };

    const id$4 = getOperatorParametersExtended;
    uplinkNames[getOperatorParametersExtended];
    const maxSize$4 = OPERATOR_PARAMETERS_EXTENDED_SIZE;
    const fromBytes$6 = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getOperatorParametersExtended();
    };
    const toBytes$5 = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$4);
        buffer.setOperatorParametersExtended(parameters);
        return toBytes$2g(id$4, buffer.data);
    };

    const id$3 = getOperatorParametersExtended2;
    uplinkNames[getOperatorParametersExtended2];
    const maxSize$3 = OPERATOR_PARAMETERS_EXTENDED2_SIZE;
    const fromBytes$5 = (bytes) => {
        const buffer = new CommandBinaryBuffer(bytes);
        return buffer.getOperatorParametersExtended2();
    };
    const toBytes$4 = (parameters) => {
        const buffer = new CommandBinaryBuffer(maxSize$3);
        buffer.setOperatorParametersExtended2(parameters);
        return toBytes$2g(id$3, buffer.data);
    };

    const id$2 = setOperatorParametersExtended;
    uplinkNames[setOperatorParametersExtended];
    const maxSize$2 = 0;
    const fromBytes$4 = (bytes) => {
        if (bytes.length !== maxSize$2) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$3 = () => toBytes$2g(id$2);

    const id$1 = setOperatorParametersExtended2;
    uplinkNames[setOperatorParametersExtended2];
    const maxSize$1 = 0;
    const fromBytes$3 = (bytes) => {
        if (bytes.length !== maxSize$1) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$2 = () => toBytes$2g(id$1);

    const id = setOperatorParametersExtended4;
    uplinkNames[setOperatorParametersExtended4];
    const maxSize = 0;
    const fromBytes$2 = (bytes) => {
        if (bytes.length !== maxSize) {
            throw new Error(`Wrong buffer size: ${bytes.length}.`);
        }
        return {};
    };
    const toBytes$1 = () => toBytes$2g(id);

    const toBytesMap = {};
    const fromBytesMap = {};
    const nameMap = uplinkNames;
    const fromBytes$1 = getFromBytes$2(fromBytesMap, nameMap);
    toBytesMap[id$17] = toBytes$18;
    toBytesMap[id$15] = toBytes$16;
    toBytesMap[id$14] = toBytes$15;
    toBytesMap[id$13] = toBytes$14;
    toBytesMap[id$12] = toBytes$13;
    toBytesMap[id$11] = toBytes$12;
    toBytesMap[id$10] = toBytes$11;
    toBytesMap[id$] = toBytes$10;
    toBytesMap[id$_] = toBytes$;
    toBytesMap[id$Z] = toBytes$_;
    toBytesMap[id$Y] = toBytes$Z;
    toBytesMap[id$X] = toBytes$Y;
    toBytesMap[id$W] = toBytes$X;
    toBytesMap[id$V] = toBytes$W;
    toBytesMap[id$U] = toBytes$V;
    toBytesMap[id$T] = toBytes$U;
    toBytesMap[id$S] = toBytes$T;
    toBytesMap[id$R] = toBytes$S;
    toBytesMap[id$Q] = toBytes$R;
    toBytesMap[id$P] = toBytes$Q;
    toBytesMap[id$O] = toBytes$P;
    toBytesMap[id$N] = toBytes$O;
    toBytesMap[id$M] = toBytes$N;
    toBytesMap[id$L] = toBytes$M;
    toBytesMap[id$K] = toBytes$L;
    toBytesMap[id$J] = toBytes$K;
    toBytesMap[id$I] = toBytes$J;
    toBytesMap[id$H] = toBytes$I;
    toBytesMap[id$G] = toBytes$H;
    toBytesMap[id$F] = toBytes$G;
    toBytesMap[id$D] = toBytes$E;
    toBytesMap[id$E] = toBytes$F;
    toBytesMap[id$C] = toBytes$D;
    toBytesMap[id$B] = toBytes$C;
    toBytesMap[id$A] = toBytes$B;
    toBytesMap[id$z] = toBytes$A;
    toBytesMap[id$y] = toBytes$z;
    toBytesMap[id$x] = toBytes$y;
    toBytesMap[id$w] = toBytes$x;
    toBytesMap[id$v] = toBytes$w;
    toBytesMap[id$u] = toBytes$v;
    toBytesMap[id$t] = toBytes$u;
    toBytesMap[id$s] = toBytes$t;
    toBytesMap[id$r] = toBytes$s;
    toBytesMap[id$q] = toBytes$r;
    toBytesMap[id$p] = toBytes$q;
    toBytesMap[id$o] = toBytes$p;
    toBytesMap[id$n] = toBytes$o;
    toBytesMap[id$m] = toBytes$n;
    toBytesMap[id$l] = toBytes$m;
    toBytesMap[id$k] = toBytes$l;
    toBytesMap[id$j] = toBytes$k;
    toBytesMap[id$i] = toBytes$j;
    toBytesMap[id$h] = toBytes$i;
    toBytesMap[id$g] = toBytes$h;
    toBytesMap[id$f] = toBytes$g;
    toBytesMap[id$e] = toBytes$f;
    toBytesMap[id$d] = toBytes$e;
    toBytesMap[id$c] = toBytes$d;
    toBytesMap[id$b] = toBytes$c;
    toBytesMap[id$a] = toBytes$b;
    toBytesMap[id$9] = toBytes$a;
    toBytesMap[id$8] = toBytes$9;
    toBytesMap[id$7] = toBytes$8;
    toBytesMap[id$6] = toBytes$7;
    toBytesMap[id$5] = toBytes$6;
    toBytesMap[id$4] = toBytes$5;
    toBytesMap[id$3] = toBytes$4;
    toBytesMap[id$D] = toBytes$E;
    toBytesMap[id$2] = toBytes$3;
    toBytesMap[id$1] = toBytes$2;
    toBytesMap[id] = toBytes$1;
    fromBytesMap[id$17] = fromBytes$19;
    fromBytesMap[id$15] = fromBytes$17;
    fromBytesMap[id$14] = fromBytes$16;
    fromBytesMap[id$13] = fromBytes$15;
    fromBytesMap[id$12] = fromBytes$14;
    fromBytesMap[id$11] = fromBytes$13;
    fromBytesMap[id$10] = fromBytes$12;
    fromBytesMap[id$] = fromBytes$11;
    fromBytesMap[id$_] = fromBytes$10;
    fromBytesMap[id$Z] = fromBytes$;
    fromBytesMap[id$Y] = fromBytes$_;
    fromBytesMap[id$X] = fromBytes$Z;
    fromBytesMap[id$W] = fromBytes$Y;
    fromBytesMap[id$V] = fromBytes$X;
    fromBytesMap[id$U] = fromBytes$W;
    fromBytesMap[id$T] = fromBytes$V;
    fromBytesMap[id$S] = fromBytes$U;
    fromBytesMap[id$R] = fromBytes$T;
    fromBytesMap[id$Q] = fromBytes$S;
    fromBytesMap[id$P] = fromBytes$R;
    fromBytesMap[id$O] = fromBytes$Q;
    fromBytesMap[id$N] = fromBytes$P;
    fromBytesMap[id$M] = fromBytes$O;
    fromBytesMap[id$L] = fromBytes$N;
    fromBytesMap[id$K] = fromBytes$M;
    fromBytesMap[id$J] = fromBytes$L;
    fromBytesMap[id$I] = fromBytes$K;
    fromBytesMap[id$H] = fromBytes$J;
    fromBytesMap[id$G] = fromBytes$I;
    fromBytesMap[id$F] = fromBytes$H;
    fromBytesMap[id$D] = fromBytes$F;
    fromBytesMap[id$E] = fromBytes$G;
    fromBytesMap[id$C] = fromBytes$E;
    fromBytesMap[id$B] = fromBytes$D;
    fromBytesMap[id$A] = fromBytes$C;
    fromBytesMap[id$z] = fromBytes$B;
    fromBytesMap[id$y] = fromBytes$A;
    fromBytesMap[id$x] = fromBytes$z;
    fromBytesMap[id$w] = fromBytes$y;
    fromBytesMap[id$v] = fromBytes$x;
    fromBytesMap[id$u] = fromBytes$w;
    fromBytesMap[id$t] = fromBytes$v;
    fromBytesMap[id$s] = fromBytes$u;
    fromBytesMap[id$r] = fromBytes$t;
    fromBytesMap[id$q] = fromBytes$s;
    fromBytesMap[id$p] = fromBytes$r;
    fromBytesMap[id$o] = fromBytes$q;
    fromBytesMap[id$n] = fromBytes$p;
    fromBytesMap[id$m] = fromBytes$o;
    fromBytesMap[id$l] = fromBytes$n;
    fromBytesMap[id$k] = fromBytes$m;
    fromBytesMap[id$j] = fromBytes$l;
    fromBytesMap[id$i] = fromBytes$k;
    fromBytesMap[id$h] = fromBytes$j;
    fromBytesMap[id$g] = fromBytes$i;
    fromBytesMap[id$f] = fromBytes$h;
    fromBytesMap[id$e] = fromBytes$g;
    fromBytesMap[id$d] = fromBytes$f;
    fromBytesMap[id$c] = fromBytes$e;
    fromBytesMap[id$b] = fromBytes$d;
    fromBytesMap[id$a] = fromBytes$c;
    fromBytesMap[id$9] = fromBytes$b;
    fromBytesMap[id$8] = fromBytes$a;
    fromBytesMap[id$7] = fromBytes$9;
    fromBytesMap[id$6] = fromBytes$8;
    fromBytesMap[id$5] = fromBytes$7;
    fromBytesMap[id$4] = fromBytes$6;
    fromBytesMap[id$3] = fromBytes$5;
    fromBytesMap[id$D] = fromBytes$F;
    fromBytesMap[id$2] = fromBytes$4;
    fromBytesMap[id$1] = fromBytes$3;
    fromBytesMap[id] = fromBytes$2;

    /**
     * Data segment wrapper around an MTX message.
     */



    // 0b10010001 (segmentIndex: 1, segmentsNumber: 1, isLast: true)
    const SINGLE_SEGMENT_FLAG = 0x91;

    const DATA_SEGMENT_COMMAND_ID = 0x1e;


    const get = ( bytes ) => {
        // check if it is a DataSegment command
        if ( bytes[0] !== DATA_SEGMENT_COMMAND_ID ) {
            return {};
        }

        // DataSegment command size
        const size = bytes[1];

        // segment metadata
        const flag = bytes[3];

        // payload
        const data = bytes.slice(4, size + 2);

        const expectedLrc = calculateLrc(bytes.slice(0, size + 2));
        const actualLrc = bytes[size + 2];

        // just a single data segment with correct lrc
        if ( flag === SINGLE_SEGMENT_FLAG && expectedLrc === actualLrc ) {
            return data;
        }

        return null;
    };

    const set = ( bytes ) => {
        const body = [
            DATA_SEGMENT_COMMAND_ID,
            bytes.length + 2,
            0,
            SINGLE_SEGMENT_FLAG,
            ...bytes
        ];

        return [...body, calculateLrc(body)];
    };

    // export
    fromBytes = fromBytes$1;
    toBytes = toBytes$19;
    getDataSegment = get;
    setDataSegment = set;

})();
//#endregion
