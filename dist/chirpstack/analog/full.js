// these options can be edited
// available hardware types can be found here:
// https://github.com/jooby-dev/jooby-docs/blob/main/docs/analog/basics.md#hardware-types
var config = {
    hardwareType: 0
};


//#region [autogenerated jooby-codec bundle]
var fromBytes, toBytes;

(function () {
    'use strict';

    // https://gist.github.com/addyosmani/d5648c89420eb333904c
    Array.prototype.fill = Array.prototype.fill || function (value) {
      var obj = Object(this);
      var len = parseInt(obj.length, 10);
      var start = arguments[1];
      var relativeStart = parseInt(start, 10) || 0;
      var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
      var end = arguments[2];
      var relativeEnd = end === undefined ? len : parseInt(end) || 0;
      var _final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
      for (; k < _final; k++) {
        obj[k] = value;
      }
      return obj;
    };

    // https://github.com/jsPolyfill/Array.prototype.find
    Array.prototype.find = Array.prototype.find || function (callback) {
      if (this === null) {
        throw new TypeError('Array.prototype.find called on null or undefined');
      } else if (typeof callback !== 'function') {
        throw new TypeError('callback must be a function');
      }
      var list = Object(this);

      // always has an positive integer as length
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      for (var i = 0; i < length; i++) {
        var element = list[i];
        if (callback.call(thisArg, element, i, list)) {
          return element;
        }
      }
    };

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    if (typeof Object.assign !== 'function') {
      Object.assign = function (target) {
        if (target === undefined || target === null) {
          throw new TypeError('Cannot convert undefined or null to object');
        }
        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
          var source = arguments[index];
          if (source !== undefined && source !== null) {
            for (var nextKey in source) {
              if (source.hasOwnProperty(nextKey)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
        }
        return output;
      };
    }

    // https://github.com/KhaledElAnsari/String.prototype.padStart
    String.prototype.padStart = String.prototype.padStart || function (targetLength, padString) {
      targetLength = Math.floor(targetLength) || 0;
      if (targetLength < this.length) {
        return String(this);
      }
      padString = padString ? String(padString) : ' ';
      var pad = '';
      var len = targetLength - this.length;
      var i = 0;
      while (pad.length < len) {
        if (!padString[i]) {
          i = 0;
        }
        pad += padString[i];
        i++;
      }
      return pad + String(this).slice(0);
    };

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var hexFormatOptions = {
      separator: ' ',
      prefix: ''
    };

    var INT8_SIZE = 1;
    var INT16_SIZE = 2;
    var INT32_SIZE = 4;
    var log = Math.log,
      pow = Math.pow,
      LN2 = Math.LN2;
    var readFloat = function readFloat(buffer, offset, isLittleEndian, mLen, bytes) {
      var e,
        m,
        eLen = bytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        nBits = -7,
        i = isLittleEndian ? bytes - 1 : 0,
        d = isLittleEndian ? -1 : 1,
        s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 0x100 + buffer[offset + i], i += d, nBits -= 8);
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 0x100 + buffer[offset + i], i += d, nBits -= 8);
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : s ? -Infinity : Infinity;
      } else {
        m = m + pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * pow(2, e - mLen);
    };
    var writeFloat = function writeFloat(buffer, offset, value, isLittleEndian, mLen, bytes) {
      var e,
        m,
        c,
        eLen = bytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0,
        i = isLittleEndian ? 0 : bytes - 1,
        d = isLittleEndian ? 1 : -1,
        s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value < 0 && (value = -value);
      if (value !== value || value === Infinity) {
        m = value !== value ? 1 : 0;
        e = eMax;
      } else {
        e = log(value) / LN2 | 0;
        if (value * (c = pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * pow(2, eBias - 1) * pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 0x100, mLen -= 8);
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 0x100, eLen -= 8);
      buffer[offset + i - d] |= s * 0x80;
    };
    var be2 = [1, 0];
    var be4 = [3, 2, 1, 0];
    var le2 = [0, 1];
    var le4 = [0, 1, 2, 3];
    var readUint8 = function readUint8(buffer, offset) {
      return buffer[offset];
    };
    var readUint16 = function readUint16(buffer, offset, isLittleEndian) {
      var order = isLittleEndian ? le2 : be2;
      var b0 = buffer[offset + order[0]];
      var b1 = buffer[offset + order[1]] << 8;
      return b0 | b1;
    };
    var readUint32 = function readUint32(buffer, offset, isLittleEndian) {
      var order = isLittleEndian ? le4 : be4;
      var b0 = buffer[offset + order[3]] * 0x1000000;
      var b1 = buffer[offset + order[2]] * 0x10000;
      var b2 = buffer[offset + order[1]] * 0x100;
      var b3 = buffer[offset + order[0]];
      return b0 + b1 + b2 + b3;
    };
    var writeUint8 = function writeUint8(buffer, offset, value) {
      buffer[offset] = value & 0xff;
    };
    var writeUint16 = function writeUint16(buffer, offset, value, isLittleEndian) {
      var order = isLittleEndian ? le2 : be2;
      buffer[offset + order[0]] = value & 0xff;
      buffer[offset + order[1]] = value >>> 8 & 0xff;
    };
    var writeUint32 = function writeUint32(buffer, offset, value, isLittleEndian) {
      var order = isLittleEndian ? le4 : be4;
      buffer[offset + order[0]] = value & 0xff;
      buffer[offset + order[1]] = value >>> 8 & 0xff;
      buffer[offset + order[2]] = value >>> 16 & 0xff;
      buffer[offset + order[3]] = value >>> 24 & 0xff;
    };
    function BinaryBuffer(dataOrLength) {
      var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (typeof dataOrLength === 'number') {
        var bytes = new Array(dataOrLength).fill(0);
        this.data = bytes;
      } else {
        this.data = dataOrLength;
      }
      this.offset = 0;
      this.isLittleEndian = isLittleEndian;
    }
    BinaryBuffer.prototype = {
      toUint8Array: function toUint8Array() {
        return this.data;
      },
      seek: function seek(position) {
        if (position < 0 || position >= this.data.length) {
          throw new Error('Invalid position.');
        }
        this.offset = position;
      },
      setInt8: function setInt8(value) {
        writeUint8(this.data, this.offset, value < 0 ? value | 0x100 : value);
        this.offset += INT8_SIZE;
      },
      getInt8: function getInt8() {
        var result = readUint8(this.data, this.offset);
        this.offset += INT8_SIZE;
        return result & 0x80 ? result ^ -0x100 : result;
      },
      setUint8: function setUint8(value) {
        writeUint8(this.data, this.offset, value);
        this.offset += INT8_SIZE;
      },
      getUint8: function getUint8() {
        var result = readUint8(this.data, this.offset);
        this.offset += INT8_SIZE;
        return result;
      },
      setInt16: function setInt16(value) {
        var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint16(this.data, this.offset, value < 0 ? value | 0x10000 : value, isLittleEndian);
        this.offset += INT16_SIZE;
      },
      getInt16: function getInt16() {
        var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        var result = readUint16(this.data, this.offset, isLittleEndian);
        this.offset += INT16_SIZE;
        return result & 0x8000 ? result ^ -0x10000 : result;
      },
      setUint16: function setUint16(value) {
        var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint16(this.data, this.offset, value, isLittleEndian);
        this.offset += INT16_SIZE;
      },
      getUint16: function getUint16() {
        var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        var result = readUint16(this.data, this.offset, isLittleEndian);
        this.offset += INT16_SIZE;
        return result;
      },
      setInt32: function setInt32(value) {
        var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint32(this.data, this.offset, value < 0 ? value | 0x100000000 : value, isLittleEndian);
        this.offset += INT32_SIZE;
      },
      getInt32: function getInt32() {
        var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        var result = readUint32(this.data, this.offset, isLittleEndian);
        this.offset += INT32_SIZE;
        return result & 0x80000000 ? result ^ -0x100000000 : result;
      },
      setUint32: function setUint32(value) {
        var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint32(this.data, this.offset, value, isLittleEndian);
        this.offset += INT32_SIZE;
      },
      getUint32: function getUint32() {
        var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        var result = readUint32(this.data, this.offset, isLittleEndian);
        this.offset += INT32_SIZE;
        return result;
      },
      setFloat32: function setFloat32(value) {
        var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeFloat(this.data, this.offset, value, isLittleEndian, 23, 4);
        this.offset += INT32_SIZE;
      },
      getFloat32: function getFloat32() {
        var isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        var result = readFloat(this.data, this.offset, isLittleEndian, 23, 4);
        this.offset += INT32_SIZE;
        return result;
      },
      setString: function setString(value) {
        this.setUint8(value.length);
        for (var index = 0; index < value.length; ++index) {
          this.setUint8(value.charCodeAt(index));
        }
      },
      getString: function getString() {
        var size = this.getUint8();
        var endIndex = this.offset + size;
        var chars = [];
        while (this.offset < endIndex) {
          chars.push(String.fromCharCode(this.getUint8()));
        }
        return chars.join('');
      },
      getBytesToOffset: function getBytesToOffset() {
        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.offset;
        return this.data.slice(0, offset);
      },
      getBytesLeft: function getBytesLeft() {
        return this.getBytes(this.bytesLeft);
      },
      getBytes: function getBytes(length) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;
        this.offset = offset + length;
        return this.data.slice(offset, this.offset);
      },
      setBytes: function setBytes(data) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;
        var bytes = this.data;
        bytes.splice.apply(bytes, [offset, data.length].concat(_toConsumableArray(data)));
        this.data = bytes;
        this.offset = offset + data.length;
      }
    };
    Object.defineProperties(BinaryBuffer.prototype, {
      size: {
        get: function get() {
          return this.data.length;
        }
      },
      isEmpty: {
        get: function get() {
          return this.data.length - this.offset === 0;
        }
      },
      bytesLeft: {
        get: function get() {
          return this.data.length - this.offset;
        }
      },
      position: {
        get: function get() {
          return this.offset;
        }
      }
    });

    var shortCommandMask = 0xe0;
    var extraCommandMask = 0x1f;
    var fromBytes$k = function fromBytes(data) {
      if (data.length === 0) {
        throw new Error('Invalid buffer size');
      }
      var header = {
        shortCode: data[0] & shortCommandMask,
        extraCode: data[0] & extraCommandMask
      };
      if (header.shortCode !== 0) {
        return {
          headerSize: 1,
          commandId: data[0] & ~header.extraCode,
          commandSize: header.extraCode
        };
      }
      if (header.extraCode === extraCommandMask) {
        if (data.length < 3) {
          throw new Error('Invalid buffer size');
        }
        return {
          headerSize: 3,
          commandId: data[1] << 8 | extraCommandMask,
          commandSize: data[2]
        };
      }
      if (data.length < 2) {
        throw new Error('Invalid buffer size');
      }
      return {
        headerSize: 2,
        commandId: header.extraCode,
        commandSize: data[1]
      };
    };
    var toBytes$n = function toBytes(commandId, commandSize) {
      if ((commandId & extraCommandMask) === 0) {
        if (commandSize > extraCommandMask) {
          throw new Error("Wrong command id/size. Id: ".concat(commandId, ", size: ").concat(commandSize, "."));
        }
        return [commandId | commandSize];
      }
      if (commandId > extraCommandMask) {
        return [extraCommandMask, commandId >> 8, commandSize];
      }
      return [commandId, commandSize];
    };

    var toBytes$m = function toBytes(commandId) {
      var commandData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var headerData = toBytes$n(commandId, commandData.length);
      return [].concat(_toConsumableArray(headerData), _toConsumableArray(commandData));
    };

    var id$j = 0x0c;
    var name$j = 'correctTime2000';
    var COMMAND_BODY_SIZE$9 = 2;
    var fromBytes$j = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE$9) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new BinaryBuffer(data, false);
      var parameters = {
        sequenceNumber: buffer.getUint8(),
        seconds: buffer.getInt8()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    var toBytes$l = function toBytes(parameters) {
      var sequenceNumber = parameters.sequenceNumber,
        seconds = parameters.seconds;
      var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$9, false);
      buffer.setUint8(sequenceNumber);
      buffer.setInt8(seconds);
      return toBytes$m(id$j, buffer.data);
    };

    var id$i = 0x07;
    var name$i = 'getCurrent';
    var toBytes$k = function toBytes() {
      return toBytes$m(id$i);
    };

    var id$h = 0x18;
    var name$h = 'getCurrentMc';
    var toBytes$j = function toBytes() {
      return toBytes$m(id$h);
    };

    var fromObject = function fromObject() {
      var bitMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var booleanObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var result = 0;
      for (var name in booleanObject) {
        if (name in bitMask && booleanObject[name]) {
          result |= bitMask[name];
        }
      }
      return result;
    };
    var toObject = function toObject() {
      var bitMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var result = {};
      for (var name in bitMask) {
        result[name] = (value & bitMask[name]) !== 0;
      }
      return result;
    };

    var INITIAL_YEAR_TIMESTAMP = 946684800000;
    var MILLISECONDS_IN_SECONDS = 1000;
    var getDateFromTime2000 = function getDateFromTime2000(time2000) {
      return new Date(INITIAL_YEAR_TIMESTAMP + time2000 * MILLISECONDS_IN_SECONDS);
    };
    var getTime2000FromDate = function getTime2000FromDate(date) {
      return (date.getTime() - INITIAL_YEAR_TIMESTAMP) / MILLISECONDS_IN_SECONDS;
    };

    var GASI1 = 1;
    var GASI2 = 2;
    var GASI3 = 3;
    var NOVATOR = 4;
    var IMP2EU = 5;
    var IMP4EU = 6;
    var MTXLORA = 7;
    var IMP2AS = 8;
    var IMP2IN = 9;
    var IMP4IN = 10;
    var ELIMP = 11;
    var GASIC = 12;

    var invertObject = (function (source) {
      var target = {};
      for (var property in source) {
        var value = source[property];
        target[value] = property;
      }
      return target;
    });

    var INITIAL_YEAR = 2000;
    var MONTH_BIT_SIZE = 4;
    var DATE_BIT_SIZE = 5;
    var YEAR_START_INDEX = 1;
    var UNKNOWN_BATTERY_VOLTAGE = 4095;
    var EXTEND_BIT_MASK = 0x80;
    var LAST_BIT_INDEX = 7;
    var GAS_HARDWARE_TYPES = [GASI2, GASI3, GASI1, GASIC];
    var TWO_CHANNELS_HARDWARE_TYPES = [IMP2AS, IMP2EU, IMP2IN, NOVATOR];
    var ELIMP_HARDWARE_TYPES = [ELIMP];
    var FOUR_CHANNELS_HARDWARE_TYPES = [IMP4EU, IMP4IN];
    var MTX_HARDWARE_TYPES = [MTXLORA];
    var gasBitMask = {
      isBatteryLow: Math.pow(2, 0),
      isMagneticInfluence: Math.pow(2, 1),
      isButtonReleased: Math.pow(2, 2),
      isConnectionLost: Math.pow(2, 3)
    };
    var twoChannelBitMask = {
      isBatteryLow: Math.pow(2, 0),
      isConnectionLost: Math.pow(2, 3),
      isFirstChannelInactive: Math.pow(2, 4),
      isSecondChannelInactive: Math.pow(2, 5)
    };
    var elimpBitMask = {
      isConnectionLost: Math.pow(2, 3)
    };
    var fourChannelBitMask = {
      isBatteryLow: Math.pow(2, 0),
      isConnectionLost: Math.pow(2, 3),
      isFirstChannelInactive: Math.pow(2, 4),
      isSecondChannelInactive: Math.pow(2, 5),
      isThirdChannelInactive: Math.pow(2, 6),
      isForthChannelInactive: Math.pow(2, 7)
    };
    var mtxBitMask = {
      isMeterCaseOpen: Math.pow(2, 0),
      isMagneticInfluence: Math.pow(2, 1),
      isParametersSetRemotely: Math.pow(2, 2),
      isParametersSetLocally: Math.pow(2, 3),
      isMeterProgramRestarted: Math.pow(2, 4),
      isLockedOut: Math.pow(2, 5),
      isTimeSet: Math.pow(2, 6),
      isTimeCorrected: Math.pow(2, 7),
      isMeterFailure: Math.pow(2, 8),
      isMeterTerminalBoxOpen: Math.pow(2, 9),
      isModuleCompartmentOpen: Math.pow(2, 10),
      isTariffPlanChanged: Math.pow(2, 11),
      isNewTariffPlanReceived: Math.pow(2, 12)
    };
    var byteToPulseCoefficientMap = {
      128: 1,
      129: 5,
      130: 10,
      131: 100,
      132: 1000,
      133: 10000,
      134: 100000
    };
    var pulseCoefficientToByteMap = invertObject(byteToPulseCoefficientMap);
    var isMSBSet = function isMSBSet(value) {
      return !!(value & 0x80);
    };
    function CommandBinaryBuffer(dataOrLength) {
      var isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      BinaryBuffer.call(this, dataOrLength, isLittleEndian);
    }
    CommandBinaryBuffer.prototype = Object.create(BinaryBuffer.prototype);
    CommandBinaryBuffer.prototype.constructor = CommandBinaryBuffer;
    CommandBinaryBuffer.prototype.getExtendedValue = function () {
      var value = 0;
      var isByteExtended = true;
      var position = 0;
      while (isByteExtended && this.offset <= this.data.length) {
        var _byte3 = this.getUint8();
        isByteExtended = !!(_byte3 & EXTEND_BIT_MASK);
        value += (_byte3 & 0x7f) << 7 * position;
        ++position;
      }
      if (value < 0) {
        value = 0;
      }
      return value;
    };
    CommandBinaryBuffer.prototype.setExtendedValue = function (value) {
      var _this = this;
      if (value === 0) {
        this.setUint8(0);
        return;
      }
      var data = [];
      var encodedValue = value;
      while (encodedValue) {
        data.push(EXTEND_BIT_MASK | encodedValue & 0x7f);
        encodedValue >>= 7;
      }
      var lastByte = data.pop();
      if (lastByte) {
        data.push(lastByte & 0x7f);
      }
      data.forEach(function (extendedValue) {
        return _this.setUint8(extendedValue);
      });
    };
    CommandBinaryBuffer.prototype.getExtendedValueSize = function (bits) {
      var extBits = Math.ceil(bits / 7);
      var totalBits = bits + extBits;
      var extBytes = Math.ceil(totalBits / 8);
      return extBytes;
    };
    CommandBinaryBuffer.prototype.getTime = function () {
      return this.getUint32(false);
    };
    CommandBinaryBuffer.prototype.setTime = function (value) {
      this.setUint32(value, false);
    };
    CommandBinaryBuffer.prototype.getBatteryVoltage = function () {
      var lowVoltageByte = this.getUint8();
      var lowAndHightVoltageByte = this.getUint8();
      var highVoltageByte = this.getUint8();
      var underLowLoad = lowVoltageByte << 4;
      underLowLoad |= (lowAndHightVoltageByte & 0xf0) >> 4;
      var underHighLoad = (lowAndHightVoltageByte & 0x0f) << 8 | highVoltageByte;
      if (underHighLoad === UNKNOWN_BATTERY_VOLTAGE) {
        underHighLoad = undefined;
      }
      if (underLowLoad === UNKNOWN_BATTERY_VOLTAGE) {
        underLowLoad = undefined;
      }
      return {
        underLowLoad: underLowLoad,
        underHighLoad: underHighLoad
      };
    };
    CommandBinaryBuffer.prototype.setBatteryVoltage = function (batteryVoltage) {
      var _this2 = this;
      var underLowLoad = batteryVoltage.underLowLoad,
        underHighLoad = batteryVoltage.underHighLoad;
      if (underLowLoad === undefined) {
        underLowLoad = UNKNOWN_BATTERY_VOLTAGE;
      }
      if (underHighLoad === undefined) {
        underHighLoad = UNKNOWN_BATTERY_VOLTAGE;
      }
      var lowVoltageByte = underLowLoad >> 4 & 0xff;
      var lowAndHighVoltageByte = (underLowLoad & 0x0f) << 4 | underHighLoad >> 8 & 0x0f;
      var highVoltageByte = underHighLoad & 0xff;
      [lowVoltageByte, lowAndHighVoltageByte, highVoltageByte].forEach(function (_byte4) {
        return _this2.setUint8(_byte4);
      });
    };
    CommandBinaryBuffer.prototype.getChannels = function () {
      var channelList = [];
      var extended = true;
      var channelIndex = 1;
      while (extended) {
        var _byte5 = this.getUint8();
        var bits = _byte5.toString(2).padStart(LAST_BIT_INDEX + 1, '0').split('').reverse();
        bits.forEach(function (bit, index) {
          var value = Number(bit);
          if (index === LAST_BIT_INDEX) {
            extended = !!value;
          } else {
            if (value) {
              channelList.push(channelIndex);
            }
            ++channelIndex;
          }
        });
      }
      return channelList;
    };
    CommandBinaryBuffer.prototype.setChannels = function (channelList) {
      var _this3 = this;
      if (channelList.length === 0) {
        this.setUint8(0);
        return;
      }
      channelList.sort(function (a, b) {
        return a.index - b.index;
      });
      var maxChannel = Math.max.apply(Math, _toConsumableArray(channelList.map(function (_ref) {
        var index = _ref.index;
        return index;
      })));
      var size = (maxChannel - maxChannel % 8) / 8;
      var data = new Array(size + 1).fill(0);
      var _byte6 = 0;
      data.forEach(function (_, byteIndex) {
        var channelIndex = byteIndex * LAST_BIT_INDEX + 1;
        var maxChannelIndex = channelIndex + LAST_BIT_INDEX;
        while (channelIndex < maxChannelIndex) {
          var channel = channelList.find(function (item) {
            return item.index === channelIndex;
          });
          if (channel !== undefined) {
            _byte6 |= 1 << (channel.index - 1) % LAST_BIT_INDEX;
          }
          ++channelIndex;
        }
        if (data[byteIndex + 1] !== undefined) {
          _byte6 |= 1 << LAST_BIT_INDEX;
        }
        data[byteIndex] = _byte6;
        _byte6 = 0;
      });
      data.forEach(function (value) {
        return _this3.setUint8(value);
      });
    };
    CommandBinaryBuffer.prototype.getChannelsValuesWithHourDiff = function () {
      var _this4 = this;
      var date = this.getDate();
      var _this$getHours = this.getHours(),
        hour = _this$getHours.hour,
        hours = _this$getHours.hours;
      var channels = this.getChannels();
      var channelList = [];
      date.setUTCHours(hour);
      channels.forEach(function (channelIndex) {
        var diff = [];
        var value = _this4.getExtendedValue();
        for (var diffHour = 1; diffHour < hours; ++diffHour) {
          diff.push(_this4.getExtendedValue());
        }
        channelList.push({
          value: value,
          diff: diff,
          index: channelIndex
        });
      });
      return {
        startTime2000: getTime2000FromDate(date),
        hours: hours,
        channelList: channelList
      };
    };
    CommandBinaryBuffer.prototype.setChannelsValuesWithHourDiff = function (hours, startTime2000, channelList) {
      var _this5 = this;
      var date = getDateFromTime2000(startTime2000);
      var hour = date.getUTCHours();
      this.setDate(date);
      this.setHours(hour, hours);
      this.setChannels(channelList);
      channelList.forEach(function (_ref2) {
        var value = _ref2.value,
          diff = _ref2.diff;
        _this5.setExtendedValue(value);
        diff.forEach(function (diffValue) {
          return _this5.setExtendedValue(diffValue);
        });
      });
    };
    CommandBinaryBuffer.prototype.getHours = function () {
      var _byte7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getUint8();
      if (_byte7 === 0) {
        return {
          hours: 0,
          hour: 0
        };
      }
      var hours = ((_byte7 & 0xe0) >> 5) + 1;
      var hour = _byte7 & 0x1f;
      return {
        hours: hours,
        hour: hour
      };
    };
    CommandBinaryBuffer.prototype.setHours = function (hour, hours) {
      if (hour === 0 && hours === 0) {
        this.setUint8(0);
        return;
      }
      this.setUint8((hours - 1 & 0x07) << 5 | hour & 0x1f);
    };
    CommandBinaryBuffer.prototype.getDate = function () {
      var yearMonthByte = this.getUint8();
      var monthDateByte = this.getUint8();
      var year = yearMonthByte >> YEAR_START_INDEX;
      var month = (yearMonthByte & 0x01) << MONTH_BIT_SIZE - YEAR_START_INDEX | monthDateByte >> DATE_BIT_SIZE;
      var monthDay = monthDateByte & 0x1f;
      return new Date(Date.UTC(year + INITIAL_YEAR, month - 1, monthDay, 0, 0, 0, 0));
    };
    CommandBinaryBuffer.prototype.setDate = function (dateOrTime) {
      var _this6 = this;
      var date;
      if (dateOrTime instanceof Date) {
        date = dateOrTime;
      } else {
        date = getDateFromTime2000(dateOrTime);
      }
      var year = date.getUTCFullYear() - INITIAL_YEAR;
      var month = date.getUTCMonth() + 1;
      var day = date.getUTCDate();
      var yearMonthByte = year << YEAR_START_INDEX | month >> MONTH_BIT_SIZE - YEAR_START_INDEX;
      var monthDateByte = (month & 0x07) << DATE_BIT_SIZE | day;
      [yearMonthByte, monthDateByte].forEach(function (_byte8) {
        return _this6.setUint8(_byte8);
      });
    };
    CommandBinaryBuffer.prototype.getPulseCoefficient = function () {
      var pulseCoefficient = this.getUint8();
      if (isMSBSet(pulseCoefficient)) {
        var value = byteToPulseCoefficientMap[pulseCoefficient];
        if (value) {
          return value;
        }
        throw new Error('pulseCoefficient MSB is set, but value unknown');
      }
      return pulseCoefficient;
    };
    CommandBinaryBuffer.prototype.setPulseCoefficient = function (value) {
      if (value in pulseCoefficientToByteMap) {
        var _byte9 = pulseCoefficientToByteMap[value];
        if (_byte9) {
          this.setUint8(_byte9);
        } else {
          throw new Error('pulseCoefficient MSB is set, but value unknown');
        }
      } else {
        this.setUint8(value);
      }
    };
    CommandBinaryBuffer.prototype.getChannelsWithAbsoluteValues = function () {
      var _this7 = this;
      var channels = this.getChannels();
      var channelList = [];
      channels.forEach(function (channelIndex) {
        channelList.push({
          pulseCoefficient: _this7.getPulseCoefficient(),
          value: _this7.getExtendedValue(),
          index: channelIndex
        });
      });
      return channelList;
    };
    CommandBinaryBuffer.prototype.setChannelsWithAbsoluteValues = function (channelList) {
      var _this8 = this;
      this.setChannels(channelList);
      channelList.forEach(function (_ref3) {
        var value = _ref3.value,
          pulseCoefficient = _ref3.pulseCoefficient;
        _this8.setPulseCoefficient(pulseCoefficient);
        _this8.setExtendedValue(value);
      });
    };
    CommandBinaryBuffer.prototype.getChannelsAbsoluteValuesWithHourDiff = function (hours) {
      var _this9 = this;
      var channels = this.getChannels();
      var channelList = [];
      channels.forEach(function (channelIndex) {
        var pulseCoefficient = _this9.getPulseCoefficient();
        var value = _this9.getExtendedValue();
        var diff = [];
        for (var hourIndex = 1; hourIndex < hours; ++hourIndex) {
          diff.push(_this9.getExtendedValue());
        }
        channelList.push({
          diff: diff,
          value: value,
          pulseCoefficient: pulseCoefficient,
          index: channelIndex
        });
      });
      return channelList;
    };
    CommandBinaryBuffer.prototype.setChannelsAbsoluteValuesWithHourDiff = function (channelList) {
      var _this10 = this;
      this.setChannels(channelList);
      channelList.forEach(function (_ref4) {
        var value = _ref4.value,
          diff = _ref4.diff,
          pulseCoefficient = _ref4.pulseCoefficient;
        _this10.setPulseCoefficient(pulseCoefficient);
        _this10.setExtendedValue(value);
        diff.forEach(function (diffValue) {
          return _this10.setExtendedValue(diffValue);
        });
      });
    };
    CommandBinaryBuffer.prototype.getEventStatus = function (hardwareType) {
      var status;
      if (GAS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(gasBitMask, this.getUint8());
      } else if (TWO_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(twoChannelBitMask, this.getUint8());
      } else if (ELIMP_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(elimpBitMask, this.getUint8());
      } else if (FOUR_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(fourChannelBitMask, this.getExtendedValue());
      } else if (MTX_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(mtxBitMask, this.getUint16());
      } else {
        throw new Error('wrong hardwareType');
      }
      return status;
    };
    CommandBinaryBuffer.prototype.setEventStatus = function (hardwareType, status) {
      if (GAS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        this.setUint8(fromObject(gasBitMask, status));
      } else if (TWO_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        this.setUint8(fromObject(twoChannelBitMask, status));
      } else if (ELIMP_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        this.setUint8(fromObject(elimpBitMask, status));
      } else if (FOUR_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        this.setExtendedValue(fromObject(fourChannelBitMask, status));
      } else if (MTX_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        this.setUint16(fromObject(mtxBitMask, status));
      } else {
        throw new Error('wrong hardwareType');
      }
    };

    var id$g = 0x0b;
    var name$g = 'getArchiveEvents';
    var COMMAND_BODY_SIZE$8 = 5;
    var fromBytes$i = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE$8) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new CommandBinaryBuffer(data);
      var startTime2000 = buffer.getTime();
      var events = buffer.getUint8();
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        startTime2000: startTime2000,
        events: events
      };
    };
    var toBytes$i = function toBytes(parameters) {
      var startTime2000 = parameters.startTime2000,
        events = parameters.events;
      var buffer = new CommandBinaryBuffer(COMMAND_BODY_SIZE$8);
      buffer.setTime(startTime2000);
      buffer.setUint8(events);
      return toBytes$m(id$g, buffer.data);
    };

    var id$f = 0x021f;
    var name$f = 'getLmicInfo';
    var COMMAND_BODY_SIZE$7 = 0;
    var fromBytes$h = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE$7) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      return {};
    };
    var toBytes$h = function toBytes() {
      return toBytes$m(id$f);
    };

    var id$e = 0x14;
    var name$e = 'getStatus';
    var COMMAND_BODY_SIZE$6 = 0;
    var fromBytes$g = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE$6) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      return {};
    };
    var toBytes$g = function toBytes() {
      return toBytes$m(id$e);
    };

    var id$d = 0x09;
    var name$d = 'getTime2000';
    var COMMAND_BODY_SIZE$5 = 0;
    var fromBytes$f = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE$5) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      return {};
    };
    var toBytes$f = function toBytes() {
      return toBytes$m(id$d, []);
    };

    var id$c = 0x02;
    var name$c = 'setTime2000';
    var COMMAND_BODY_SIZE$4 = 5;
    var fromBytes$e = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE$4) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new BinaryBuffer(data, false);
      var parameters = {
        sequenceNumber: buffer.getUint8(),
        seconds: buffer.getInt32()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    var toBytes$e = function toBytes(parameters) {
      var sequenceNumber = parameters.sequenceNumber,
        seconds = parameters.seconds;
      var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$4, false);
      buffer.setUint8(sequenceNumber);
      buffer.setInt32(seconds);
      return toBytes$m(id$c, buffer.data);
    };

    var calculateLrc = (function (data) {
      var initialLrc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0x55;
      var lrc = initialLrc;
      data.forEach(function (item) {
        lrc ^= item;
      });
      return lrc;
    });

    var HEADER_MAX_SIZE = 3;
    var getFromBytes = function getFromBytes(fromBytesMap, nameMap) {
      return function () {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var config = arguments.length > 1 ? arguments[1] : undefined;
        var commands = [];
        var message = {
          commands: commands,
          bytes: data,
          lrc: {
            expected: undefined,
            actual: 0
          }
        };
        var processedBytes = 0;
        var expectedLrc;
        var actualLrc;
        do {
          var headerInfo = fromBytes$k(data.slice(processedBytes, processedBytes + HEADER_MAX_SIZE));
          var headerData = data.slice(processedBytes, processedBytes + headerInfo.headerSize);
          var bodyData = data.slice(processedBytes + headerInfo.headerSize, processedBytes + headerInfo.headerSize + headerInfo.commandSize);
          var command = {
            id: headerInfo.commandId,
            name: nameMap[headerInfo.commandId],
            headerSize: headerInfo.headerSize,
            bytes: [].concat(_toConsumableArray(headerData), _toConsumableArray(bodyData))
          };
          processedBytes = processedBytes + headerInfo.headerSize + headerInfo.commandSize;
          if (config) {
            command.config = config;
          }
          try {
            command.parameters = fromBytesMap[headerInfo.commandId](bodyData, config);
            commands.push(command);
          } catch (error) {
            commands.push({
              command: command,
              error: error.message
            });
          }
        } while (processedBytes < data.length - 1);
        if (data.length - processedBytes === 1) {
          expectedLrc = data[data.length - 1];
          actualLrc = calculateLrc(data.slice(0, -1));
        } else {
          actualLrc = calculateLrc(data);
        }
        message.lrc.actual = actualLrc;
        message.lrc.expected = expectedLrc;
        if (expectedLrc === actualLrc) {
          return message;
        }
        return {
          message: message,
          error: 'mismatch LRC'
        };
      };
    };
    var getToBytes = function getToBytes(toBytesMap) {
      return function (commands) {
        var _ref;
        var commandBytes = commands.map(function (command) {
          if ('parameters' in command) {
            return toBytesMap[command.id](command.parameters, command.config);
          }
          if ('command' in command) {
            return command.command.bytes;
          }
          throw new Error('wrong command format');
        });
        var body = (_ref = []).concat.apply(_ref, _toConsumableArray(commandBytes));
        return [].concat(_toConsumableArray(body), [calculateLrc(body)]);
      };
    };

    var toBytesMap$1 = {};
    var fromBytesMap$1 = {};
    var nameMap$1 = {};
    var toBytes$d = getToBytes(toBytesMap$1);
    toBytesMap$1[id$j] = toBytes$l;
    toBytesMap$1[id$i] = toBytes$k;
    toBytesMap$1[id$h] = toBytes$j;
    toBytesMap$1[id$g] = toBytes$i;
    toBytesMap$1[id$f] = toBytes$h;
    toBytesMap$1[id$e] = toBytes$g;
    toBytesMap$1[id$d] = toBytes$f;
    toBytesMap$1[id$c] = toBytes$e;
    fromBytesMap$1[id$j] = fromBytes$j;
    fromBytesMap$1[id$i] = toBytes$k;
    fromBytesMap$1[id$h] = toBytes$j;
    fromBytesMap$1[id$g] = fromBytes$i;
    fromBytesMap$1[id$f] = fromBytes$h;
    fromBytesMap$1[id$e] = fromBytes$g;
    fromBytesMap$1[id$d] = fromBytes$f;
    fromBytesMap$1[id$c] = fromBytes$e;
    nameMap$1[id$j] = name$j;
    nameMap$1[id$i] = name$i;
    nameMap$1[id$h] = name$h;
    nameMap$1[id$g] = name$g;
    nameMap$1[id$f] = name$f;
    nameMap$1[id$e] = name$e;
    nameMap$1[id$d] = name$d;
    nameMap$1[id$c] = name$c;

    var id$b = 0x0c;
    var name$b = 'correctTime2000';
    var COMMAND_BODY_SIZE$3 = 1;
    var fromBytes$d = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE$3) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new BinaryBuffer(data, false);
      var parameters = {
        status: buffer.getUint8()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    var toBytes$c = function toBytes(parameters) {
      var status = parameters.status;
      var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$3, false);
      buffer.setUint8(status);
      return toBytes$m(id$b, buffer.data);
    };

    var id$a = 0x18;
    var name$a = 'currentMC';
    var COMMAND_BODY_MAX_SIZE$6 = 37;
    var fromBytes$c = function fromBytes(data) {
      if (data.length > COMMAND_BODY_MAX_SIZE$6) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var parameters = {
        channelList: []
      };
      var buffer = new CommandBinaryBuffer(data);
      var channelList = buffer.getChannels();
      parameters.channelList = channelList.map(function (channelIndex) {
        return {
          value: buffer.getExtendedValue(),
          index: channelIndex
        };
      });
      return parameters;
    };
    var toBytes$b = function toBytes(parameters) {
      var buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$6);
      var channelList = parameters.channelList;
      buffer.setChannels(channelList);
      channelList.forEach(function (_ref) {
        var value = _ref.value;
        buffer.setExtendedValue(value);
      });
      return toBytes$m(id$a, buffer.getBytesToOffset());
    };

    var id$9 = 0x16;
    var name$9 = 'dayMC';
    var COMMAND_BODY_MAX_SIZE$5 = 32;
    var fromBytes$b = function fromBytes(data) {
      if (data.length > COMMAND_BODY_MAX_SIZE$5) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new CommandBinaryBuffer(data);
      var date = buffer.getDate();
      var channels = buffer.getChannels();
      var channelList = channels.map(function (channelIndex) {
        return {
          value: buffer.getExtendedValue(),
          index: channelIndex
        };
      });
      return {
        startTime2000: getTime2000FromDate(date),
        channelList: channelList
      };
    };
    var toBytes$a = function toBytes(parameters) {
      var buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$5);
      var channelList = parameters.channelList,
        startTime2000 = parameters.startTime2000;
      buffer.setDate(startTime2000);
      buffer.setChannels(channelList);
      channelList.forEach(function (_ref) {
        var value = _ref.value;
        buffer.setExtendedValue(value);
      });
      return toBytes$m(id$9, buffer.getBytesToOffset());
    };

    var id$8 = 0x0b1f;
    var name$8 = 'exAbsDayMC';
    var COMMAND_BODY_MAX_SIZE$4 = 89;
    var fromBytes$a = function fromBytes(data) {
      if (data.length > COMMAND_BODY_MAX_SIZE$4) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new CommandBinaryBuffer(data);
      var date = buffer.getDate();
      var channelList = buffer.getChannelsWithAbsoluteValues();
      return {
        startTime2000: getTime2000FromDate(date),
        channelList: channelList
      };
    };
    var toBytes$9 = function toBytes(parameters) {
      var buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$4);
      var startTime2000 = parameters.startTime2000,
        channelList = parameters.channelList;
      buffer.setDate(startTime2000);
      buffer.setChannelsWithAbsoluteValues(channelList);
      return toBytes$m(id$8, buffer.getBytesToOffset());
    };

    var id$7 = 0x0a1f;
    var name$7 = 'exAbsHourMC';
    var COMMAND_BODY_MAX_SIZE$3 = 168;
    var fromBytes$9 = function fromBytes(data) {
      if (data.length > COMMAND_BODY_MAX_SIZE$3) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new CommandBinaryBuffer(data);
      var date = buffer.getDate();
      var _buffer$getHours = buffer.getHours(),
        hour = _buffer$getHours.hour,
        hours = _buffer$getHours.hours;
      var channelList = buffer.getChannelsAbsoluteValuesWithHourDiff(hours);
      date.setUTCHours(hour);
      return {
        startTime2000: getTime2000FromDate(date),
        hours: hours,
        channelList: channelList
      };
    };
    var toBytes$8 = function toBytes(parameters) {
      var buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$3);
      var startTime2000 = parameters.startTime2000,
        hours = parameters.hours,
        channelList = parameters.channelList;
      var date = getDateFromTime2000(startTime2000);
      var hour = date.getUTCHours();
      buffer.setDate(startTime2000);
      buffer.setHours(hour, hours);
      buffer.setChannelsAbsoluteValuesWithHourDiff(channelList);
      return toBytes$m(id$7, buffer.getBytesToOffset());
    };

    var id$6 = 0x0b;
    var name$6 = 'getArchiveEvents';
    var COMMAND_BODY_MIN_SIZE = 4 + 1 + 1;
    var getEvent = function getEvent(buffer) {
      return {
        time2000: buffer.getTime(),
        id: buffer.getUint8(),
        sequenceNumber: buffer.getUint8()
      };
    };
    var setEvent = function setEvent(buffer, event) {
      buffer.setTime(event.time2000);
      buffer.setUint8(event.id);
      buffer.setUint8(event.sequenceNumber);
    };
    var fromBytes$8 = function fromBytes(data) {
      var buffer = new CommandBinaryBuffer(data, false);
      var eventList = [];
      while (buffer.bytesLeft > 0) {
        eventList.push(getEvent(buffer));
      }
      return {
        eventList: eventList
      };
    };
    function toBytes$7(parameters) {
      var eventList = parameters.eventList;
      var buffer = new CommandBinaryBuffer(eventList.length * COMMAND_BODY_MIN_SIZE, false);
      eventList.forEach(function (event) {
        return setEvent(buffer, event);
      });
      return toBytes$m(id$6, buffer.data);
    }

    var id$5 = 0x021f;
    var name$5 = 'getLmicInfo';
    var COMMAND_BODY_SIZE$2 = 2;
    var lmicCapabilitiesBitMask = {
      isMulticastSupported: 1 << 0,
      isFragmentedDataSupported: 1 << 1
    };
    var fromBytes$7 = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE$2) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new BinaryBuffer(data);
      var capabilities = toObject(lmicCapabilitiesBitMask, buffer.getUint8());
      var version = buffer.getUint8();
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        capabilities: capabilities,
        version: version
      };
    };
    var toBytes$6 = function toBytes(parameters) {
      var capabilities = parameters.capabilities,
        version = parameters.version;
      var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$2);
      buffer.setUint8(fromObject(lmicCapabilitiesBitMask, capabilities));
      buffer.setUint8(version);
      return toBytes$m(id$5, buffer.data);
    };

    var id$4 = 0x17;
    var name$4 = 'hourMC';
    var COMMAND_BODY_MAX_SIZE$2 = 164;
    var fromBytes$6 = function fromBytes(data) {
      if (data.length > COMMAND_BODY_MAX_SIZE$2) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new CommandBinaryBuffer(data);
      return buffer.getChannelsValuesWithHourDiff();
    };
    var toBytes$5 = function toBytes(parameters) {
      var buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$2);
      var startTime2000 = parameters.startTime2000,
        hours = parameters.hours,
        channelList = parameters.channelList;
      buffer.setChannelsValuesWithHourDiff(hours, startTime2000, channelList);
      return toBytes$m(id$4, buffer.getBytesToOffset());
    };

    var MAGNET_ON = 1;
    var MAGNET_OFF = 2;
    var ACTIVATE = 3;
    var DEACTIVATE = 4;
    var BATTERY_ALARM = 5;
    var CAN_OFF = 6;
    var INSERT = 7;
    var REMOVE = 8;
    var COUNTER_OVER = 9;
    var ACTIVATE_MTX = 11;
    var CONNECT = 12;
    var DISCONNECT = 13;
    var OPTOLOW = 15;
    var OPTOFLASH = 16;
    var MTX = 17;
    var JOIN_ACCEPT = 18;

    var getHexFromBytes = (function (bytes) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _Object$assign = Object.assign({}, hexFormatOptions, options),
        separator = _Object$assign.separator,
        prefix = _Object$assign.prefix;
      return bytes.map(function (_byte) {
        return "".concat(prefix).concat(_byte.toString(16).padStart(2, '0'));
      }).join(separator);
    });

    var getBytesFromHex = (function (hex) {
      var cleanHex = hex.replace(/\s+|0x/g, '');
      if (cleanHex.length % 2 !== 0) {
        cleanHex = "0".concat(cleanHex);
      }
      var resultLength = cleanHex.length / 2;
      var bytes = new Array(resultLength);
      for (var index = 0; index < resultLength; index++) {
        bytes[index] = parseInt(cleanHex.substring(index * 2, index * 2 + 2), 16);
      }
      return bytes;
    });

    var id$3 = 0x15;
    var name$3 = 'newEvent';
    var COMMAND_BODY_MAX_SIZE$1 = 14;
    var MTX_ADDRESS_SIZE = 8;
    var getVoltage = function getVoltage(buffer) {
      return buffer.getUint16(false);
    };
    var setVoltage = function setVoltage(buffer, value) {
      return buffer.setUint16(value, false);
    };
    var getDeviceId = function getDeviceId(buffer) {
      return getHexFromBytes(buffer.getBytes(MTX_ADDRESS_SIZE));
    };
    var setDeviceId = function setDeviceId(buffer, value) {
      getBytesFromHex(value).forEach(function (_byte) {
        return buffer.setUint8(_byte);
      });
    };
    var fromBytes$5 = function fromBytes(data) {
      if (data.length > COMMAND_BODY_MAX_SIZE$1) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new CommandBinaryBuffer(data);
      var eventId = buffer.getUint8();
      var sequenceNumber = buffer.getUint8();
      var eventData;
      switch (eventId) {
        case MAGNET_ON:
        case MAGNET_OFF:
        case ACTIVATE:
        case DEACTIVATE:
        case CAN_OFF:
        case INSERT:
        case REMOVE:
        case COUNTER_OVER:
        case OPTOLOW:
        case OPTOFLASH:
        case JOIN_ACCEPT:
          eventData = {
            time2000: buffer.getTime()
          };
          break;
        case BATTERY_ALARM:
          eventData = {
            voltage: getVoltage(buffer)
          };
          break;
        case ACTIVATE_MTX:
          eventData = {
            time2000: buffer.getTime(),
            deviceId: getDeviceId(buffer)
          };
          break;
        case CONNECT:
        case DISCONNECT:
          eventData = {
            channel: buffer.getUint8() + 1,
            value: buffer.getExtendedValue()
          };
          break;
        case MTX:
          eventData = {
            status: buffer.getEventStatus(MTXLORA)
          };
          break;
        default:
          throw new Error("Event ".concat(id$3, " is not supported"));
      }
      return {
        id: eventId,
        sequenceNumber: sequenceNumber,
        data: eventData
      };
    };
    var toBytes$4 = function toBytes(parameters) {
      var buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE$1);
      var eventId = parameters.id,
        sequenceNumber = parameters.sequenceNumber,
        data = parameters.data;
      buffer.setUint8(eventId);
      buffer.setUint8(sequenceNumber);
      switch (eventId) {
        case MAGNET_ON:
        case MAGNET_OFF:
        case ACTIVATE:
        case DEACTIVATE:
        case CAN_OFF:
        case INSERT:
        case REMOVE:
        case COUNTER_OVER:
        case OPTOLOW:
        case OPTOFLASH:
        case JOIN_ACCEPT:
          buffer.setTime(data.time2000);
          break;
        case BATTERY_ALARM:
          setVoltage(buffer, data.voltage);
          break;
        case ACTIVATE_MTX:
          buffer.setTime(data.time2000);
          setDeviceId(buffer, data.deviceId);
          break;
        case CONNECT:
        case DISCONNECT:
          buffer.setUint8(data.channel - 1);
          buffer.setExtendedValue(data.value);
          break;
        case MTX:
          buffer.setEventStatus(MTXLORA, data.status);
          break;
        default:
          throw new Error("Event ".concat(id$3, " is not supported"));
      }
      return toBytes$m(id$3, buffer.getBytesToOffset());
    };

    var id$2 = 0x02;
    var name$2 = 'setTime2000';
    var COMMAND_BODY_SIZE$1 = 1;
    var fromBytes$4 = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE$1) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new BinaryBuffer(data, false);
      var parameters = {
        status: buffer.getUint8()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    var toBytes$3 = function toBytes(parameters) {
      var status = parameters.status;
      var buffer = new BinaryBuffer(COMMAND_BODY_SIZE$1, false);
      buffer.setUint8(status);
      return toBytes$m(id$2, buffer.data);
    };

    var roundNumber = (function (value) {
      var decimalPlaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
      var places = Math.pow(10, decimalPlaces);
      return Math.round(value * places * (1 + Number.EPSILON)) / places;
    });

    var id$1 = 0x14;
    var name$1 = 'status';
    var COMMAND_BODY_MAX_SIZE = 20;
    var UNKNOWN_BATTERY_RESISTANCE = 65535;
    var UNKNOWN_BATTERY_CAPACITY = 255;
    var fromBytes$3 = function fromBytes(bytes) {
      var buffer = new CommandBinaryBuffer(bytes);
      var software = {
        type: buffer.getUint8(),
        version: buffer.getUint8()
      };
      var hardware = {
        type: buffer.getUint8(),
        version: buffer.getUint8()
      };
      var data;
      switch (hardware.type) {
        case GASI1:
        case GASI2:
        case GASI3:
        case NOVATOR:
        case IMP2EU:
        case IMP4EU:
        case IMP2AS:
        case IMP2IN:
        case IMP4IN:
        case GASIC:
          {
            var statusData = {
              batteryVoltage: buffer.getBatteryVoltage(),
              batteryInternalResistance: buffer.getUint16(false),
              temperature: buffer.getUint8(),
              remainingBatteryCapacity: buffer.getUint8(),
              lastEventSequenceNumber: buffer.getUint8()
            };
            if (statusData.batteryInternalResistance === UNKNOWN_BATTERY_RESISTANCE) {
              statusData.batteryInternalResistance = undefined;
            }
            if (statusData.remainingBatteryCapacity === UNKNOWN_BATTERY_CAPACITY) {
              statusData.remainingBatteryCapacity = undefined;
            } else if (statusData.remainingBatteryCapacity !== undefined) {
              statusData.remainingBatteryCapacity = roundNumber(statusData.remainingBatteryCapacity * 100 / (UNKNOWN_BATTERY_CAPACITY - 1), 0);
            }
            data = statusData;
          }
          break;
        case MTXLORA:
          data = {
            time2000: buffer.getUint32(),
            resetReason: buffer.getUint8(),
            rssiLastDownlinkFrame: buffer.getUint8(),
            snrLastDownlinkFrame: buffer.getUint8(),
            downlinkRequestsNumber: buffer.getUint8(),
            downlinkFragmentsNumber: buffer.getUint8(),
            uplinkResponsesNumber: buffer.getUint8(),
            uplinkFragmentsNumber: buffer.getUint8(),
            signalMarginToGateway: buffer.getUint8(),
            signalMarginFromGateway: buffer.getUint8(),
            detectedGatewaysNumber: buffer.getUint8(),
            gatewayDownlinkErrorRate: buffer.getUint8(),
            lastEventSequenceNumber: buffer.getUint8()
          };
          break;
        case ELIMP:
        default:
          throw new Error("".concat(id$1, ": hardware type ").concat(hardware.type, " is not supported"));
      }
      return {
        software: software,
        hardware: hardware,
        data: data
      };
    };
    var toBytes$2 = function toBytes(parameters) {
      var software = parameters.software,
        hardware = parameters.hardware,
        data = parameters.data;
      var buffer = new CommandBinaryBuffer(COMMAND_BODY_MAX_SIZE);
      buffer.setUint8(software.type);
      buffer.setUint8(software.version);
      buffer.setUint8(hardware.type);
      buffer.setUint8(hardware.version);
      switch (hardware.type) {
        case GASI1:
        case GASI2:
        case GASI3:
        case NOVATOR:
        case IMP2EU:
        case IMP4EU:
        case IMP2AS:
        case IMP2IN:
        case IMP4IN:
        case GASIC:
          {
            var statusData = data;
            buffer.setBatteryVoltage(statusData.batteryVoltage);
            if (statusData.batteryInternalResistance === undefined) {
              buffer.setUint16(UNKNOWN_BATTERY_RESISTANCE, false);
            } else {
              buffer.setUint16(statusData.batteryInternalResistance, false);
            }
            buffer.setUint8(statusData.temperature);
            if (statusData.remainingBatteryCapacity === undefined) {
              buffer.setUint8(UNKNOWN_BATTERY_CAPACITY);
            } else {
              buffer.setUint8((UNKNOWN_BATTERY_CAPACITY - 1) * (statusData.remainingBatteryCapacity / 100));
            }
            buffer.setUint8(statusData.lastEventSequenceNumber);
          }
          break;
        case MTXLORA:
          {
            var _statusData = data;
            buffer.setUint32(_statusData.time2000);
            buffer.setUint8(_statusData.resetReason);
            buffer.setUint8(_statusData.rssiLastDownlinkFrame);
            buffer.setUint8(_statusData.snrLastDownlinkFrame);
            buffer.setUint8(_statusData.downlinkRequestsNumber);
            buffer.setUint8(_statusData.downlinkFragmentsNumber);
            buffer.setUint8(_statusData.uplinkResponsesNumber);
            buffer.setUint8(_statusData.uplinkFragmentsNumber);
            buffer.setUint8(_statusData.signalMarginToGateway);
            buffer.setUint8(_statusData.signalMarginFromGateway);
            buffer.setUint8(_statusData.detectedGatewaysNumber);
            buffer.setUint8(_statusData.gatewayDownlinkErrorRate);
            buffer.setUint8(_statusData.lastEventSequenceNumber);
          }
          break;
        case ELIMP:
        default:
          throw new Error("".concat(id$1, ": hardware type ").concat(hardware.type, " is not supported"));
      }
      return toBytes$m(id$1, buffer.getBytesToOffset());
    };

    var id = 0x09;
    var name = 'time2000';
    var COMMAND_BODY_SIZE = 5;
    var fromBytes$2 = function fromBytes(data) {
      if (data.length !== COMMAND_BODY_SIZE) {
        throw new Error("Wrong buffer size: ".concat(data.length, "."));
      }
      var buffer = new CommandBinaryBuffer(data);
      var parameters = {
        sequenceNumber: buffer.getUint8(),
        time2000: buffer.getTime()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    function toBytes$1(parameters) {
      var sequenceNumber = parameters.sequenceNumber,
        time2000 = parameters.time2000;
      var buffer = new CommandBinaryBuffer(COMMAND_BODY_SIZE);
      buffer.setUint8(sequenceNumber);
      buffer.setTime(time2000);
      return toBytes$m(id, buffer.data);
    }

    var toBytesMap = {};
    var fromBytesMap = {};
    var nameMap = {};
    var fromBytes$1 = getFromBytes(fromBytesMap, nameMap);
    toBytesMap[id$b] = toBytes$c;
    toBytesMap[id$a] = toBytes$b;
    toBytesMap[id$9] = toBytes$a;
    toBytesMap[id$8] = toBytes$9;
    toBytesMap[id$7] = toBytes$8;
    toBytesMap[id$6] = toBytes$7;
    toBytesMap[id$5] = toBytes$6;
    toBytesMap[id$4] = toBytes$5;
    toBytesMap[id$3] = toBytes$4;
    toBytesMap[id$2] = toBytes$3;
    toBytesMap[id$1] = toBytes$2;
    toBytesMap[id] = toBytes$1;
    fromBytesMap[id$b] = fromBytes$d;
    fromBytesMap[id$a] = fromBytes$c;
    fromBytesMap[id$9] = fromBytes$b;
    fromBytesMap[id$8] = fromBytes$a;
    fromBytesMap[id$7] = fromBytes$9;
    fromBytesMap[id$6] = fromBytes$8;
    fromBytesMap[id$5] = fromBytes$7;
    fromBytesMap[id$4] = fromBytes$6;
    fromBytesMap[id$3] = fromBytes$5;
    fromBytesMap[id$2] = fromBytes$4;
    fromBytesMap[id$1] = fromBytes$3;
    fromBytesMap[id] = fromBytes$2;
    nameMap[id$b] = name$b;
    nameMap[id$a] = name$a;
    nameMap[id$9] = name$9;
    nameMap[id$8] = name$8;
    nameMap[id$7] = name$7;
    nameMap[id$6] = name$6;
    nameMap[id$5] = name$5;
    nameMap[id$4] = name$4;
    nameMap[id$3] = name$3;
    nameMap[id$2] = name$2;
    nameMap[id$1] = name$1;
    nameMap[id] = name;

    // export
    fromBytes = fromBytes$1;
    toBytes = toBytes$d;

})();
//#endregion


/*
  Get message form bytes.

  Input is an object with the following fields:
    * bytes - byte array containing the uplink payload, e.g. [255, 230, 255, 0]
    * fPort - uplink fPort
    * variables - object containing the configured device variables

  Output must be an object with the following fields:
    * data - object representing the decoded payload
*/
function decodeUplink ( input ) {
    return fromBytes(input.bytes, config);
};


/*
  Get payload bytes from commands.

  Input is an object with the following fields:
    * data - object representing the payload that must be encoded
    * variables - object containing the configured device variables

  Output must be an object with the following fields:
    * bytes - byte array containing the downlink payload
*/
function encodeDownlink ( input ) {
    return {
        bytes: toBytes(input.data, config)
    };
};
